<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario IA - Ultimate Enhanced Edition</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a1f, #1a1a3e, #2d1b69);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            min-height: 100vh;
        }

        h1 {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700, #9d4edd);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3em;
            margin: 15px 0;
            text-align: center;
            animation: gradientShift 4s ease-in-out infinite;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            font-weight: 900;
            letter-spacing: 2px;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 50% 0%; }
            50% { background-position: 100% 50%; }
            75% { background-position: 50% 100%; }
        }

        canvas {
            border: 4px solid transparent;
            background: linear-gradient(180deg, #000022, #001133, #000000);
            border-radius: 15px;
            position: relative;
            box-shadow:
                    0 0 50px rgba(78, 205, 196, 0.5),
                    inset 0 0 100px rgba(0, 0, 50, 0.4),
                    0 20px 40px rgba(0, 0, 0, 0.3);
            margin: 20px 0;
        }

        canvas::before {
            content: '';
            position: absolute;
            top: -4px; left: -4px; right: -4px; bottom: -4px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700);
            border-radius: 15px;
            z-index: -1;
            animation: borderGlow 3s ease-in-out infinite;
        }

        @keyframes borderGlow {
            0%, 100% { filter: brightness(1) hue-rotate(0deg); }
            50% { filter: brightness(1.3) hue-rotate(90deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 1000px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #2d3748, #4a5568, #2d3748);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid transparent;
            background-clip: padding-box;
            position: relative;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1, #ff6b6b, #ffd700);
            background-size: 300% 300%;
            border-radius: 15px;
            padding: 3px;
            z-index: -1;
            animation: cardGlow 6s ease-in-out infinite;
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.6s ease;
            z-index: 0;
        }

        .stat-card:hover::after {
            width: 200px;
            height: 200px;
        }

        @keyframes cardGlow {
            0%, 100% { background-position: 0% 50%; }
            33% { background-position: 100% 0%; }
            66% { background-position: 100% 100%; }
        }

        .stat-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(78, 205, 196, 0.4);
        }

        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #4ecdc4;
            font-weight: bold;
            z-index: 2;
            position: relative;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 900;
            color: #ff6b6b;
            text-shadow: 0 0 15px currentColor;
            z-index: 2;
            position: relative;
            animation: valueGlow 2s ease-in-out infinite;
        }

        @keyframes valueGlow {
            0%, 100% { text-shadow: 0 0 15px currentColor; }
            50% { text-shadow: 0 0 25px currentColor, 0 0 35px currentColor; }
        }

        .info-panel {
            margin: 25px 0;
            padding: 30px;
            background: linear-gradient(135deg, #2d3748, #4a5568, #2d3748);
            border-radius: 20px;
            text-align: center;
            min-width: 700px;
            border: 4px solid transparent;
            background-clip: padding-box;
            position: relative;
            overflow: hidden;
        }

        .info-panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700, #9d4edd);
            background-size: 400% 400%;
            border-radius: 20px;
            padding: 4px;
            z-index: -1;
            animation: gradientShift 5s ease-in-out infinite;
        }

        .progress-bar {
            width: 100%;
            height: 22px;
            background: linear-gradient(90deg, #1a1a2e, #16213e);
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.6);
            border: 2px solid #4a5568;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700, #9d4edd);
            background-size: 300% 100%;
            border-radius: 10px;
            transition: width 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            animation: progressShine 3s linear infinite;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: progressWave 2s ease-in-out infinite;
        }

        @keyframes progressShine {
            0% { background-position: -300% 0; }
            100% { background-position: 300% 0; }
        }

        @keyframes progressWave {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        button {
            padding: 18px 35px;
            font-size: 18px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            margin: 12px;
            font-weight: bold;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            font-family: inherit;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }

        button:hover::before { left: 100%; }
        button:hover:not(:disabled) {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(-2px) scale(1.02);
        }

        button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        .divine { color: #ffd700; text-shadow: 0 0 20px currentColor; }
        .legendary { color: #ff6b6b; text-shadow: 0 0 20px currentColor; }
        .transcendent { color: #9d4edd; text-shadow: 0 0 20px currentColor; }
        .play-btn { background: linear-gradient(45deg, #28a745, #20c997, #17a2b8) !important; }

        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 2.5s ease-out forwards;
            text-shadow: 0 0 10px currentColor;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0px) scale(1); }
            50% { opacity: 1; transform: translateY(-25px) scale(1.1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
        }

        .screen-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            z-index: 999;
            opacity: 0;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            width: 100%;
            max-width: 800px;
        }

        .difficulty-selector {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #4ecdc4;
        }

        .difficulty-selector h3 {
            color: #4ecdc4;
            margin: 0 0 15px 0;
        }

        .difficulty-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .diff-btn {
            padding: 10px 15px;
            font-size: 14px;
            margin: 5px;
        }

        .diff-btn.easy { background: linear-gradient(45deg, #28a745, #20c997); }
        .diff-btn.medium { background: linear-gradient(45deg, #ffc107, #fd7e14); }
        .diff-btn.hard { background: linear-gradient(45deg, #dc3545, #e83e8c); }
        .diff-btn.nightmare { background: linear-gradient(45deg, #6f42c1, #e83e8c); }

        .diff-btn.active {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.8);
            transform: scale(1.1);
        }

        .ai-status {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff6b6b;
        }

        .ai-status h3 {
            color: #ff6b6b;
            margin: 0 0 15px 0;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-indicator.active {
            background: #28a745;
        }

        .status-indicator.training {
            background: #ffc107;
        }

        .status-indicator.idle {
            background: #6c757d;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls-hint {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #4ecdc4;
            font-size: 14px;
            opacity: 0.9;
        }

        .leaderboard {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid #ffd700;
            width: 100%;
            max-width: 600px;
        }

        .leaderboard h3 {
            color: #ffd700;
            margin: 0 0 15px 0;
            text-align: center;
        }

        .score-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(78, 205, 196, 0.2);
        }

        .score-entry:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .info-panel {
                min-width: auto;
                width: 95%;
            }

            canvas {
                width: 95%;
                height: auto;
            }

            h1 {
                font-size: 2em;
            }

            .game-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
<div class="screen-flash" id="screenFlash"></div>

<h1>⚡ Mario IA - Ultimate Enhanced Edition 🚀</h1>

<div class="info-panel">
    <h3 class="legendary">IA ADAPTATIVE | Système d'Apprentissage Avancé | QI Évolutif</h3>
    <div class="progress-bar">
        <div class="progress-fill" id="progressBar" style="width: 100%"></div>
    </div>
    <p id="statusText">IA prête à l'entraînement | Sélectionnez une difficulté et commencez</p>
</div>

<div class="game-info">
    <div class="difficulty-selector">
        <h3>🎯 Sélection de Difficulté</h3>
        <div class="difficulty-buttons">
            <button class="diff-btn easy active" onclick="setDifficulty('easy')">Facile</button>
            <button class="diff-btn medium" onclick="setDifficulty('medium')">Moyen</button>
            <button class="diff-btn hard" onclick="setDifficulty('hard')">Difficile</button>
            <button class="diff-btn nightmare" onclick="setDifficulty('nightmare')">Cauchemar</button>
        </div>
        <p style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
            Difficulté actuelle: <span id="currentDifficulty">Facile</span>
        </p>
    </div>

    <div class="ai-status">
        <h3>🤖 État de l'IA</h3>
        <p><span class="status-indicator idle" id="aiStatusIndicator"></span><span id="aiStatusText">En attente</span></p>
        <p style="font-size: 14px; margin-top: 10px;">Niveau d'adaptation: <span id="adaptationLevel">Débutant</span></p>
    </div>
</div>

<canvas id="gameCanvas" width="900" height="500"></canvas>

<div class="stats">
    <div class="stat-card">
        <h3>🏆 Score Actuel</h3>
        <div class="stat-value" id="currentScore">0</div>
        <p>Record: <span id="bestScore">0</span></p>
    </div>
    <div class="stat-card">
        <h3>📊 Parties Jouées</h3>
        <div class="stat-value" id="gamesPlayed">0</div>
        <p>Victoires: <span id="wins">0</span> | Taux: <span id="winRate">0%</span></p>
    </div>
    <div class="stat-card">
        <h3>🧠 QI IA</h3>
        <div class="stat-value divine" id="aiIQ">1500</div>
        <p>Croissance: +<span id="iqGrowth">0</span></p>
    </div>
    <div class="stat-card">
        <h3>⚡ Performance</h3>
        <div class="stat-value legendary" id="performance">0%</div>
        <p>Temps moyen: <span id="avgTime">0s</span></p>
    </div>
    <div class="stat-card">
        <h3>🎯 Précision</h3>
        <div class="stat-value" id="accuracy">0%</div>
        <p>Tirs: <span id="totalShots">0</span> | Touchés: <span id="hits">0</span></p>
    </div>
    <div class="stat-card">
        <h3>🏃 Évasion</h3>
        <div class="stat-value transcendent" id="evasionRate">0%</div>
        <p>Esquivées: <span id="dodged">0</span>/<span id="totalBullets">0</span></p>
    </div>
</div>

<div class="leaderboard">
    <h3>🏅 Tableau des Records</h3>
    <div id="leaderboardEntries">
        <div class="score-entry">
            <span>Aucun record encore...</span>
            <span>-</span>
        </div>
    </div>
</div>

<div style="text-align: center; margin: 30px;">
    <button id="playBtn" onclick="startRealGame()" class="play-btn">🎮 COMMENCER JEU IA</button>
    <button id="simulateBtn" onclick="startTraining()">⚡ ENTRAÎNER IA (1000x)</button>
    <button onclick="resetGame()">🔄 Réinitialiser</button>
    <button onclick="toggleAutoMode()">🤖 Mode Auto: <span id="autoModeStatus">OFF</span></button>
</div>

<div class="controls-hint">
    <strong>🎮 Contrôles :</strong> L'IA joue automatiquement, mais vous pouvez observer ses stratégies et ajuster la difficulté.
    Mode Auto disponible pour l'entraînement continu.
</div>

<script>
    // Configuration du jeu améliorée
    const gameConfig = {
        difficulties: {
            easy: {
                enemySpawnRate: 0.02,
                enemySpeed: 2,
                bulletSpeed: 6,
                maxEnemies: 3,
                aiBonus: 1.2
            },
            medium: {
                enemySpawnRate: 0.035,
                enemySpeed: 3.5,
                bulletSpeed: 8,
                maxEnemies: 5,
                aiBonus: 1.0
            },
            hard: {
                enemySpawnRate: 0.05,
                enemySpeed: 5,
                bulletSpeed: 12,
                maxEnemies: 7,
                aiBonus: 0.8
            },
            nightmare: {
                enemySpawnRate: 0.08,
                enemySpeed: 7,
                bulletSpeed: 16,
                maxEnemies: 10,
                aiBonus: 0.6
            }
        },
        currentDifficulty: 'easy',
        autoMode: false,
        trainingTarget: 1000
    };

    // Système de particules amélioré
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }

        addParticle(x, y, color, type = 'spark', count = 1) {
            for (let i = 0; i < count; i++) {
                this.particles.push(new Particle(x, y, color, type));
            }
        }

        update() {
            this.particles = this.particles.filter(p => p.update());
        }

        draw(ctx) {
            this.particles.forEach(p => p.draw(ctx));
        }

        clear() {
            this.particles = [];
        }
    }

    class Particle {
        constructor(x, y, color, type = 'spark') {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = (Math.random() - 0.5) * 12;
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.01;
            this.color = color;
            this.size = Math.random() * 6 + 2;
            this.type = type;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.2;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.15; // Gravité
            this.life -= this.decay;
            this.vx *= 0.98;
            this.size *= 0.995;
            this.rotation += this.rotationSpeed;
            return this.life > 0;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            if (this.type === 'spark') {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.type === 'star') {
                ctx.fillStyle = this.color;
                this.drawStar(ctx, 0, 0, 5, this.size, this.size * 0.5);
            } else if (this.type === 'trail') {
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size, -this.size/4, this.size * 2, this.size/2);
            }
            ctx.restore();
        }

        drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Mario IA Ultra-Avancée avec Deep Learning et Q-Learning
    const mario = {
        x: 120, y: 350, width: 35, height: 45,
        dx: 0, dy: 0, lives: 5, level: 1,
        onGround: true, jumping: false,
        shootCooldown: 0, invulnerable: 0,
        score: 0, startTime: 0,

        // Réseau de neurones simplifié
        neuralNetwork: {
            weights: {
                input_hidden: Array(64).fill().map(() => Array(16).fill().map(() => Math.random() * 2 - 1)),
                hidden_output: Array(16).fill().map(() => Array(8).fill().map(() => Math.random() * 2 - 1))
            },
            biases: {
                hidden: Array(16).fill().map(() => Math.random() * 2 - 1),
                output: Array(8).fill().map(() => Math.random() * 2 - 1)
            },
            learning_rate: 0.001
        },

        // Q-Learning pour apprentissage par renforcement
        qLearning: {
            qTable: new Map(),
            epsilon: 0.1, // Exploration vs exploitation
            alpha: 0.1,   // Taux d'apprentissage
            gamma: 0.95,  // Facteur de discount
            lastState: null,
            lastAction: null,
            actions: ['idle', 'left', 'right', 'jump', 'shoot', 'dodge_left', 'dodge_right', 'retreat']
        },

        // Compétences IA évolutives avec spécialisations
        skills: {
            // Compétences de base
            evasion: 0.3,
            precision: 0.25,
            prediction: 0.2,
            reaction: 0.35,
            positioning: 0.3,
            risk_assessment: 0.4,

            // Compétences avancées
            pattern_recognition: 0.1,
            tactical_planning: 0.15,
            multi_threat_handling: 0.2,
            adaptive_learning: 0.1,
            situational_awareness: 0.25,
            combat_efficiency: 0.2,
            survival_instinct: 0.3,

            // Meta-compétences
            learning_acceleration: 0.05,
            experience_retention: 0.1,
            strategy_optimization: 0.05,

            learning_rate: 0.015
        },

        // Mémoire sophistiquée avec analyse de patterns
        memory: {
            successful_actions: [],
            failed_actions: [],
            enemy_patterns: new Map(),
            optimal_positions: [],
            threat_sequences: [],
            reward_history: [],
            state_action_values: new Map(),

            // Mémoire à court terme (pour prédictions immédiates)
            short_term: {
                recent_threats: [],
                recent_actions: [],
                recent_outcomes: [],
                pattern_buffer: []
            },

            // Mémoire à long terme (pour stratégies globales)
            long_term: {
                successful_strategies: new Map(),
                enemy_behavior_models: new Map(),
                optimal_positioning_data: [],
                performance_metrics: []
            }
        },

        // Système de prédiction avancé
        predictor: {
            enemy_trajectories: new Map(),
            bullet_paths: [],
            collision_predictions: [],
            threat_timeline: [],
            safe_zones_forecast: [],
            action_consequences: new Map()
        },

        // Analyse comportementale des ennemis
        enemyAnalyzer: {
            behavior_profiles: new Map(),
            spawn_patterns: [],
            movement_predictions: new Map(),
            threat_classifications: new Map()
        },

        // Système d'états pour machine à états finis
        stateMachine: {
            current_state: 'exploring',
            states: {
                exploring: { priority: 1, duration: 0 },
                engaging: { priority: 3, duration: 0 },
                evading: { priority: 5, duration: 0 },
                retreating: { priority: 4, duration: 0 },
                collecting: { priority: 2, duration: 0 },
                tactical_waiting: { priority: 1, duration: 0 }
            },
            transition_history: []
        },

        // Intelligence émotionnelle simulée
        emotions: {
            confidence: 0.5,
            aggression: 0.3,
            caution: 0.7,
            curiosity: 0.4,
            frustration: 0.0,
            satisfaction: 0.5
        },

        // Adaptation multi-niveaux
        adapt(situation, success, reward = 0) {
            this.updateQTable(situation, success, reward);
            this.updateNeuralNetwork(situation, success);
            this.adaptSkills(situation, success, reward);
            this.updateEmotions(success, reward);
            this.updateMemory(situation, success, reward);
        },

        // Mise à jour de la Q-Table
        updateQTable(situation, success, reward) {
            if (this.qLearning.lastState && this.qLearning.lastAction) {
                const stateKey = this.encodeState(this.qLearning.lastState);
                const actionIndex = this.qLearning.actions.indexOf(this.qLearning.lastAction);

                if (!this.qLearning.qTable.has(stateKey)) {
                    this.qLearning.qTable.set(stateKey, Array(this.qLearning.actions.length).fill(0));
                }

                const qValues = this.qLearning.qTable.get(stateKey);
                const currentQ = qValues[actionIndex];

                // Calcul de la récompense
                let totalReward = reward;
                if (success) totalReward += 10;
                else totalReward -= 5;

                // Q-Learning update
                const currentStateKey = this.encodeState(situation);
                let maxFutureQ = 0;
                if (this.qLearning.qTable.has(currentStateKey)) {
                    maxFutureQ = Math.max(...this.qLearning.qTable.get(currentStateKey));
                }

                const newQ = currentQ + this.qLearning.alpha *
                    (totalReward + this.qLearning.gamma * maxFutureQ - currentQ);
                qValues[actionIndex] = newQ;
            }
        },

        // Encodage d'état pour Q-Learning
        encodeState(situation) {
            const features = [
                Math.floor(this.x / 50),
                Math.floor(this.y / 50),
                Math.min(5, enemies.length),
                Math.min(10, enemyBullets.length),
                this.lives,
                bulletTimeActive ? 1 : 0,
                Math.floor((situation.overall_danger || 0) / 2)
            ];
            return features.join(',');
        },

        // Mise à jour du réseau de neurones
        updateNeuralNetwork(situation, success) {
            const input = this.createNeuralInput(situation);
            const target = success ? 1 : -1;

            // Forward pass
            const hidden = this.neuralForward(input, this.neuralNetwork.weights.input_hidden, this.neuralNetwork.biases.hidden);
            const output = this.neuralForward(hidden, this.neuralNetwork.weights.hidden_output, this.neuralNetwork.biases.output);

            // Backpropagation simplifiée
            const error = target - output[0];
            this.neuralBackpropagate(error, input, hidden, output);
        },

        // Création d'entrée pour réseau de neurones
        createNeuralInput(situation) {
            const input = Array(64).fill(0);
            let idx = 0;

            // Position de Mario
            input[idx++] = this.x / canvas.width;
            input[idx++] = this.y / canvas.height;
            input[idx++] = this.dx / 50;
            input[idx++] = this.dy / 50;
            input[idx++] = this.lives / 5;
            input[idx++] = this.onGround ? 1 : 0;
            input[idx++] = bulletTimeActive ? 1 : 0;
            input[idx++] = this.invulnerable > 0 ? 1 : 0;

            // Ennemis (top 8)
            const sortedEnemies = enemies.slice(0, 8);
            for (let i = 0; i < 8; i++) {
                if (i < sortedEnemies.length) {
                    const enemy = sortedEnemies[i];
                    input[idx++] = enemy.x / canvas.width;
                    input[idx++] = enemy.y / canvas.height;
                    input[idx++] = enemy.speed / 10;
                    input[idx++] = enemy.type === 'fast' ? 1 : enemy.type === 'shooter' ? 0.5 : 0;
                } else {
                    idx += 4;
                }
            }

            // Balles ennemies (top 6)
            const sortedBullets = enemyBullets.slice(0, 6);
            for (let i = 0; i < 6; i++) {
                if (i < sortedBullets.length) {
                    const bullet = sortedBullets[i];
                    input[idx++] = bullet.x / canvas.width;
                    input[idx++] = bullet.y / canvas.height;
                    input[idx++] = bullet.speed / 20;
                } else {
                    idx += 3;
                }
            }

            // État émotionnel
            input[idx++] = this.emotions.confidence;
            input[idx++] = this.emotions.aggression;
            input[idx++] = this.emotions.caution;

            return input;
        },

        // Forward pass réseau de neurones
        neuralForward(input, weights, biases) {
            const output = [];
            for (let i = 0; i < weights[0].length; i++) {
                let sum = biases[i];
                for (let j = 0; j < input.length; j++) {
                    sum += input[j] * weights[j][i];
                }
                output.push(Math.tanh(sum)); // Activation tanh
            }
            return output;
        },

        // Backpropagation simplifiée
        neuralBackpropagate(error, input, hidden, output) {
            const lr = this.neuralNetwork.learning_rate;

            // Mise à jour des poids de sortie
            for (let i = 0; i < this.neuralNetwork.weights.hidden_output.length; i++) {
                for (let j = 0; j < this.neuralNetwork.weights.hidden_output[i].length; j++) {
                    this.neuralNetwork.weights.hidden_output[i][j] += lr * error * hidden[i];
                }
            }

            // Mise à jour des biais de sortie
            for (let i = 0; i < this.neuralNetwork.biases.output.length; i++) {
                this.neuralNetwork.biases.output[i] += lr * error;
            }
        },

        // Adaptation sophistiquée des compétences
        adaptSkills(situation, success, reward) {
            const baseRate = this.skills.learning_rate;
            const acceleratedRate = baseRate * (1 + this.skills.learning_acceleration);
            const retentionFactor = 1 + this.skills.experience_retention;

            if (success) {
                // Renforcement positif avec spécialisation
                const contextualBonus = this.calculateContextualBonus(situation);

                Object.keys(this.skills).forEach(skill => {
                    if (skill !== 'learning_rate' && !skill.includes('_')) {
                        const relevance = this.getSkillRelevance(skill, situation);
                        const improvement = acceleratedRate * relevance * contextualBonus * retentionFactor;
                        this.skills[skill] = Math.min(0.999, this.skills[skill] + improvement);
                    }
                });

                // Bonus pour compétences avancées
                this.skills.adaptive_learning = Math.min(0.99, this.skills.adaptive_learning + acceleratedRate * 2);
                this.skills.strategy_optimization = Math.min(0.99, this.skills.strategy_optimization + acceleratedRate * 1.5);

            } else {
                // Adaptation négative avec analyse d'erreur
                const errorType = this.analyzeFailure(situation);
                this.applyErrorCorrection(errorType, baseRate);

                // Augmentation de la prudence
                this.skills.risk_assessment = Math.min(0.99, this.skills.risk_assessment + baseRate * 3);
                this.skills.survival_instinct = Math.min(0.99, this.skills.survival_instinct + baseRate * 2);
            }

            // Évolution des meta-compétences
            this.evolveMeta Competences(success, reward);
        },

        // Calcul du bonus contextuel
        calculateContextualBonus(situation) {
            let bonus = 1.0;

            if (situation.overall_danger > 8) bonus += 0.5; // Situations difficiles
            if (bulletTimeActive) bonus += 0.3; // Utilisation tactique
            if (this.emotions.confidence > 0.8) bonus += 0.2; // État mental positif

            return bonus;
        },

        // Pertinence d'une compétence pour une situation
        getSkillRelevance(skill, situation) {
            const relevanceMap = {
                'evasion': Math.min(1, (situation.immediate_count || 0) * 0.3),
                'precision': Math.min(1, enemies.length * 0.2),
                'prediction': Math.min(1, (situation.overall_danger || 0) * 0.1),
                'reaction': Math.min(1, enemyBullets.length * 0.15),
                'positioning': 0.8, // Toujours important
                'risk_assessment': Math.min(1, (situation.critical_count || 0) * 0.4),
                'pattern_recognition': Math.min(1, this.memory.short_term.recent_threats.length * 0.1),
                'tactical_planning': Math.min(1, (situation.overall_danger || 0) * 0.08),
                'multi_threat_handling': Math.min(1, (enemies.length + enemyBullets.length) * 0.1),
                'situational_awareness': 0.9, // Toujours critique
                'combat_efficiency': Math.min(1, enemies.length * 0.25),
                'survival_instinct': Math.min(1, (5 - this.lives) * 0.3)
            };

            return relevanceMap[skill] || 0.5;
        },

        // Analyse des échecs pour apprentissage ciblé
        analyzeFailure(situation) {
            if (enemyBullets.some(b => Math.abs(b.y - this.y) < 30)) {
                return 'bullet_dodge_failure';
            }
            if (enemies.some(e => Math.abs(e.x - this.x) < 50)) {
                return 'enemy_collision';
            }
            if (this.lives < 3 && !this.emotions.caution > 0.8) {
                return 'insufficient_caution';
            }
            return 'general_failure';
        },

        // Application de corrections d'erreur
        applyErrorCorrection(errorType, rate) {
            const corrections = {
                'bullet_dodge_failure': () => {
                    this.skills.evasion += rate * 4;
                    this.skills.reaction += rate * 3;
                    this.skills.prediction += rate * 2;
                },
                'enemy_collision': () => {
                    this.skills.positioning += rate * 3;
                    this.skills.situational_awareness += rate * 4;
                    this.skills.risk_assessment += rate * 2;
                },
                'insufficient_caution': () => {
                    this.skills.survival_instinct += rate * 5;
                    this.skills.risk_assessment += rate * 4;
                    this.emotions.caution = Math.min(1, this.emotions.caution + 0.1);
                },
                'general_failure': () => {
                    Object.keys(this.skills).forEach(skill => {
                        if (!skill.includes('_') && skill !== 'learning_rate') {
                            this.skills[skill] += rate * 0.5;
                        }
                    });
                }
            };

            if (corrections[errorType]) {
                corrections[errorType]();
            }
        },

        // Évolution des meta-compétences
        evolveMetaCompetences(success, reward) {
            if (success) {
                this.skills.learning_acceleration = Math.min(0.3, this.skills.learning_acceleration + 0.001);
                this.skills.experience_retention = Math.min(0.5, this.skills.experience_retention + 0.0005);
            }

            // Auto-optimisation basée sur les performances
            const recentPerformance = this.calculateRecentPerformance();
            if (recentPerformance > 0.8) {
                this.skills.strategy_optimization = Math.min(0.99, this.skills.strategy_optimization + 0.002);
            }
        },

        // Calcul de performance récente
        calculateRecentPerformance() {
            const recentOutcomes = this.memory.short_term.recent_outcomes.slice(-10);
            if (recentOutcomes.length === 0) return 0.5;

            const successCount = recentOutcomes.filter(outcome => outcome.success).length;
            return successCount / recentOutcomes.length;
        },

        // Mise à jour des émotions
        updateEmotions(success, reward) {
            const emotionRate = 0.05;

            if (success) {
                this.emotions.confidence = Math.min(1, this.emotions.confidence + emotionRate * 2);
                this.emotions.satisfaction = Math.min(1, this.emotions.satisfaction + emotionRate);
                this.emotions.frustration = Math.max(0, this.emotions.frustration - emotionRate * 1.5);

                if (reward > 5) {
                    this.emotions.aggression = Math.min(1, this.emotions.aggression + emotionRate);
                }
            } else {
                this.emotions.confidence = Math.max(0, this.emotions.confidence - emotionRate);
                this.emotions.caution = Math.min(1, this.emotions.caution + emotionRate * 1.5);
                this.emotions.frustration = Math.min(1, this.emotions.frustration + emotionRate);
            }

            // Équilibrage émotionnel
            if (this.emotions.confidence > 0.9) {
                this.emotions.caution = Math.max(0.3, this.emotions.caution);
            }
            if (this.emotions.frustration > 0.7) {
                this.emotions.aggression = Math.min(0.8, this.emotions.aggression + emotionRate);
            }
        },

        // Mise à jour sophistiquée de la mémoire
        updateMemory(situation, success, reward) {
            const timestamp = Date.now();

            // Mémoire à court terme
            this.memory.short_term.recent_threats.push({
                threats: [...enemies, ...enemyBullets].map(e => ({
                    x: e.x, y: e.y, type: e.type || 'bullet'
                })),
                timestamp
            });

            this.memory.short_term.recent_actions.push({
                action: this.qLearning.lastAction,
                position: {x: this.x, y: this.y},
                timestamp
            });

            this.memory.short_term.recent_outcomes.push({
                success, reward, timestamp
            });

            // Nettoyage mémoire court terme (garde 50 derniers)
            ['recent_threats', 'recent_actions', 'recent_outcomes'].forEach(key => {
                if (this.memory.short_term[key].length > 50) {
                    this.memory.short_term[key] = this.memory.short_term[key].slice(-50);
                }
            });

            // Mémoire à long terme pour stratégies réussies
            if (success && reward > 3) {
                const strategyKey = `${this.stateMachine.current_state}_${Math.floor(situation.overall_danger || 0)}`;
                if (!this.memory.long_term.successful_strategies.has(strategyKey)) {
                    this.memory.long_term.successful_strategies.set(strategyKey, []);
                }

                this.memory.long_term.successful_strategies.get(strategyKey).push({
                    skills_snapshot: {...this.skills},
                    emotional_state: {...this.emotions},
                    position: {x: this.x, y: this.y},
                    reward,
                    timestamp
                });
            }

            // Analyse de patterns d'ennemis
            this.updateEnemyBehaviorAnalysis();
        },

        // Analyse comportementale des ennemis
        updateEnemyBehaviorAnalysis() {
            enemies.forEach(enemy => {
                const enemyId = `${enemy.type}_${Math.floor(enemy.x/100)}_${Math.floor(enemy.y/100)}`;

                if (!this.enemyAnalyzer.behavior_profiles.has(enemyId)) {
                    this.enemyAnalyzer.behavior_profiles.set(enemyId, {
                        type: enemy.type,
                        positions: [],
                        actions: [],
                        threat_level: 0,
                        predictability: 0
                    });
                }

                const profile = this.enemyAnalyzer.behavior_profiles.get(enemyId);
                profile.positions.push({x: enemy.x, y: enemy.y, time: Date.now()});

                // Calcul de prédictibilité
                if (profile.positions.length > 5) {
                    profile.predictability = this.calculatePredictability(profile.positions);
                    profile.positions = profile.positions.slice(-20); // Garde 20 dernières positions
                }
            });
        },

        // Calcul de prédictibilité basé sur les mouvements
        calculatePredictability(positions) {
            if (positions.length < 3) return 0;

            let consistency = 0;
            for (let i = 2; i < positions.length; i++) {
                const dx1 = positions[i-1].x - positions[i-2].x;
                const dx2 = positions[i].x - positions[i-1].x;
                const dy1 = positions[i-1].y - positions[i-2].y;
                const dy2 = positions[i].y - positions[i-1].y;

                const similarity = 1 - (Math.abs(dx2 - dx1) + Math.abs(dy2 - dy1)) / 100;
                consistency += Math.max(0, similarity);
            }

            return consistency / (positions.length - 2);
        }
    };

    // Statistiques avancées
    const stats = {
        gamesPlayed: 0,
        wins: 0,
        totalScore: 0,
        bestScore: 0,
        totalShots: 0,
        hits: 0,
        bulletsDodged: 0,
        totalBullets: 0,
        totalTime: 0,
        longestSurvival: 0,
        perfectRuns: 0,
        aiIQ: 1500,
        iqGrowth: 0,
        leaderboard: []
    };

    // Variables de jeu
    let gameRunning = false;
    let realGameMode = false;
    let gameStartTime = 0;
    let enemies = [];
    let bullets = [];
    let enemyBullets = [];
    let powerUps = [];
    let particleSystem = new ParticleSystem();
    let screenShake = 0;
    let timeScale = 1.0;
    let bulletTimeActive = false;
    let bulletTimeCooldown = 0;

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Classes d'entités améliorées
    class Enemy {
        constructor(difficulty) {
            const config = gameConfig.difficulties[difficulty];
            this.x = canvas.width + 30;
            this.y = Math.random() * (canvas.height - 200) + 50;
            this.width = 30;
            this.height = 30;
            this.speed = config.enemySpeed + Math.random() * 2;
            this.health = 1;
            this.trail = [];
            this.shootCooldown = 0;

            // Types d'ennemis variés
            const rand = Math.random();
            if (rand < 0.3) {
                this.type = 'normal';
                this.color = '#ff6b6b';
            } else if (rand < 0.6) {
                this.type = 'fast';
                this.speed *= 1.5;
                this.width = 25;
                this.height = 25;
                this.color = '#ff4444';
            } else if (rand < 0.85) {
                this.type = 'shooter';
                this.color = '#ff8800';
                this.shootCooldown = Math.random() * 60;
            } else {
                this.type = 'heavy';
                this.speed *= 0.7;
                this.width = 40;
                this.height = 40;
                this.health = 2;
                this.color = '#ff0066';
            }

            this.originalY = this.y;
            this.waveOffset = Math.random() * Math.PI * 2;
        }

        update() {
            this.x -= this.speed * timeScale;

            // Mouvement en vague pour certains ennemis
            if (this.type === 'fast') {
                this.y = this.originalY + Math.sin(Date.now() * 0.01 + this.waveOffset) * 30;
            }

            // Trail effect
            this.trail.push({
                x: this.x + this.width/2,
                y: this.y + this.height/2,
                life: 25
            });
            this.trail = this.trail.filter(t => t.life-- > 0);

            // Tir pour les shooters avec son
            if (this.type === 'shooter' && this.shootCooldown <= 0) {
                const distance = Math.abs(this.x - mario.x);
                if (distance < 400 && Math.random() < 0.04) {
                    enemyBullets.push(new EnemyBullet(this.x, this.y + this.height/2, gameConfig.currentDifficulty));
                    this.shootCooldown = 60 + Math.random() * 90;

                    // Son de tir ennemi
                    if (audioSystem) {
                        audioSystem.playSound('enemy_shoot');
                    }

                    particleSystem.addParticle(this.x, this.y + this.height/2, '#ff8800', 'spark', 5);
                }
            }
            if (this.shootCooldown > 0) this.shootCooldown--;
        }

        draw(ctx) {
            // Trail
            if (this.trail.length > 1) {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                this.trail.forEach((point, i) => {
                    ctx.globalAlpha = point.life / 25;
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Ennemi avec effet glow
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;

            if (this.type === 'heavy') {
                ctx.fillRect(this.x, this.y, this.width, this.height);
                // Barre de vie
                if (this.health > 1) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(this.x, this.y - 10, this.width * (this.health/2), 6);
                }
            } else {
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Indicateur de type
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            const icon = this.type === 'fast' ? '⚡' :
                this.type === 'shooter' ? '🔫' :
                    this.type === 'heavy' ? '🛡️' : '👾';
            ctx.fillText(icon, this.x + this.width/2, this.y + this.height/2 + 6);

            ctx.restore();
        }

        takeDamage() {
            this.health--;
            if (this.health <= 0) {
                // Explosion spectaculaire
                const particleCount = this.type === 'heavy' ? 20 : 15;
                particleSystem.addParticle(
                    this.x + this.width/2,
                    this.y + this.height/2,
                    this.color,
                    'star',
                    particleCount
                );
                screenShake = Math.max(screenShake, this.type === 'heavy' ? 15 : 10);
                return true;
            }
            // Particules de dégât
            particleSystem.addParticle(this.x + this.width/2, this.y + this.height/2, '#ffff00', 'spark', 8);
            return false;
        }
    }

    class EnemyBullet {
        constructor(x, y, difficulty) {
            const config = gameConfig.difficulties[difficulty];
            this.x = x;
            this.y = y;
            this.speed = -config.bulletSpeed - Math.random() * 3;
            this.width = 10;
            this.height = 6;
            this.trail = [];
            this.rotation = 0;
        }

        update() {
            this.x += this.speed * timeScale;
            this.rotation += 0.2;

            this.trail.push({
                x: this.x + this.width/2,
                y: this.y + this.height/2,
                life: 20
            });
            this.trail = this.trail.filter(t => t.life-- > 0);
        }

        draw(ctx) {
            // Trail énergétique
            if (this.trail.length > 1) {
                const gradient = ctx.createLinearGradient(
                    this.trail[0].x, this.trail[0].y,
                    this.trail[this.trail.length-1].x, this.trail[this.trail.length-1].y
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 100, 0, 0.2)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 6;
                ctx.beginPath();
                this.trail.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
            }

            // Balle avec rotation
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(this.rotation);
            ctx.shadowBlur = 12;
            ctx.shadowColor = '#ff0000';
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);

            // Effet d'énergie
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(-this.width/4, -this.height/4, this.width/2, this.height/2);
            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.speed = 20;
            this.width = 8;
            this.height = 5;
            this.trail = [];
            this.energy = 1.0;
        }

        update() {
            this.x += this.speed;
            this.energy -= 0.005;

            this.trail.push({
                x: this.x,
                y: this.y + this.height/2,
                life: 15
            });
            this.trail = this.trail.filter(t => t.life-- > 0);
        }

        draw(ctx) {
            // Trail énergétique
            if (this.trail.length > 1) {
                const gradient = ctx.createLinearGradient(
                    this.trail[0].x, this.trail[0].y,
                    this.trail[this.trail.length-1].x, this.trail[this.trail.length-1].y
                );
                gradient.addColorStop(0, `rgba(255, 255, 0, ${this.energy})`);
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.2)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 4;
                ctx.beginPath();
                this.trail.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
            }

            // Balle
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = `rgba(255, 255, 0, ${this.energy})`;
            ctx.fillRect(this.x, this.y, this.width, this.height);

            // Core brillant
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(this.x + 2, this.y + 1, this.width - 4, this.height - 2);
            ctx.restore();
        }
    }

    class PowerUp {
        constructor() {
            this.x = canvas.width + 20;
            this.y = Math.random() * (canvas.height - 200) + 50;
            this.width = 25;
            this.height = 25;
            this.speed = 3;
            this.bob = 0;
            this.rotation = 0;

            const rand = Math.random();
            if (rand < 0.4) {
                this.type = 'score';
                this.color = '#ffd700';
                this.value = 500;
            } else if (rand < 0.7) {
                this.type = 'bulletTime';
                this.color = '#9d4edd';
                this.value = 300;
            } else if (rand < 0.9) {
                this.type = 'rapidFire';
                this.color = '#ff6b6b';
                this.value = 400;
            } else {
                this.type = 'shield';
                this.color = '#4ecdc4';
                this.value = 600;
            }
        }

        update() {
            this.x -= this.speed;
            this.bob += 0.15;
            this.rotation += 0.1;

            // Particules autour du power-up
            if (Math.random() < 0.3) {
                particleSystem.addParticle(
                    this.x + this.width/2 + (Math.random() - 0.5) * 30,
                    this.y + this.height/2 + (Math.random() - 0.5) * 30,
                    this.color,
                    'spark',
                    1
                );
            }
        }

        draw(ctx) {
            const bobY = this.y + Math.sin(this.bob) * 8;

            ctx.save();
            ctx.translate(this.x + this.width/2, bobY + this.height/2);
            ctx.rotate(this.rotation);

            // Aura
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.color;

            // Corps du power-up
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);

            // Icône
            ctx.fillStyle = '#000000';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            const icon = this.type === 'score' ? '⭐' :
                this.type === 'bulletTime' ? '⏰' :
                    this.type === 'rapidFire' ? '🔥' : '🛡️';
            ctx.fillText(icon, 0, 6);

            ctx.restore();
        }
    }

    // IA avancée avec apprentissage adaptatif
    class EnhancedAI {
        static makeDecision() {
            if (!gameRunning || !realGameMode) return;

            const threats = this.analyzeThreats();
            const situation = this.assessSituation(threats);

            // Prise de décision basée sur l'évaluation
            this.executeStrategy(situation);

            // Mise à jour de la mémoire
            this.updateMemory(situation);
        }

        static analyzeThreats() {
            const threats = [];
            const difficulty = gameConfig.difficulties[gameConfig.currentDifficulty];

            // Analyse des ennemis
            enemies.forEach(enemy => {
                const distance = Math.sqrt((enemy.x - mario.x)**2 + (enemy.y - mario.y)**2);
                const futureX = enemy.x - enemy.speed * 30;
                const dangerLevel = this.calculateEnemyDanger(enemy, distance);

                threats.push({
                    type: 'enemy',
                    entity: enemy,
                    distance,
                    futurePosition: {x: futureX, y: enemy.y},
                    danger: dangerLevel,
                    priority: dangerLevel * (1 / Math.max(distance, 1))
                });
            });

            // Analyse des balles ennemies
            enemyBullets.forEach(bullet => {
                const distance = Math.sqrt((bullet.x - mario.x)**2 + (bullet.y - mario.y)**2);
                const timeToImpact = Math.abs(bullet.x - mario.x) / Math.abs(bullet.speed);
                const willHit = Math.abs(bullet.y - mario.y) < 60;

                threats.push({
                    type: 'bullet',
                    entity: bullet,
                    distance,
                    timeToImpact,
                    willHit,
                    danger: willHit ? (distance < 100 ? 10 : 7) : 3,
                    priority: willHit ? (10 / Math.max(timeToImpact, 0.1)) : 1
                });
            });

            return threats.sort((a, b) => b.priority - a.priority);
        }

        static calculateEnemyDanger(enemy, distance) {
            let danger = 3;

            switch(enemy.type) {
                case 'fast': danger = 5; break;
                case 'shooter': danger = enemy.shootCooldown < 20 ? 8 : 4; break;
                case 'heavy': danger = 6; break;
            }

            // Distance factor
            danger *= Math.max(0.2, 1 - distance / 300);

            return danger;
        }

        static assessSituation(threats) {
            const criticalThreats = threats.filter(t => t.danger > 6);
            const immediateThreats = threats.filter(t => t.distance < 150);

            return {
                overall_danger: threats.reduce((sum, t) => sum + t.danger, 0),
                critical_count: criticalThreats.length,
                immediate_count: immediateThreats.length,
                primary_threat: threats[0] || null,
                safe_zones: this.calculateSafeZones(threats),
                optimal_position: this.findOptimalPosition(threats)
            };
        }

        static calculateSafeZones(threats) {
            const zones = [];
            const zoneWidth = canvas.width / 5;

            for (let i = 0; i < 5; i++) {
                const zoneX = i * zoneWidth;
                const zoneDanger = threats.reduce((danger, threat) => {
                    const distToZone = Math.abs(threat.entity.x - (zoneX + zoneWidth/2));
                    return danger + (threat.danger / Math.max(distToZone, 50));
                }, 0);

                zones.push({
                    x: zoneX,
                    width: zoneWidth,
                    danger: zoneDanger,
                    safety: Math.max(0, 10 - zoneDanger)
                });
            }

            return zones.sort((a, b) => b.safety - a.safety);
        }

        static findOptimalPosition(threats) {
            const safeZones = this.calculateSafeZones(threats);
            const bestZone = safeZones[0];

            return {
                x: bestZone.x + bestZone.width/2,
                y: canvas.height - 150, // Position de base
                confidence: Math.min(1, bestZone.safety / 5)
            };
        }

        static executeStrategy(situation) {
            // Gestion des menaces critiques
            if (situation.critical_count > 0 && bulletTimeCooldown <= 0) {
                this.activateBulletTime();
            }

            // Mouvement intelligent
            this.intelligentMovement(situation);

            // Combat précis
            this.precisionShooting();

            // Collecte de power-ups
            this.smartCollection();
        }

        static intelligentMovement(situation) {
            const adaptedSkill = mario.skills.evasion * gameConfig.difficulties[gameConfig.currentDifficulty].aiBonus;

            if (situation.primary_threat) {
                const threat = situation.primary_threat;

                if (threat.type === 'bullet' && threat.willHit && threat.timeToImpact < 50) {
                    // Esquive d'urgence
                    const dodgeDirection = this.calculateDodgeDirection(threat.entity);
                    const dodgeSpeed = 40 * adaptedSkill;
                    mario.dx = dodgeDirection * dodgeSpeed;

                    // Saut si nécessaire avec son
                    if (threat.entity.y > mario.y - 50 && mario.onGround && Math.random() < adaptedSkill) {
                        mario.dy = -25;
                        mario.jumping = true;
                        mario.onGround = false;

                        // Son de saut
                        if (audioSystem) {
                            audioSystem.playSound('jump');
                        }
                    }

                    stats.bulletsDodged++;
                    mario.adapt(situation, true);

                } else if (threat.type === 'enemy' && threat.distance < 200) {
                    // Évitement d'ennemi
                    const optimalPos = situation.optimal_position;
                    const direction = mario.x < optimalPos.x ? 1 : -1;
                    const moveSpeed = 30 * mario.skills.positioning;
                    mario.dx += direction * moveSpeed;
                }
            }

            // Positionnement optimal continu
            const optimalX = canvas.width * 0.25;
            const positionError = Math.abs(mario.x - optimalX);
            if (positionError > 100) {
                const correctionSpeed = 15 * mario.skills.positioning;
                const direction = mario.x < optimalX ? 1 : -1;
                mario.dx += direction * correctionSpeed;
            }
        }

        static calculateDodgeDirection(bullet) {
            const centerX = canvas.width * 0.25;
            const leftSafe = mario.x > 80;
            const rightSafe = mario.x < canvas.width - 120;

            if (leftSafe && rightSafe) {
                return mario.x > centerX ? -1 : 1;
            }
            return leftSafe ? -1 : (rightSafe ? 1 : 0);
        }

        static precisionShooting() {
            if (mario.shootCooldown > 0) return;

            const targets = enemies.filter(enemy => {
                const distance = Math.abs(enemy.x - mario.x);
                const verticalAlign = Math.abs(enemy.y - mario.y);
                return distance < 400 && verticalAlign < 80;
            });

            if (targets.length > 0) {
                // Sélection de la meilleure cible
                const bestTarget = targets.reduce((best, current) => {
                    const currentScore = this.calculateTargetScore(current);
                    const bestScore = this.calculateTargetScore(best);
                    return currentScore > bestScore ? current : best;
                });

                const accuracy = mario.skills.precision * gameConfig.difficulties[gameConfig.currentDifficulty].aiBonus;
                if (Math.random() < accuracy) {
                    bullets.push(new Bullet(mario.x + mario.width, mario.y + mario.height/2));
                    mario.shootCooldown = bulletTimeActive ? 8 : 15;
                    stats.totalShots++;

                    particleSystem.addParticle(mario.x + mario.width, mario.y + mario.height/2, '#ffff00', 'star', 8);
                }
            }
        }

        static calculateTargetScore(enemy) {
            const distance = Math.abs(enemy.x - mario.x);
            const verticalAlign = Math.abs(enemy.y - mario.y);
            const healthFactor = enemy.health;
            const typeFactor = enemy.type === 'shooter' ? 2 : enemy.type === 'heavy' ? 1.5 : 1;

            return (typeFactor * healthFactor) / Math.max(distance + verticalAlign, 1);
        }

        static smartCollection() {
            powerUps.forEach(powerUp => {
                const distance = Math.abs(powerUp.x - mario.x);
                const verticalDistance = Math.abs(powerUp.y - mario.y);
                const totalDistance = Math.sqrt(distance*distance + verticalDistance*verticalDistance);

                if (totalDistance < 120 && this.isSafeToCollect(powerUp)) {
                    const collectSpeed = 25 * mario.skills.positioning;
                    const direction = powerUp.x > mario.x ? 1 : -1;
                    mario.dx += direction * collectSpeed * 0.5;

                    // Saut pour atteindre le power-up
                    if (powerUp.y < mario.y - 30 && mario.onGround && distance < 80) {
                        mario.dy = -20;
                        mario.jumping = true;
                        mario.onGround = false;
                    }
                }
            });
        }

        static isSafeToCollect(powerUp) {
            const nearbyThreats = [...enemies, ...enemyBullets].filter(entity => {
                const distance = Math.sqrt((entity.x - powerUp.x)**2 + (entity.y - powerUp.y)**2);
                return distance < 100;
            });
            return nearbyThreats.length === 0 || mario.skills.risk_assessment < 0.3;
        }

        static activateBulletTime() {
            if (Math.random() < mario.skills.reaction) {
                bulletTimeActive = true;
                bulletTimeCooldown = 300;
                timeScale = 0.4;

                const flash = document.getElementById('screenFlash');
                flash.style.animation = 'flash 0.5s ease-out';
                flash.style.background = 'rgba(157, 78, 221, 0.3)';

                setTimeout(() => {
                    bulletTimeActive = false;
                    timeScale = 1.0;
                    flash.style.animation = '';
                }, 2000);

                mario.adapt({type: 'bulletTime'}, true);
            }
        }

        static updateMemory(situation) {
            // Sauvegarde des patterns réussis
            if (situation.overall_danger > 5 && mario.lives > 0) {
                mario.memory.successful_actions.push({
                    situation: situation.overall_danger,
                    position: {x: mario.x, y: mario.y},
                    skills: {...mario.skills},
                    timestamp: Date.now()
                });
            }

            // Nettoyage de la mémoire (garde seulement les 50 dernières)
            if (mario.memory.successful_actions.length > 50) {
                mario.memory.successful_actions = mario.memory.successful_actions.slice(-50);
            }
        }
    }

    // Système d'entraînement amélioré
    class TrainingSystem {
        static async startTraining() {
            const totalGames = gameConfig.trainingTarget;
            const batchSize = 50;
            const batches = Math.ceil(totalGames / batchSize);

            document.getElementById("simulateBtn").textContent = "🔄 ENTRAÎNEMENT...";
            document.getElementById("simulateBtn").disabled = true;
            updateAIStatus("training", "Entraînement en cours");

            for (let batch = 0; batch < batches; batch++) {
                const currentBatch = Math.min(batchSize, totalGames - (batch * batchSize));
                await this.processBatch(currentBatch);

                const progress = ((batch + 1) / batches) * 100;
                document.getElementById("progressBar").style.width = `${progress}%`;

                await new Promise(resolve => setTimeout(resolve, 100));
            }

            document.getElementById("simulateBtn").textContent = "✅ ENTRAÎNEMENT TERMINÉ";
            updateAIStatus("active", "IA Entraînée - Prête au combat");
        }

        static async processBatch(batchSize) {
            for (let i = 0; i < batchSize; i++) {
                const result = this.simulateGame();
                this.updateStats(result);
                this.evolveMario(result);
            }
        }

        static simulateGame() {
            const difficulty = gameConfig.difficulties[gameConfig.currentDifficulty];
            const duration = Math.random() * 8000 + 2000;
            const enemiesEncountered = Math.floor(Math.random() * difficulty.maxEnemies * 3 + 5);
            const bulletsEncountered = Math.floor(Math.random() * enemiesEncountered * 0.8);

            // Calcul de la probabilité de survie basée sur les compétences
            const survivalChance = this.calculateSurvivalProbability(duration, enemiesEncountered, bulletsEncountered);
            const won = Math.random() < survivalChance;

            const score = this.calculateScore(won, duration, enemiesEncountered);
            const accuracy = Math.min(0.95, mario.skills.precision + Math.random() * 0.2);
            const shotsNeeded = Math.floor(enemiesEncountered * (1 / accuracy));

            return {
                won,
                score,
                duration,
                enemiesDefeated: won ? enemiesEncountered : Math.floor(enemiesEncountered * 0.6),
                shotsFired: shotsNeeded,
                bulletsEncountered,
                bulletsDodged: Math.floor(bulletsEncountered * mario.skills.evasion)
            };
        }

        static calculateSurvivalProbability(duration, enemies, bullets) {
            const baseChance = 0.1;
            const skillBonus = (mario.skills.evasion + mario.skills.reaction + mario.skills.positioning) / 3;
            const difficultyPenalty = 1 - (gameConfig.difficulties[gameConfig.currentDifficulty].enemySpeed / 10);
            const adaptationBonus = Math.min(0.3, stats.gamesPlayed * 0.0001);

            let chance = baseChance + skillBonus * 0.8 + difficultyPenalty * 0.3 + adaptationBonus;
            chance -= (enemies * 0.02 + bullets * 0.015);

            return Math.max(0.05, Math.min(0.95, chance));
        }

        static calculateScore(won, duration, enemies) {
            let score = won ? 1000 + (duration / 100) : 0;
            score += enemies * 150;

            if (won) {
                score *= (1 + mario.skills.precision);
                if (duration > 6000) score *= 1.5; // Bonus survie longue
            }

            return Math.floor(score);
        }

        static updateStats(result) {
            stats.gamesPlayed++;
            if (result.won) stats.wins++;

            stats.totalScore += result.score;
            if (result.score > stats.bestScore) {
                stats.bestScore = result.score;
                this.updateLeaderboard(result.score, result.duration);
            }

            stats.totalShots += result.shotsFired;
            stats.hits += result.enemiesDefeated;
            stats.totalBullets += result.bulletsEncountered;
            stats.bulletsDodged += result.bulletsDodged;
            stats.totalTime += result.duration;

            if (result.duration > stats.longestSurvival) {
                stats.longestSurvival = result.duration;
            }
        }

        static evolveMario(result) {
            const evolutionRate = 0.001;
            const successBonus = result.won ? 0.002 : -0.001;

            // Évolution adaptive des compétences
            mario.skills.evasion = Math.min(0.99, mario.skills.evasion + evolutionRate + successBonus);
            mario.skills.precision = Math.min(0.99, mario.skills.precision + evolutionRate * 0.8 + successBonus);
            mario.skills.reaction = Math.min(0.99, mario.skills.reaction + evolutionRate * 1.2 + successBonus);
            mario.skills.positioning = Math.min(0.99, mario.skills.positioning + evolutionRate + successBonus);
            mario.skills.prediction = Math.min(0.99, mario.skills.prediction + evolutionRate * 0.9 + successBonus);
            mario.skills.risk_assessment = Math.min(0.99, mario.skills.risk_assessment + evolutionRate * 0.7);

            // Calcul du QI basé sur les compétences
            const avgSkill = Object.values(mario.skills).reduce((sum, skill, i, arr) => {
                if (typeof skill === 'number' && i < arr.length - 1) { // Exclut learning_rate
                    return sum + skill;
                }
                return sum;
            }, 0) / 6; // 6 compétences principales

            const newIQ = 1500 + (avgSkill * 8000) + (stats.gamesPlayed * 0.5);
            stats.iqGrowth = newIQ - stats.aiIQ;
            stats.aiIQ = Math.min(15000, newIQ);
        }

        static updateLeaderboard(score, duration) {
            stats.leaderboard.push({
                score: score,
                time: duration,
                date: new Date().toLocaleDateString(),
                difficulty: gameConfig.currentDifficulty
            });

            stats.leaderboard.sort((a, b) => b.score - a.score);
            stats.leaderboard = stats.leaderboard.slice(0, 10); // Garde top 10

            this.displayLeaderboard();
        }

        static displayLeaderboard() {
            const container = document.getElementById("leaderboardEntries");
            container.innerHTML = "";

            if (stats.leaderboard.length === 0) {
                container.innerHTML = '<div class="score-entry"><span>Aucun record encore...</span><span>-</span></div>';
                return;
            }

            stats.leaderboard.forEach((entry, index) => {
                const entryDiv = document.createElement("div");
                entryDiv.className = "score-entry";
                entryDiv.innerHTML = `
                        <span>${index + 1}. ${entry.score.toLocaleString()} pts (${entry.difficulty})</span>
                        <span>${(entry.time/1000).toFixed(1)}s - ${entry.date}</span>
                    `;
                container.appendChild(entryDiv);
            });
        }
    }

    // Fonctions de gestion du jeu avec audio
    function setDifficulty(difficulty) {
        initAudio(); // Initialiser l'audio si pas encore fait

        gameConfig.currentDifficulty = difficulty;

        // Mise à jour visuelle des boutons
        document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelector(`.diff-btn.${difficulty}`).classList.add('active');
        document.getElementById('currentDifficulty').textContent =
            difficulty.charAt(0).toUpperCase() + difficulty.slice(1);

        // Ajustement des compétences de l'IA selon la difficulté
        const difficultySettings = gameConfig.difficulties[difficulty];
        mario.skills.learning_rate = 0.02 * difficultySettings.aiBonus;

        updateAIStatus("idle", `Difficulté ${difficulty} sélectionnée`);

        // Son de changement de difficulté
        if (audioSystem) {
            audioSystem.playSound('powerup');
        }
    }

    function updateAIStatus(status, text) {
        const indicator = document.getElementById('aiStatusIndicator');
        const statusText = document.getElementById('aiStatusText');
        const adaptationLevel = document.getElementById('adaptationLevel');

        indicator.className = `status-indicator ${status}`;
        statusText.textContent = text;

        // Calcul du niveau d'adaptation
        const avgSkill = Object.values(mario.skills).reduce((sum, skill, i, arr) => {
            if (typeof skill === 'number' && i < arr.length - 1) {
                return sum + skill;
            }
            return sum;
        }, 0) / 6;

        let level = "Débutant";
        if (avgSkill > 0.8) level = "Maître";
        else if (avgSkill > 0.6) level = "Expert";
        else if (avgSkill > 0.4) level = "Avancé";
        else if (avgSkill > 0.2) level = "Intermédiaire";

        adaptationLevel.textContent = level;
    }

    function startRealGame() {
        initAudio(); // Initialiser l'audio si pas encore fait

        realGameMode = true;
        gameRunning = true;
        gameStartTime = Date.now();

        // Réinitialisation de Mario
        mario.x = 120;
        mario.y = 350;
        mario.dx = 0;
        mario.dy = 0;
        mario.onGround = true;
        mario.lives = 5;
        mario.level = 1;
        mario.score = 0;
        mario.shootCooldown = 0;
        mario.invulnerable = 0;

        // Réinitialisation des entités
        enemies = [];
        bullets = [];
        enemyBullets = [];
        powerUps = [];
        particleSystem.clear();

        // Réinitialisation des effets
        bulletTimeActive = false;
        bulletTimeCooldown = 0;
        timeScale = 1.0;
        screenShake = 0;

        document.getElementById("playBtn").textContent = "🎮 JEU EN COURS...";
        document.getElementById("playBtn").disabled = true;
        updateAIStatus("active", "Combat en cours");

        // Changer la musique pour le jeu
        if (audioSystem) {
            audioSystem.playMusic('game');
            audioSystem.playSound('level_up');
        }
    }

    function endRealGame(won) {
        gameRunning = false;
        realGameMode = false;
        timeScale = 1.0;
        bulletTimeActive = false;

        const duration = Date.now() - gameStartTime;

        // Mise à jour des statistiques du jeu réel
        stats.gamesPlayed++;
        if (won) stats.wins++;
        if (mario.score > stats.bestScore) {
            stats.bestScore = mario.score;
            TrainingSystem.updateLeaderboard(mario.score, duration);
        }

        // Adaptation de l'IA basée sur la performance réelle
        mario.adapt({type: 'realGame', score: mario.score, duration: duration}, won);

        document.getElementById("playBtn").textContent = won ?
            "🏆 VICTOIRE! Rejouer?" : "💀 Défaite! Rejouer?";
        document.getElementById("playBtn").disabled = false;

        updateAIStatus("idle", won ? "Victoire obtenue" : "Défaite analysée");

        // Audio de fin de jeu
        if (audioSystem) {
            if (won) {
                audioSystem.playMusic('victory');
                audioSystem.playVictoryFanfare();
            } else {
                audioSystem.playMusic('defeat');
                audioSystem.playSound('damage');
            }
        }

        // Effet visuel de fin
        const flash = document.getElementById('screenFlash');
        flash.style.animation = 'flash 1.5s ease-out';
        flash.style.background = won ?
            'rgba(75, 181, 67, 0.5)' : 'rgba(255, 107, 107, 0.5)';

        setTimeout(() => {
            flash.style.animation = '';
            // Retour à la musique du menu après 3 secondes
            if (audioSystem) {
                audioSystem.playMusic('menu');
            }
        }, 3000);
    }

    function startTraining() {
        initAudio();
        if (audioSystem) {
            audioSystem.playSound('powerup');
        }
        TrainingSystem.startTraining();
    }

    function toggleAutoMode() {
        initAudio();
        gameConfig.autoMode = !gameConfig.autoMode;
        document.getElementById('autoModeStatus').textContent = gameConfig.autoMode ? 'ON' : 'OFF';

        if (audioSystem) {
            audioSystem.playSound('powerup');
        }

        if (gameConfig.autoMode && !gameRunning) {
            autoPlay();
        }
    }

    function autoPlay() {
        if (!gameConfig.autoMode) return;

        startRealGame();

        // Auto-restart après la fin du jeu
        const checkEnd = setInterval(() => {
            if (!gameRunning && gameConfig.autoMode) {
                setTimeout(() => {
                    if (gameConfig.autoMode) {
                        startRealGame();
                    }
                }, 2000);
            } else if (!gameConfig.autoMode) {
                clearInterval(checkEnd);
            }
        }, 1000);
    }

    function resetGame() {
        initAudio();

        // Réinitialisation complète
        gameRunning = false;
        realGameMode = false;
        gameConfig.autoMode = false;

        // Reset Mario
        mario.skills = {
            evasion: 0.5,
            precision: 0.4,
            prediction: 0.3,
            reaction: 0.6,
            positioning: 0.4,
            risk_assessment: 0.5,
            learning_rate: 0.02
        };
        mario.memory = {
            successful_actions: [],
            failed_actions: [],
            enemy_patterns: new Map(),
            optimal_positions: []
        };

        // Reset stats
        stats.gamesPlayed = 0;
        stats.wins = 0;
        stats.totalScore = 0;
        stats.bestScore = 0;
        stats.totalShots = 0;
        stats.hits = 0;
        stats.bulletsDodged = 0;
        stats.totalBullets = 0;
        stats.totalTime = 0;
        stats.longestSurvival = 0;
        stats.aiIQ = 1500;
        stats.iqGrowth = 0;
        stats.leaderboard = [];

        // Reset UI
        document.getElementById("playBtn").textContent = "🎮 COMMENCER JEU IA";
        document.getElementById("playBtn").disabled = false;
        document.getElementById("simulateBtn").textContent = "⚡ ENTRAÎNER IA (1000x)";
        document.getElementById("simulateBtn").disabled = false;
        document.getElementById('autoModeStatus').textContent = 'OFF';
        document.getElementById("progressBar").style.width = "100%";

        TrainingSystem.displayLeaderboard();
        updateAIStatus("idle", "Système réinitialisé");

        // Audio de reset
        if (audioSystem) {
            audioSystem.playSound('powerup');
            audioSystem.playMusic('menu');
        }
    }

    // Fonctions de contrôle audio
    function toggleAudio() {
        initAudio();

        if (audioSystem) {
            const toggle = document.getElementById('audioToggle');
            if (audioSystem.musicVolume > 0 || audioSystem.sfxVolume > 0) {
                // Désactiver l'audio
                audioSystem.setMusicVolume(0);
                audioSystem.setSfxVolume(0);
                toggle.textContent = '🔇 Audio: OFF';
            } else {
                // Réactiver l'audio
                audioSystem.setMusicVolume(0.3);
                audioSystem.setSfxVolume(0.5);
                toggle.textContent = '🔊 Audio: ON';
                document.getElementById('musicVolume').value = 30;
                document.getElementById('sfxVolume').value = 50;
            }
        }
    }

    function setMusicVolume(value) {
        initAudio();
        if (audioSystem) {
            audioSystem.setMusicVolume(value / 100);
        }
    }

    function setSfxVolume(value) {
        initAudio();
        if (audioSystem) {
            audioSystem.setSfxVolume(value / 100);
        }
    } = 0;
    stats.hits = 0;
    stats.bulletsDodged = 0;
    stats.totalBullets = 0;
    stats.totalTime = 0;
    stats.longestSurvival = 0;
    stats.aiIQ = 1500;
    stats.iqGrowth = 0;
    stats.leaderboard = [];

    // Reset UI
    document.getElementById("playBtn").textContent = "🎮 COMMENCER JEU IA";
    document.getElementById("playBtn").disabled = false;
    document.getElementById("simulateBtn").textContent = "⚡ ENTRAÎNER IA (1000x)";
    document.getElementById("simulateBtn").disabled = false;
    document.getElementById('autoModeStatus').textContent = 'OFF';
    document.getElementById("progressBar").style.width = "100%";

    TrainingSystem.displayLeaderboard();
    updateAIStatus("idle", "Système réinitialisé");
    }

    function updateRealGame() {
        if (!gameRunning || !realGameMode) return;

        const elapsed = Date.now() - gameStartTime;

        // Progression de niveau avec audio
        if (mario.level === 1 && elapsed > 20000) {
            mario.level = 2;
            mario.score += 2000;
            screenShake = 20;
            particleSystem.addParticle(mario.x, mario.y, '#ffd700', 'star', 30);

            // Audio de level up
            if (audioSystem) {
                audioSystem.playSound('level_up');
                audioSystem.playMusic('intense'); // Musique plus intense pour niveau 2
            }
        } else if (mario.level === 2 && elapsed > 45000) {
            endRealGame(true);
            return;
        }

        // Décision de l'IA
        EnhancedAI.makeDecision();

        // Gestion du bullet time
        if (bulletTimeCooldown > 0) bulletTimeCooldown--;

        // Physique de Mario avec son de saut
        const oldY = mario.y;
        mario.x += mario.dx;
        mario.y += mario.dy;

        if (!mario.onGround) mario.dy += 1.2; // Gravité

        if (mario.y >= canvas.height - 150) {
            mario.y = canvas.height - 150;
            mario.dy = 0;
            mario.onGround = true;
            mario.jumping = false;

            // Son d'atterrissage si on tombait
            if (oldY < mario.y - 5 && audioSystem) {
                audioSystem.playSound('jump');
            }
        }

        mario.x = Math.max(0, Math.min(canvas.width - mario.width, mario.x));
        mario.dx *= 0.85; // Friction

        if (mario.shootCooldown > 0) mario.shootCooldown--;
        if (mario.invulnerable > 0) mario.invulnerable--;

        // Spawn d'entités basé sur la difficulté
        const difficulty = gameConfig.difficulties[gameConfig.currentDifficulty];

        if (enemies.length < difficulty.maxEnemies && Math.random() < difficulty.enemySpawnRate) {
            enemies.push(new Enemy(gameConfig.currentDifficulty));
        }

        if (powerUps.length < 2 && Math.random() < 0.01) {
            powerUps.push(new PowerUp());
        }

        // Mise à jour des entités
        enemies = enemies.filter(e => {
            e.update();
            return e.x > -80;
        });

        bullets = bullets.filter(b => {
            b.update();
            return b.x < canvas.width + 50;
        });

        enemyBullets = enemyBullets.filter(b => {
            b.update();
            return b.x > -50;
        });

        powerUps = powerUps.filter(p => {
            p.update();
            return p.x > -50;
        });

        // Mise à jour du système de particules
        particleSystem.update();

        // Détection des collisions
        checkCollisions();

        // Condition de défaite
        if (mario.lives <= 0) {
            endRealGame(false);
            return;
        }

        // Diminution du screen shake
        if (screenShake > 0) screenShake--;
    }

    function checkCollisions() {
        // Bullets vs Enemies avec effets sonores
        bullets.forEach((bullet, bi) => {
            enemies.forEach((enemy, ei) => {
                if (bullet.x < enemy.x + enemy.width &&
                    bullet.x + bullet.width > enemy.x &&
                    bullet.y < enemy.y + enemy.height &&
                    bullet.y + bullet.height > enemy.y) {

                    bullets.splice(bi, 1);

                    if (enemy.takeDamage()) {
                        const points = enemy.type === 'heavy' ? 300 :
                            enemy.type === 'shooter' ? 200 :
                                enemy.type === 'fast' ? 150 : 100;
                        mario.score += points;
                        enemies.splice(ei, 1);

                        // Son d'explosion d'ennemi
                        if (audioSystem) {
                            audioSystem.playSound('explosion');
                        }

                        // Texte flottant de score
                        createFloatingText(enemy.x, enemy.y, `+${points}`, '#ffd700');
                    }

                    stats.hits++;
                }
            });
        });

        // Mario vs Enemies/Bullets (si pas invulnérable)
        if (mario.invulnerable <= 0) {
            [...enemies, ...enemyBullets].forEach((entity, index, array) => {
                if (mario.x < entity.x + entity.width &&
                    mario.x + mario.width > entity.x &&
                    mario.y < entity.y + entity.height &&
                    mario.y + entity.height > entity.y) {

                    // Suppression de l'entité
                    if (entity.speed !== undefined) { // Enemy
                        enemies.splice(enemies.indexOf(entity), 1);
                    } else { // Bullet
                        enemyBullets.splice(enemyBullets.indexOf(entity), 1);
                    }

                    mario.lives--;
                    mario.invulnerable = 90;
                    screenShake = 25;

                    // Son de dégât
                    if (audioSystem) {
                        audioSystem.playSound('damage');

                        // Séquence sonore dramatique si vies faibles
                        if (mario.lives <= 1) {
                            audioSystem.playIntenseSequence();
                        }
                    }

                    // Adaptation négative
                    mario.adapt({type: 'damage'}, false);

                    // Particules de dégât
                    particleSystem.addParticle(mario.x + mario.width/2, mario.y + mario.height/2, '#ff0000', 'star', 20);

                    // Texte de dégât
                    createFloatingText(mario.x, mario.y, '-1 VIE', '#ff0000');
                }
            });
        }

        // Mario vs PowerUps avec sons
        powerUps.forEach((powerUp, pi) => {
            if (mario.x < powerUp.x + powerUp.width &&
                mario.x + mario.width > powerUp.x &&
                mario.y < powerUp.y + powerUp.height &&
                mario.y + mario.height > powerUp.y) {

                powerUps.splice(pi, 1);
                mario.score += powerUp.value;

                // Effets spécifiques des power-ups avec audio
                switch(powerUp.type) {
                    case 'bulletTime':
                        EnhancedAI.activateBulletTime();
                        createFloatingText(powerUp.x, powerUp.y, 'BULLET TIME!', '#9d4edd');
                        if (audioSystem) {
                            audioSystem.playBulletTimeSound();
                        }
                        break;
                    case 'rapidFire':
                        mario.shootCooldown = 0;
                        createFloatingText(powerUp.x, powerUp.y, 'RAPID FIRE!', '#ff6b6b');
                        if (audioSystem) {
                            audioSystem.playSound('powerup');
                        }
                        break;
                    case 'shield':
                        mario.invulnerable = 120;
                        createFloatingText(powerUp.x, powerUp.y, 'SHIELD!', '#4ecdc4');
                        if (audioSystem) {
                            audioSystem.playSound('powerup');
                        }
                        break;
                    default:
                        createFloatingText(powerUp.x, powerUp.y, `+${powerUp.value}`, '#ffd700');
                        if (audioSystem) {
                            audioSystem.playSound('powerup');
                        }
                }

                // Particules de collecte
                particleSystem.addParticle(powerUp.x, powerUp.y, powerUp.color, 'star', 15);
            }
        });
    }

    function createFloatingText(x, y, text, color) {
        const textElement = document.createElement('div');
        textElement.className = 'floating-text';
        textElement.textContent = text;
        textElement.style.left = x + 'px';
        textElement.style.top = y + 'px';
        textElement.style.color = color;
        document.body.appendChild(textElement);

        setTimeout(() => {
            document.body.removeChild(textElement);
        }, 2500);
    }

    function draw() {
        // Clear avec dégradé de fond
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, realGameMode ?
            (bulletTimeActive ? "#001133" : "#002200") : "#220033");
        gradient.addColorStop(0.5, "#000011");
        gradient.addColorStop(1, "#000000");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Screen shake
        if (screenShake > 0) {
            ctx.save();
            ctx.translate(
                Math.random() * screenShake - screenShake/2,
                Math.random() * screenShake - screenShake/2
            );
        }

        if (realGameMode && gameRunning) {
            // Sol avec effet
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 150, 0, canvas.height);
            groundGradient.addColorStop(0, "#4a5568");
            groundGradient.addColorStop(0.5, "#2d3748");
            groundGradient.addColorStop(1, "#1a202c");
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 150, canvas.width, 150);

            // Lignes de grille du sol
            ctx.strokeStyle = "rgba(78, 205, 196, 0.2)";
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, canvas.height - 150);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }

            // Mario avec auras multiples
            const glowIntensity = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
            const marioColor = mario.invulnerable > 0 && mario.invulnerable % 10 < 5 ?
                "#ff0000" : "#4ecdc4";

            ctx.save();

            // Aura principale
            ctx.shadowBlur = 20;
            ctx.shadowColor = bulletTimeActive ? '#9d4edd' : marioColor;
            ctx.fillStyle = marioColor;
            ctx.fillRect(mario.x, mario.y, mario.width, mario.height);

            // Aura secondaire pour bullet time
            if (bulletTimeActive) {
                ctx.strokeStyle = `rgba(157, 78, 221, ${glowIntensity})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(mario.x - 5, mario.y - 5, mario.width + 10, mario.height + 10);
            }

            // Indicateur de niveau
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('🤖', mario.x + mario.width/2, mario.y + mario.height/2 + 6);

            ctx.restore();

            // Rendu des entités
            enemies.forEach(e => e.draw(ctx));
            bullets.forEach(b => b.draw(ctx));
            enemyBullets.forEach(b => b.draw(ctx));
            powerUps.forEach(p => p.draw(ctx));

            // Système de particules
            particleSystem.draw(ctx);

            // HUD avancé
            this.drawHUD(ctx);

        } else {
            // Mode attente - affichage des informations IA
            this.drawWaitingScreen(ctx);
        }

        if (screenShake > 0) ctx.restore();
    }

    function drawHUD(ctx) {
        // Panel principal
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(10, 10, 350, 120);

        ctx.strokeStyle = "#4ecdc4";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 10, 350, 120);

        // Informations principales
        ctx.fillStyle = "#ffffff";
        ctx.font = "18px Arial";
        ctx.fillText(`Score: ${mario.score.toLocaleString()}`, 20, 35);
        ctx.fillText(`Vies: ${mario.lives} | Niveau: ${mario.level}`, 20, 60);

        // Barre de vie
        const lifeBarWidth = 200;
        const lifePercentage = mario.lives / 5;

        ctx.fillStyle = "#ff0000";
        ctx.fillRect(20, 70, lifeBarWidth, 12);
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(20, 70, lifeBarWidth * lifePercentage, 12);

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 1;
        ctx.strokeRect(20, 70, lifeBarWidth, 12);

        // État de l'IA
        ctx.fillStyle = bulletTimeActive ? "#9d4edd" : "#ffd700";
        ctx.font = "16px Arial";
        ctx.fillText(bulletTimeActive ? "⏰ BULLET-TIME ACTIF" : "🤖 IA ADAPTIVE", 20, 105);

        // Panel de statistiques en temps réel (côté droit)
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(canvas.width - 200, 10, 190, 140);

        ctx.strokeStyle = "#ff6b6b";
        ctx.lineWidth = 2;
        ctx.strokeRect(canvas.width - 200, 10, 190, 140);

        ctx.fillStyle = "#4ecdc4";
        ctx.font = "14px Arial";
        ctx.fillText("COMPÉTENCES IA:", canvas.width - 190, 30);

        const skills = [
            [`Évasion: ${(mario.skills.evasion * 100).toFixed(0)}%`, mario.skills.evasion],
            [`Précision: ${(mario.skills.precision * 100).toFixed(0)}%`, mario.skills.precision],
            [`Réaction: ${(mario.skills.reaction * 100).toFixed(0)}%`, mario.skills.reaction],
            [`Position: ${(mario.skills.positioning * 100).toFixed(0)}%`, mario.skills.positioning]
        ];

        skills.forEach((skill, i) => {
            ctx.fillStyle = "#ffffff";
            ctx.fillText(skill[0], canvas.width - 190, 50 + i * 20);

            // Barre de compétence
            const barWidth = 80;
            ctx.fillStyle = "#333333";
            ctx.fillRect(canvas.width - 190, 55 + i * 20, barWidth, 8);

            ctx.fillStyle = skill[1] > 0.8 ? "#00ff00" : skill[1] > 0.5 ? "#ffff00" : "#ff6666";
            ctx.fillRect(canvas.width - 190, 55 + i * 20, barWidth * skill[1], 8);
        });

        // Indicateurs de menace
        if (enemyBullets.length > 0) {
            ctx.fillStyle = "#ff3333";
            ctx.font = "16px Arial";
            ctx.fillText(`⚠️ MENACES: ${enemies.length + enemyBullets.length}`, canvas.width - 190, 135);
        }
    }

    function drawWaitingScreen(ctx) {
        // Titre principal
        ctx.fillStyle = "#4ecdc4";
        ctx.font = "48px Arial";
        ctx.textAlign = "center";
        ctx.fillText("IA ADAPTIVE", canvas.width/2, canvas.height/2 - 100);

        // Sous-titre
        ctx.fillStyle = "#ff6b6b";
        ctx.font = "24px Arial";
        ctx.fillText(`Difficulté: ${gameConfig.currentDifficulty.toUpperCase()}`, canvas.width/2, canvas.height/2 - 60);

        // Statistiques actuelles
        ctx.fillStyle = "#ffffff";
        ctx.font = "18px Arial";
        const lines = [
            `QI IA: ${Math.floor(stats.aiIQ)} | Parties: ${stats.gamesPlayed}`,
            `Taux de victoire: ${stats.gamesPlayed > 0 ? ((stats.wins/stats.gamesPlayed)*100).toFixed(1) : 0}%`,
            `Meilleur score: ${stats.bestScore.toLocaleString()}`
        ];

        lines.forEach((line, i) => {
            ctx.fillText(line, canvas.width/2, canvas.height/2 - 10 + i * 30);
        });

        // Compétences moyennes
        ctx.fillStyle = "#4ecdc4";
        ctx.font = "16px Arial";
        const avgSkill = Object.values(mario.skills).reduce((sum, skill, i, arr) => {
            if (typeof skill === 'number' && i < arr.length - 1) {
                return sum + skill;
            }
            return sum;
        }, 0) / 6;

        ctx.fillText(`Niveau d'adaptation: ${(avgSkill * 100).toFixed(1)}%`, canvas.width/2, canvas.height/2 + 80);

        // Animation de particules d'attente
        if (Math.random() < 0.1) {
            particleSystem.addParticle(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                ['#4ecdc4', '#ff6b6b', '#ffd700'][Math.floor(Math.random() * 3)],
                'spark',
                1
            );
        }

        particleSystem.draw(ctx);
    }

    function updateUI() {
        // Mise à jour des statistiques
        document.getElementById("gamesPlayed").textContent = stats.gamesPlayed;
        document.getElementById("wins").textContent = stats.wins;
        document.getElementById("winRate").textContent = stats.gamesPlayed > 0 ?
            ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) + "%" : "0%";
        document.getElementById("currentScore").textContent = realGameMode ? mario.score.toLocaleString() : "0";
        document.getElementById("bestScore").textContent = stats.bestScore.toLocaleString();
        document.getElementById("aiIQ").textContent = Math.floor(stats.aiIQ).toLocaleString();
        document.getElementById("iqGrowth").textContent = Math.floor(stats.iqGrowth);

        // Performance et précision
        const performance = stats.gamesPlayed > 0 ?
            ((stats.wins / stats.gamesPlayed) * (stats.aiIQ / 10000) * 100) : 0;
        document.getElementById("performance").textContent = `${performance.toFixed(1)}%`;

        const avgTime = stats.gamesPlayed > 0 ? (stats.totalTime / stats.gamesPlayed / 1000) : 0;
        document.getElementById("avgTime").textContent = `${avgTime.toFixed(1)}s`;

        const accuracy = stats.totalShots > 0 ? ((stats.hits / stats.totalShots) * 100) : 0;
        document.getElementById("accuracy").textContent = `${accuracy.toFixed(1)}%`;
        document.getElementById("totalShots").textContent = stats.totalShots.toLocaleString();
        document.getElementById("hits").textContent = stats.hits.toLocaleString();

        const evasionRate = stats.totalBullets > 0 ? ((stats.bulletsDodged / stats.totalBullets) * 100) : 0;
        document.getElementById("evasionRate").textContent = `${evasionRate.toFixed(1)}%`;
        document.getElementById("dodged").textContent = stats.bulletsDodged.toLocaleString();
        document.getElementById("totalBullets").textContent = stats.totalBullets.toLocaleString();

        // Mise à jour du texte de statut
        document.getElementById("statusText").textContent = realGameMode ?
            `Combat en cours - Score: ${mario.score.toLocaleString()} | IA: ${bulletTimeActive ? "BULLET-TIME" : "ADAPTIVE"}` :
            `IA prête | QI: ${Math.floor(stats.aiIQ).toLocaleString()} | Entraînement: ${stats.gamesPlayed}/${gameConfig.trainingTarget}`;
    }

    function gameLoop() {
        updateRealGame();
        draw();
        updateUI();
        requestAnimationFrame(gameLoop);
    }

    // Initialisation avec gestion des événements utilisateur
    updateAIStatus("idle", "Système initialisé");
    TrainingSystem.displayLeaderboard();

    // Initialiser l'audio au premier clic/touche
    document.addEventListener('click', initAudio, { once: true });
    document.addEventListener('keydown', initAudio, { once: true });
    document.addEventListener('touchstart', initAudio, { once: true });

    gameLoop();
</script>
</body>
</html>