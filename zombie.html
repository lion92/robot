<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robots vs Zombies - IA Adaptative</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #00ff41;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .hud, .wave-info, .ai-status {
            position: fixed;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }

        .hud { top: 20px; left: 20px; }
        .hud h4 { color: #00ff41; margin-bottom: 10px; font-weight: 700; }
        .hud div { font-size: 14px; margin: 5px 0; color: #fff; }

        .wave-info { top: 20px; right: 20px; min-width: 200px; }
        .wave-info h4 { color: #ff4444; margin-bottom: 10px; font-weight: 700; }
        .wave-info div { font-size: 12px; margin: 3px 0; color: #fff; }

        .ai-status { bottom: 20px; right: 20px; min-width: 300px; max-height: 300px; overflow-y: auto; }
        .ai-status h4 { color: #4ecdc4; margin-bottom: 10px; font-weight: 700; }
        .ai-status .robot-ai { font-size: 10px; margin: 2px 0; padding: 2px; border-left: 2px solid #4ecdc4; }

        .timer {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 72px; font-weight: 900; color: #ff4444;
            text-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
            z-index: 200; display: none;
        }

        .controls {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 150;
        }

        .btn {
            padding: 15px 30px; background: linear-gradient(45deg, #00ff41, #00cc33);
            border: none; color: #000; font-family: inherit; font-weight: 700;
            border-radius: 5px; cursor: pointer; transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn:hover { transform: translateY(-3px); box-shadow: 0 10px 20px rgba(0, 255, 65, 0.4); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .game-log {
            position: fixed; bottom: 20px; left: 20px; width: 400px; height: 200px;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(15px);
            border: 1px solid #00ff41; border-radius: 10px;
            padding: 15px; z-index: 100; overflow-y: auto;
        }
        .game-log h4 { margin-bottom: 10px; font-weight: 700; color: #00ff41; }
        .game-log .log-entry {
            font-size: 11px; margin: 2px 0;
            animation: fadeIn 0.3s ease-in;
        }
        .log-entry.combat { color: #ff4444; }
        .log-entry.ai { color: #4ecdc4; }
        .log-entry.wave { color: #ffa500; font-weight: 700; }
        .log-entry.system { color: #00ff41; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .robot-vision {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.1); backdrop-filter: blur(10px);
            border: 2px solid #00ff41; border-radius: 15px;
            padding: 15px; z-index: 120; display: none;
        }
        .robot-vision h4 { color: #00ff41; margin-bottom: 10px; text-align: center; }

        .robot-crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; z-index: 150; display: none;
            border: 2px solid #ff4444; border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
        }
        .robot-crosshair::before {
            content: '‚ö°';
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 16px; color: #ff4444;
        }
    </style>
</head>
<body>
<div id="gameContainer"></div>

<div class="hud">
    <h4>ü§ñ ROBOTS D√âFENSEURS</h4>
    <div>Robots Actifs: <span id="aliveRobots">16</span></div>
    <div>Zombies Tu√©s: <span id="zombiesKilled">0</span></div>
    <div>Score: <span id="totalScore">0</span></div>
    <div>Munitions: <span id="totalAmmo">‚àû</span></div>
</div>

<div class="timer" id="timer">VAGUE 1</div>

<div class="wave-info">
    <h4>üßü INVASION ZOMBIE</h4>
    <div id="waveContent">
        <div>Vague: <span id="currentWave">1</span></div>
        <div>Zombies Restants: <span id="zombiesLeft">0</span></div>
        <div>Prochaine Vague: <span id="nextWaveTimer">30s</span></div>
        <div>Difficult√©: <span id="difficulty">Facile</span></div>
    </div>
</div>

<div class="ai-status">
    <h4>üß† STATUT IA ADAPTATIVE</h4>
    <div id="aiStatusContent"></div>
</div>

<div class="controls">
    <button class="btn" id="startBtn">‚ö° D√âMARRER D√âFENSE</button>
    <button class="btn" id="resetBtn">üîÑ RESET</button>
</div>

<div class="game-log">
    <h4>üì° JOURNAL TACTIQUE</h4>
    <div id="gameLog"></div>
</div>

<div class="robot-vision" id="robotVision">
    <h4>üëÅÔ∏è VISION ROBOT</h4>
    <div id="robotVisionContent"></div>
</div>

<div class="robot-crosshair" id="robotCrosshair"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Configuration du jeu de survie
    const CONFIG = {
        ROBOTS: 16, ARENA_SIZE: 80, ROBOT_SPEED: 0.25, BULLET_SPEED: 3,
        ZOMBIE_SPEED: 0.15, ZOMBIE_HEALTH: 50, ROBOT_HEALTH: 200,
        FIRE_RATE: 300, DETECTION_RANGE: 40, FORMATION_DISTANCE: 12,
        WAVE_DELAY: 15000, DIFFICULTY_SCALING: 1.2
    };

    const ROBOT_TYPES = [
        { name: 'Assault', body: 'cube', color: '#ff4444', icon: 'üî´', role: 'attacker', damage: 25 },
        { name: 'Sniper', body: 'cylinder', color: '#4444ff', icon: 'üéØ', role: 'sniper', damage: 50 },
        { name: 'Tank', body: 'sphere', color: '#44ff44', icon: 'üõ°Ô∏è', role: 'tank', damage: 15 },
        { name: 'Support', body: 'octahedron', color: '#ffff44', icon: '‚ö°', role: 'support', damage: 20 }
    ];

    const AI_BEHAVIORS = {
        AGGRESSIVE: { priority: 'closest_enemy', formation: 'frontline', risk: 0.8 },
        DEFENSIVE: { priority: 'protect_weak', formation: 'circle', risk: 0.3 },
        TACTICAL: { priority: 'high_value_target', formation: 'spread', risk: 0.5 },
        ADAPTIVE: { priority: 'dynamic', formation: 'adaptive', risk: 0.6 }
    };

    // Variables globales
    let gameState = 'idle', currentWave = 1, waveTimer = CONFIG.WAVE_DELAY;
    let robots = [], zombies = [], bullets = [], scene, camera, renderer;
    let robotMeshes = [], zombieMeshes = [], bulletMeshes = [];
    let stats = { zombiesKilled: 0, totalScore: 0, wavesCompleted: 0 };
    let gameLog = [], robotVisionMode = false, currentViewedRobot = 0;
    let aiLearning = { successfulTactics: new Map(), failedTactics: new Map() };

    // Syst√®me de logs
    function addLog(message, type = 'system') {
        const timestamp = new Date().toLocaleTimeString('fr-FR', {
            hour: '2-digit', minute: '2-digit', second: '2-digit'
        });

        gameLog.push({ time: timestamp, message: message, type: type });
        if (gameLog.length > 50) gameLog.shift();
        updateLogDisplay();
    }

    function updateLogDisplay() {
        const logContainer = document.getElementById('gameLog');
        logContainer.innerHTML = '';

        gameLog.slice(-15).reverse().forEach(log => {
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry ${log.type}`;
            logDiv.innerHTML = `<span style="opacity: 0.6;">[${log.time}]</span> ${log.message}`;
            logContainer.appendChild(logDiv);
        });
    }

    // Initialisation Three.js
    function initThreeJS() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a1a2e, 50, 200);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 80, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x1a1a2e);
        document.getElementById('gameContainer').appendChild(renderer.domElement);

        // √âclairage apocalyptique
        scene.add(new THREE.AmbientLight(0x404040, 0.4));

        const moonLight = new THREE.DirectionalLight(0x8888ff, 0.8);
        moonLight.position.set(50, 100, 50);
        moonLight.castShadow = true;
        scene.add(moonLight);

        const fireLight = new THREE.PointLight(0xff4444, 1, 100);
        fireLight.position.set(0, 10, 0);
        scene.add(fireLight);

        // Sol de bataille
        const floor = new THREE.Mesh(
            new THREE.CircleGeometry(CONFIG.ARENA_SIZE, 64),
            new THREE.MeshLambertMaterial({ color: 0x2d2d2d })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        setupControls();
        window.addEventListener('resize', onWindowResize);
    }

    function setupControls() {
        let mouseDown = false, angle = 0, height = 80;

        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);
        document.addEventListener('mousemove', (e) => {
            if (mouseDown && !robotVisionMode) {
                angle += e.movementX * 0.01;
                height = Math.max(40, Math.min(150, height - e.movementY * 0.5));
                updateCamera();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'b') toggleRobotVision();
            if (robotVisionMode) {
                if (e.key === 'ArrowLeft') switchToRobot(-1);
                if (e.key === 'ArrowRight') switchToRobot(1);
            }
        });

        function updateCamera() {
            if (!robotVisionMode) {
                const distance = 120;
                camera.position.set(Math.sin(angle) * distance, height, Math.cos(angle) * distance);
                camera.lookAt(0, 0, 0);
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Initialisation du jeu
    function initGame() {
        robots = []; zombies = []; bullets = [];
        stats = { zombiesKilled: 0, totalScore: 0, wavesCompleted: 0 };
        currentWave = 1; waveTimer = CONFIG.WAVE_DELAY;
        clearMeshes();
        createRobots();
        updateUI();
        addLog('ü§ñ Syst√®me de d√©fense robotique initialis√©', 'system');
        addLog('üß† IA adaptative en ligne - Analyse des patterns ennemis', 'ai');
    }

    function clearMeshes() {
        [...robotMeshes, ...zombieMeshes, ...bulletMeshes].forEach(mesh => scene.remove(mesh));
        robotMeshes = []; zombieMeshes = []; bulletMeshes = [];
    }

    function createRobots() {
        for (let i = 0; i < CONFIG.ROBOTS; i++) {
            const type = ROBOT_TYPES[i % ROBOT_TYPES.length];
            const angle = (i / CONFIG.ROBOTS) * Math.PI * 2;
            const radius = 15 + (i % 4) * 5; // Formation en cercles concentriques

            const robot = {
                id: i,
                name: `${type.name}-${(i % 4) + 1}`,
                type: type,
                x: Math.cos(angle) * radius,
                z: Math.sin(angle) * radius,
                health: CONFIG.ROBOT_HEALTH,
                maxHealth: CONFIG.ROBOT_HEALTH,
                target: null,
                lastShot: 0,
                alive: true,
                // IA Adaptative
                behavior: 'ADAPTIVE',
                experience: 0,
                accuracy: 0.7,
                killCount: 0,
                preferredRange: type.role === 'sniper' ? 35 : type.role === 'tank' ? 10 : 20,
                learningRate: 0.1,
                tacticalMemory: new Map(),
                formationRole: assignFormationRole(i, type.role),
                // √âtats tactiques
                isReloading: false,
                ammoCount: 100,
                suppressingFire: false,
                coverPosition: null
            };

            robots.push(robot);
            createRobotMesh(robot);
        }

        addLog(`ü§ñ ${CONFIG.ROBOTS} robots d√©ploy√©s avec IA adaptative`, 'system');
        analyzeFormation();
    }

    function assignFormationRole(index, role) {
        const roles = ['frontline', 'support', 'flanker', 'sniper'];
        if (role === 'tank') return 'frontline';
        if (role === 'sniper') return 'sniper';
        if (role === 'support') return 'support';
        return roles[index % roles.length];
    }

    function analyzeFormation() {
        const formation = robots.reduce((acc, robot) => {
            acc[robot.formationRole] = (acc[robot.formationRole] || 0) + 1;
            return acc;
        }, {});

        addLog(`üìä Formation analys√©e: ${Object.entries(formation).map(([role, count]) => `${role}:${count}`).join(', ')}`, 'ai');
    }

    function createRobotMesh(robot) {
        const group = new THREE.Group();
        const color = new THREE.Color(robot.type.color);
        const scale = 1.2;

        // Corps selon le r√¥le
        let bodyGeometry;
        switch (robot.type.body) {
            case 'cube':
                bodyGeometry = new THREE.BoxGeometry(2 * scale, 2 * scale, 2 * scale);
                break;
            case 'cylinder':
                bodyGeometry = new THREE.CylinderGeometry(1 * scale, 1 * scale, 2.5 * scale, 16);
                break;
            case 'octahedron':
                bodyGeometry = new THREE.OctahedronGeometry(1.3 * scale);
                break;
            default:
                bodyGeometry = new THREE.SphereGeometry(1.2 * scale, 16, 16);
        }

        const body = new THREE.Mesh(bodyGeometry, new THREE.MeshLambertMaterial({ color: color }));
        body.position.y = 2 * scale;
        body.castShadow = true;
        group.add(body);

        // Canon d'arme
        const cannon = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.15, 2, 8),
            new THREE.MeshLambertMaterial({ color: 0x444444 })
        );
        cannon.rotation.z = Math.PI / 2;
        cannon.position.set(1.5, 2, 0);
        group.add(cannon);

        // Indicateur de sant√©
        const healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 0.2),
            new THREE.MeshBasicMaterial({ color: 0x00ff00 })
        );
        healthBar.position.set(0, 4, 0);
        group.add(healthBar);

        group.position.set(robot.x, 0, robot.z);
        robotMeshes.push(group);
        scene.add(group);
    }

    // Syst√®me de vagues de zombies
    function spawnWave() {
        const zombieCount = Math.floor(5 + currentWave * CONFIG.DIFFICULTY_SCALING * 2);
        const zombieHealth = CONFIG.ZOMBIE_HEALTH + (currentWave - 1) * 10;

        addLog(`üßü VAGUE ${currentWave}: ${zombieCount} zombies d√©tect√©s !`, 'wave');
        addLog(`‚ö†Ô∏è Zombies renforc√©s: ${zombieHealth} HP chacun`, 'wave');

        for (let i = 0; i < zombieCount; i++) {
            setTimeout(() => createZombie(zombieHealth), i * 200);
        }

        // IA adapte la strat√©gie selon la vague
        adaptAIStrategy(currentWave, zombieCount);
    }

    function createZombie(health) {
        const angle = Math.random() * Math.PI * 2;
        const spawnRadius = CONFIG.ARENA_SIZE + 20;

        const zombie = {
            id: zombies.length,
            x: Math.cos(angle) * spawnRadius,
            z: Math.sin(angle) * spawnRadius,
            health: health,
            maxHealth: health,
            speed: CONFIG.ZOMBIE_SPEED + Math.random() * 0.05,
            target: null,
            alive: true,
            lastAttack: 0,
            type: Math.random() < 0.1 ? 'fast' : Math.random() < 0.1 ? 'tank' : 'normal'
        };

        // Variants de zombies
        if (zombie.type === 'fast') {
            zombie.speed *= 1.5;
            zombie.health *= 0.7;
        } else if (zombie.type === 'tank') {
            zombie.speed *= 0.7;
            zombie.health *= 1.8;
        }

        zombies.push(zombie);
        createZombieMesh(zombie);
    }

    function createZombieMesh(zombie) {
        const group = new THREE.Group();
        const color = zombie.type === 'fast' ? 0xff4444 : zombie.type === 'tank' ? 0x444444 : 0x00aa00;
        const scale = zombie.type === 'tank' ? 1.3 : zombie.type === 'fast' ? 0.8 : 1.0;

        // Corps zombie
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(1.5 * scale, 2 * scale, 1 * scale),
            new THREE.MeshLambertMaterial({ color: color })
        );
        body.position.y = 1 * scale;
        body.castShadow = true;
        group.add(body);

        // T√™te
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.6 * scale, 8, 8),
            new THREE.MeshLambertMaterial({ color: color })
        );
        head.position.y = 2.5 * scale;
        group.add(head);

        // Yeux rouges brillants
        [-0.2, 0.2].forEach(x => {
            const eye = new THREE.Mesh(
                new THREE.SphereGeometry(0.05 * scale, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.0 })
            );
            eye.position.set(x * scale, 2.6 * scale, 0.5 * scale);
            group.add(eye);
        });

        // Bras mena√ßants
        [-0.8, 0.8].forEach(x => {
            const arm = new THREE.Mesh(
                new THREE.BoxGeometry(0.3 * scale, 1.5 * scale, 0.3 * scale),
                new THREE.MeshLambertMaterial({ color: color })
            );
            arm.position.set(x * scale, 1.5 * scale, 0);
            arm.castShadow = true;
            group.add(arm);
        });

        // Barre de vie zombie
        const healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(2 * scale, 0.2),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        healthBar.position.set(0, 3.5 * scale, 0);
        group.add(healthBar);

        group.position.set(zombie.x, 0, zombie.z);
        zombieMeshes.push(group);
        scene.add(group);
    }

    // IA Adaptative des robots
    function updateRobotAI(robot) {
        if (!robot.alive) return;

        const now = Date.now();

        // Analyse de la situation tactique
        const situation = analyzeTacticalSituation(robot);

        // Apprentissage bas√© sur l'exp√©rience
        adaptBehaviorFromExperience(robot, situation);

        // S√©lection de cible intelligente
        selectOptimalTarget(robot, situation);

        // Positionnement tactique
        updateTacticalPosition(robot, situation);

        // Tir adaptatif
        if (robot.target && canShoot(robot, now)) {
            executeAdaptiveFiring(robot, now);
        }

        // Mise √† jour des statistiques d'apprentissage
        updateLearningStats(robot, situation);
    }

    function analyzeTacticalSituation(robot) {
        const nearbyZombies = zombies.filter(z => z.alive && getDistance(robot, z) < CONFIG.DETECTION_RANGE);
        const nearbyRobots = robots.filter(r => r.alive && r.id !== robot.id && getDistance(robot, r) < 20);

        const situation = {
            enemyCount: nearbyZombies.length,
            closestEnemy: nearbyZombies.sort((a, b) => getDistance(robot, a) - getDistance(robot, b))[0],
            averageEnemyDistance: nearbyZombies.length > 0 ?
                nearbyZombies.reduce((sum, z) => sum + getDistance(robot, z), 0) / nearbyZombies.length : 100,
            alliesNearby: nearbyRobots.length,
            healthRatio: robot.health / robot.maxHealth,
            ammoRatio: robot.ammoCount / 100,
            threatLevel: calculateThreatLevel(robot, nearbyZombies),
            formationIntegrity: checkFormationIntegrity(robot)
        };

        return situation;
    }

    function calculateThreatLevel(robot, enemies) {
        if (enemies.length === 0) return 0;

        let threat = 0;
        enemies.forEach(enemy => {
            const distance = getDistance(robot, enemy);
            const enemyThreat = (100 - distance) / 100; // Plus proche = plus dangereux
            threat += enemyThreat * (enemy.type === 'tank' ? 1.5 : enemy.type === 'fast' ? 1.2 : 1);
        });

        return Math.min(threat, 10); // Cap √† 10
    }

    function checkFormationIntegrity(robot) {
        const rolePositions = robots.filter(r => r.alive && r.formationRole === robot.formationRole);
        if (rolePositions.length <= 1) return 1;

        const avgDistance = rolePositions.reduce((sum, r) => {
            if (r.id === robot.id) return sum;
            return sum + getDistance(robot, r);
        }, 0) / (rolePositions.length - 1);

        return Math.max(0, 1 - (avgDistance - CONFIG.FORMATION_DISTANCE) / CONFIG.FORMATION_DISTANCE);
    }

    function adaptBehaviorFromExperience(robot, situation) {
        // L'IA apprend de ses succ√®s et √©checs pr√©c√©dents
        const contextKey = `threat_${Math.floor(situation.threatLevel)}_enemies_${Math.min(situation.enemyCount, 5)}`;

        if (robot.tacticalMemory.has(contextKey)) {
            const memory = robot.tacticalMemory.get(contextKey);

            // Ajuster le comportement bas√© sur le succ√®s pass√©
            if (memory.success > memory.failure) {
                robot.behavior = memory.bestBehavior;
                robot.preferredRange = memory.bestRange;
            } else {
                // Essayer une nouvelle approche
                robot.behavior = getAlternativeBehavior(robot.behavior);
                addLog(`üß† ${robot.name} adapte sa strat√©gie apr√®s analyse des √©checs`, 'ai');
            }
        }

        // Adaptation en temps r√©el
        if (situation.healthRatio < 0.3) {
            robot.behavior = 'DEFENSIVE';
            addLog(`üõ°Ô∏è ${robot.name} passe en mode d√©fensif (vie critique)`, 'ai');
        } else if (situation.threatLevel > 7) {
            robot.behavior = 'AGGRESSIVE';
            robot.suppressingFire = true;
        }
    }

    function getAlternativeBehavior(currentBehavior) {
        const behaviors = ['AGGRESSIVE', 'DEFENSIVE', 'TACTICAL', 'ADAPTIVE'];
        const current = behaviors.indexOf(currentBehavior);
        return behaviors[(current + 1) % behaviors.length];
    }

    function selectOptimalTarget(robot, situation) {
        if (!situation.closestEnemy) {
            robot.target = null;
            return;
        }

        const possibleTargets = zombies.filter(z => z.alive && getDistance(robot, z) < CONFIG.DETECTION_RANGE);
        if (possibleTargets.length === 0) return;

        let bestTarget = null;
        let bestScore = -1;

        possibleTargets.forEach(zombie => {
            const distance = getDistance(robot, zombie);
            const healthRatio = zombie.health / zombie.maxHealth;

            let score = 0;

            // Scoring bas√© sur le comportement IA
            switch (robot.behavior) {
                case 'AGGRESSIVE':
                    score = (100 - distance) + (healthRatio * 50); // Pr√©f√®re proches et bless√©s
                    break;
                case 'DEFENSIVE':
                    score = (100 - distance) + (robot.health < robot.maxHealth * 0.5 ? 100 : 0);
                    break;
                case 'TACTICAL':
                    // Pr√©f√®re les cibles isol√©es ou dangereuses
                    const nearbyEnemies = zombies.filter(z => z.alive && getDistance(zombie, z) < 10).length;
                    score = (zombie.type === 'tank' ? 80 : 40) - nearbyEnemies * 10 + (100 - distance);
                    break;
                case 'ADAPTIVE':
                    // Combinaison intelligente
                    score = (100 - distance) * 0.4 + (zombie.type === 'fast' ? 60 : 30) +
                        (robot.accuracy * 100) * 0.3;
                    break;
            }

            // Bonus si d'autres robots visent la m√™me cible (tir concentr√©)
            const robotsTargetingSame = robots.filter(r => r.alive && r.target && r.target.id === zombie.id).length;
            if (robotsTargetingSame > 1 && zombie.type === 'tank') {
                score += 30; // Bonus pour focus fire sur tanks
            }

            if (score > bestScore) {
                bestScore = score;
                bestTarget = zombie;
            }
        });

        // Changement de cible intelligent
        if (robot.target !== bestTarget) {
            if (robot.target) {
                addLog(`üéØ ${robot.name} change de cible: ${robot.target.type} ‚Üí ${bestTarget.type}`, 'ai');
            }
            robot.target = bestTarget;
        }
    }

    function updateTacticalPosition(robot, situation) {
        if (!robot.target) return;

        let targetX = robot.x;
        let targetZ = robot.z;

        const enemyX = robot.target.x;
        const enemyZ = robot.target.z;
        const distance = getDistance(robot, robot.target);

        // Positionnement selon le r√¥le et la situation
        switch (robot.formationRole) {
            case 'frontline':
                // Tanks avancent mais maintiennent distance optimale
                if (distance > robot.preferredRange + 5) {
                    const direction = Math.atan2(enemyZ - robot.z, enemyX - robot.x);
                    targetX = robot.x + Math.cos(direction) * CONFIG.ROBOT_SPEED;
                    targetZ = robot.z + Math.sin(direction) * CONFIG.ROBOT_SPEED;
                } else if (distance < robot.preferredRange - 3) {
                    // Reculer si trop proche
                    const direction = Math.atan2(robot.z - enemyZ, robot.x - enemyX);
                    targetX = robot.x + Math.cos(direction) * CONFIG.ROBOT_SPEED * 0.5;
                    targetZ = robot.z + Math.sin(direction) * CONFIG.ROBOT_SPEED * 0.5;
                }
                break;

            case 'sniper':
                // Snipers cherchent position √©lev√©e et distance
                if (distance < robot.preferredRange) {
                    const direction = Math.atan2(robot.z - enemyZ, robot.x - enemyX);
                    targetX = robot.x + Math.cos(direction) * CONFIG.ROBOT_SPEED;
                    targetZ = robot.z + Math.sin(direction) * CONFIG.ROBOT_SPEED;
                }
                // Chercher couverture si sant√© faible
                if (robot.health < robot.maxHealth * 0.5) {
                    const coverPos = findCoverPosition(robot, situation);
                    if (coverPos) {
                        targetX = coverPos.x;
                        targetZ = coverPos.z;
                    }
                }
                break;

            case 'support':
                // Support reste pr√®s des alli√©s bless√©s
                const injuredRobot = robots.find(r => r.alive && r.health < r.maxHealth * 0.4);
                if (injuredRobot) {
                    const direction = Math.atan2(injuredRobot.z - robot.z, injuredRobot.x - robot.x);
                    targetX = robot.x + Math.cos(direction) * CONFIG.ROBOT_SPEED * 0.8;
                    targetZ = robot.z + Math.sin(direction) * CONFIG.ROBOT_SPEED * 0.8;
                }
                break;

            case 'flanker':
                // Flankers contournent l'ennemi
                const flankAngle = Math.atan2(enemyZ - robot.z, enemyX - robot.x) + Math.PI / 2;
                targetX = robot.x + Math.cos(flankAngle) * CONFIG.ROBOT_SPEED;
                targetZ = robot.z + Math.sin(flankAngle) * CONFIG.ROBOT_SPEED;
                break;
        }

        // √âviter les collisions avec alli√©s
        const nearbyAllies = robots.filter(r => r.alive && r.id !== robot.id &&
            getDistance({x: targetX, z: targetZ}, r) < 3);
        if (nearbyAllies.length > 0) {
            const avoidDirection = Math.random() * Math.PI * 2;
            targetX += Math.cos(avoidDirection) * 2;
            targetZ += Math.sin(avoidDirection) * 2;
        }

        // Rester dans les limites
        const centerDistance = Math.sqrt(targetX * targetX + targetZ * targetZ);
        if (centerDistance > CONFIG.ARENA_SIZE - 10) {
            targetX *= 0.9;
            targetZ *= 0.9;
        }

        robot.x = targetX;
        robot.z = targetZ;
    }

    function findCoverPosition(robot, situation) {
        // Trouve une position avec des alli√©s entre le robot et les ennemis
        const allies = robots.filter(r => r.alive && r.id !== robot.id);

        for (let ally of allies) {
            const allyDistance = getDistance(robot, ally);
            if (allyDistance > 5 && allyDistance < 15) {
                // Position derri√®re l'alli√©
                const angle = Math.atan2(ally.z - robot.z, ally.x - robot.x);
                return {
                    x: ally.x - Math.cos(angle) * 8,
                    z: ally.z - Math.sin(angle) * 8
                };
            }
        }
        return null;
    }

    function executeAdaptiveFiring(robot, now) {
        if (!robot.target || robot.ammoCount <= 0) return;

        const distance = getDistance(robot, robot.target);

        // Calcul de pr√©cision adaptatif
        let accuracy = robot.accuracy;

        // Facteurs influen√ßant la pr√©cision
        accuracy *= Math.max(0.3, 1 - (distance - robot.preferredRange) / robot.preferredRange);
        accuracy *= robot.health / robot.maxHealth; // Sant√© affecte pr√©cision
        accuracy += robot.experience * 0.01; // Exp√©rience am√©liore pr√©cision

        // Mode tir de suppression
        if (robot.suppressingFire) {
            accuracy *= 0.7; // Moins pr√©cis mais tir plus rapide
        }

        // Tir pr√©dictif pour cibles mobiles
        const predictedX = robot.target.x + robot.target.vx * distance / CONFIG.BULLET_SPEED;
        const predictedZ = robot.target.z + robot.target.vz * distance / CONFIG.BULLET_SPEED;

        fireBullet(robot, { x: predictedX, z: predictedZ }, accuracy, now);

        robot.ammoCount--;
        robot.lastShot = now;

        // Apprentissage du tir
        robot.experience += 0.1;
    }

    function fireBullet(robot, target, accuracy, now) {
        const spread = (1 - accuracy) * 0.3;
        const angleToTarget = Math.atan2(target.z - robot.z, target.x - robot.x);
        const finalAngle = angleToTarget + (Math.random() - 0.5) * spread;

        const bullet = {
            x: robot.x,
            y: 2,
            z: robot.z,
            vx: Math.cos(finalAngle) * CONFIG.BULLET_SPEED,
            vz: Math.sin(finalAngle) * CONFIG.BULLET_SPEED,
            damage: robot.type.damage,
            owner: robot.id,
            life: 100,
            type: 'bullet'
        };

        bullets.push(bullet);

        // Mesh de balle avec tra√Æn√©e
        const mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 8, 8),
            new THREE.MeshBasicMaterial({
                color: robot.type.color,
                emissive: robot.type.color,
                emissiveIntensity: 0.8
            })
        );
        mesh.position.set(robot.x, 2, robot.z);
        bulletMeshes.push(mesh);
        scene.add(mesh);

        // Effet de flash de tir
        createMuzzleFlash(robot);

        addLog(`üî´ ${robot.name} tire (pr√©cision: ${Math.round(accuracy * 100)}%)`, 'combat');
    }

    function createMuzzleFlash(robot) {
        const flash = new THREE.Mesh(
            new THREE.SphereGeometry(1, 8, 8),
            new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.8
            })
        );
        flash.position.set(robot.x, 2, robot.z);
        scene.add(flash);

        // Supprimer le flash apr√®s 100ms
        setTimeout(() => {
            scene.remove(flash);
        }, 100);
    }

    function canShoot(robot, now) {
        const fireRate = robot.suppressingFire ? CONFIG.FIRE_RATE * 0.6 : CONFIG.FIRE_RATE;
        return now - robot.lastShot > fireRate && robot.ammoCount > 0;
    }

    function updateLearningStats(robot, situation) {
        // Enregistrer les situations et r√©sultats pour apprentissage
        const contextKey = `threat_${Math.floor(situation.threatLevel)}_enemies_${Math.min(situation.enemyCount, 5)}`;

        if (!robot.tacticalMemory.has(contextKey)) {
            robot.tacticalMemory.set(contextKey, {
                success: 0,
                failure: 0,
                bestBehavior: robot.behavior,
                bestRange: robot.preferredRange
            });
        }

        // √âvaluer le succ√®s (survie + kills r√©cents)
        const isSuccessful = robot.health > robot.maxHealth * 0.7 &&
            (Date.now() - robot.lastKill < 5000 || situation.threatLevel < 3);

        const memory = robot.tacticalMemory.get(contextKey);
        if (isSuccessful) {
            memory.success++;
            memory.bestBehavior = robot.behavior;
            memory.bestRange = robot.preferredRange;
        } else if (robot.health < robot.maxHealth * 0.5) {
            memory.failure++;
        }
    }

    function adaptAIStrategy(wave, zombieCount) {
        addLog(`üß† IA analyse vague ${wave}: ${zombieCount} ennemis d√©tect√©s`, 'ai');

        // Adaptation globale bas√©e sur la vague
        robots.forEach(robot => {
            if (wave > 3) {
                robot.preferredRange *= 1.1; // Plus prudent
                robot.accuracy = Math.min(0.95, robot.accuracy + 0.05);
            }

            if (zombieCount > 15) {
                robot.behavior = 'DEFENSIVE';
                robot.suppressingFire = true;
                addLog(`üõ°Ô∏è ${robot.name} active le mode d√©fensif avanc√©`, 'ai');
            } else if (zombieCount < 8) {
                robot.behavior = 'AGGRESSIVE';
                addLog(`‚öîÔ∏è ${robot.name} passe en mode offensif`, 'ai');
            }
        });
    }

    function updateRobotMesh(robot, index) {
        const mesh = robotMeshes[index];
        if (!mesh) return;

        mesh.position.set(robot.x, 0, robot.z);

        // Orientation vers la cible
        if (robot.target) {
            const angle = Math.atan2(robot.target.z - robot.z, robot.target.x - robot.x);
            mesh.rotation.y = angle;

            // Animation du canon
            if (mesh.children[1]) { // Canon
                mesh.children[1].rotation.y = angle;
            }
        }

        // Mise √† jour barre de vie
        if (mesh.children[2]) { // Barre de sant√©
            const healthPercent = robot.health / robot.maxHealth;
            mesh.children[2].material.color.setHex(
                healthPercent > 0.6 ? 0x00ff00 :
                    healthPercent > 0.3 ? 0xffff00 : 0xff0000
            );
            mesh.children[2].scale.x = healthPercent;
        }

        // Animation de tir
        const timeSinceShot = Date.now() - robot.lastShot;
        if (timeSinceShot < 200 && mesh.children[1]) {
            mesh.children[1].position.x = 1.2; // Recul du canon
        } else if (mesh.children[1]) {
            mesh.children[1].position.x = 1.5;
        }
    }
    zombies.forEach((zombie, index) => {
        if (!zombie.alive) return;

        // IA zombie simple mais mena√ßante
        const nearestRobot = robots.filter(r => r.alive)
            .sort((a, b) => getDistance(zombie, a) - getDistance(zombie, b))[0];

        if (nearestRobot) {
            zombie.target = nearestRobot;
            const dx = nearestRobot.x - zombie.x;
            const dz = nearestRobot.z - zombie.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            if (distance > 0) {
                zombie.vx = (dx / distance) * zombie.speed;
                zombie.vz = (dz / distance) * zombie.speed;
                zombie.x += zombie.vx;
                zombie.z += zombie.vz;

                // Attaque au corps √† corps
                if (distance < 3 && Date.now() - zombie.lastAttack > 1000) {
                    nearestRobot.health -= 15;
                    zombie.lastAttack = Date.now();
                    addLog(`üßü ${zombie.type} zombie attaque ${nearestRobot.name} !`, 'combat');

                    if (nearestRobot.health <= 0) {
                        nearestRobot.alive = false;
                        addLog(`üíÄ ${nearestRobot.name} est d√©truit !`, 'combat');
                    }
                }
            }
        }

        updateZombieMesh(zombie, index);
    })

    function updateZombieMesh(zombie, index) {
        const mesh = zombieMeshes[index];
        if (!mesh || !zombie.alive) return;

        mesh.position.set(zombie.x, 0, zombie.z);

        // Orientation vers la cible
        if (zombie.target) {
            const angle = Math.atan2(zombie.target.z - zombie.z, zombie.target.x - zombie.x);
            mesh.rotation.y = angle;
        }

        // Animation de marche agressive
        const walkCycle = Date.now() * 0.008 * zombie.speed;
        mesh.position.y = Math.abs(Math.sin(walkCycle)) * 0.2;
        mesh.rotation.z = Math.sin(walkCycle * 2) * 0.1;

        // Barre de vie zombie
        if (mesh.children[5]) { // Barre de sant√©
            const healthPercent = zombie.health / zombie.maxHealth;
            mesh.children[5].scale.x = healthPercent;
            mesh.children[5].material.color.setHex(
                healthPercent > 0.7 ? 0xff0000 :
                    healthPercent > 0.3 ? 0xff8800 : 0xff4444
            );
        }

        // Effet de d√©g√¢ts
        const timeSinceHit = Date.now() - (zombie.lastHit || 0);
        if (timeSinceHit < 200) {
            mesh.children.forEach(child => {
                if (child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xffffff);
                    child.material.emissiveIntensity = 0.3;
                }
            });
        } else {
            mesh.children.forEach(child => {
                if (child.material && child.material.emissive) {
                    child.material.emissive.setHex(0x000000);
                    child.material.emissiveIntensity = 0;
                }
            });
        }
    }

    // Mise √† jour des projectiles
    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            const mesh = bulletMeshes[i];
            if (!bullet || !mesh) continue;

            bullet.x += bullet.vx;
            bullet.z += bullet.vz;
            bullet.life--;

            mesh.position.set(bullet.x, bullet.y, bullet.z);

            if (bullet.life <= 0 || Math.abs(bullet.x) > CONFIG.ARENA_SIZE * 2) {
                removeBullet(i);
                continue;
            }

            // Collision avec zombies
            for (let j = 0; j < zombies.length; j++) {
                const zombie = zombies[j];
                if (!zombie.alive) continue;

                if (getDistance(bullet, zombie) < 1.5) {
                    zombie.health -= bullet.damage;
                    zombie.lastHit = Date.now(); // Pour effet visuel

                    // Effet d'impact
                    createImpactEffect(bullet.x, bullet.z);

                    const shooter = robots.find(r => r.id === bullet.owner);
                    if (shooter) {
                        shooter.accuracy = Math.min(0.95, shooter.accuracy + 0.01);
                        shooter.lastKill = Date.now();
                    }

                    addLog(`üí• ${shooter ? shooter.name : 'Robot'} touche ${zombie.type} zombie (${bullet.damage} dmg)`, 'combat');

                    if (zombie.health <= 0) {
                        zombie.alive = false;
                        stats.zombiesKilled++;
                        stats.totalScore += zombie.type === 'tank' ? 50 : zombie.type === 'fast' ? 30 : 20;

                        // Effet de mort
                        createDeathEffect(zombie.x, zombie.z, zombie.type);

                        if (shooter) {
                            shooter.killCount++;
                            shooter.experience += 1;
                            addLog(`üéØ ${shooter.name} √©limine un ${zombie.type} zombie ! (${shooter.killCount} kills)`, 'combat');
                        }

                        // Retirer le mesh du zombie
                        setTimeout(() => {
                            if (zombieMeshes[j]) {
                                scene.remove(zombieMeshes[j]);
                                zombieMeshes[j] = null;
                            }
                        }, 1000); // D√©lai pour voir l'effet de mort
                    }

                    removeBullet(i);
                    break;
                }
            }
        }
    }

    function removeBullet(index) {
        bullets.splice(index, 1);
        scene.remove(bulletMeshes[index]);
        bulletMeshes.splice(index, 1);
    }

    function createImpactEffect(x, z) {
        const impact = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 8, 8),
            new THREE.MeshBasicMaterial({
                color: 0xff8800,
                emissive: 0xff8800,
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.9
            })
        );
        impact.position.set(x, 1, z);
        scene.add(impact);

        // Animation d'expansion
        let scale = 0.1;
        const animate = () => {
            scale += 0.1;
            impact.scale.set(scale, scale, scale);
            impact.material.opacity -= 0.1;

            if (impact.material.opacity > 0) {
                requestAnimationFrame(animate);
            } else {
                scene.remove(impact);
            }
        };
        animate();
    }

    function createDeathEffect(x, z, zombieType) {
        const color = zombieType === 'tank' ? 0x888888 : zombieType === 'fast' ? 0xff4444 : 0x00aa00;

        // Explosion de particules
        for (let i = 0; i < 8; i++) {
            const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 6, 6),
                new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                })
            );

            const angle = (i / 8) * Math.PI * 2;
            const speed = 2 + Math.random() * 3;
            particle.position.set(x, 2, z);
            scene.add(particle);

            // Animation des particules
            let life = 60;
            const animateParticle = () => {
                particle.position.x += Math.cos(angle) * speed * 0.1;
                particle.position.z += Math.sin(angle) * speed * 0.1;
                particle.position.y += (Math.random() - 0.5) * 0.2;
                particle.material.opacity -= 0.02;
                life--;

                if (life > 0) {
                    requestAnimationFrame(animateParticle);
                } else {
                    scene.remove(particle);
                }
            };
            setTimeout(() => animateParticle(), i * 50);
        }
    }

    // Vision robot (mode B)
    function toggleRobotVision() {
        robotVisionMode = !robotVisionMode;
        const visionPanel = document.getElementById('robotVision');
        const crosshair = document.getElementById('robotCrosshair');

        if (robotVisionMode) {
            visionPanel.style.display = 'block';
            crosshair.style.display = 'block';
            updateRobotVision();
            addLog('üëÅÔ∏è Mode vision robot activ√©', 'system');
        } else {
            visionPanel.style.display = 'none';
            crosshair.style.display = 'none';
            camera.position.set(0, 80, 100);
            camera.lookAt(0, 0, 0);
            addLog('üëÅÔ∏è Mode vision d√©sactiv√©', 'system');
        }
    }

    function switchToRobot(direction) {
        const aliveRobots = robots.filter(r => r.alive);
        if (aliveRobots.length === 0) return;

        currentViewedRobot += direction;
        if (currentViewedRobot >= aliveRobots.length) currentViewedRobot = 0;
        if (currentViewedRobot < 0) currentViewedRobot = aliveRobots.length - 1;

        updateRobotVision();
    }

    function updateRobotVision() {
        if (!robotVisionMode) return;

        const aliveRobots = robots.filter(r => r.alive);
        if (aliveRobots.length === 0) return;

        const robot = aliveRobots[currentViewedRobot];
        camera.position.set(robot.x, 6, robot.z);

        if (robot.target) {
            camera.lookAt(robot.target.x, 2, robot.target.z);
        } else {
            camera.lookAt(robot.x, 2, robot.z + 10);
        }

        updateRobotVisionUI(robot);
    }

    function updateRobotVisionUI(robot) {
        const visionContent = document.getElementById('robotVisionContent');
        const nearbyZombies = zombies.filter(z => z.alive && getDistance(robot, z) < CONFIG.DETECTION_RANGE);

        visionContent.innerHTML = `
                <div><strong style="color: ${robot.type.color};">${robot.type.icon} ${robot.name}</strong></div>
                <div>‚ù§Ô∏è Sant√©: ${robot.health}/${robot.maxHealth}</div>
                <div>üéØ Pr√©cision: ${Math.round(robot.accuracy * 100)}%</div>
                <div>üíÄ Kills: ${robot.killCount}</div>
                <div>üß† Comportement: ${robot.behavior}</div>
                <div>üé™ R√¥le: ${robot.formationRole}</div>
                ${robot.target ?
            `<div>üéØ Cible: ${robot.target.type} zombie (${Math.round(getDistance(robot, robot.target))}m)</div>` :
            '<div>üîç Recherche de cible...</div>'
        }
                <div>üßü Zombies d√©tect√©s: ${nearbyZombies.length}</div>
                <div>üìä Exp√©rience: ${Math.round(robot.experience)}</div>
            `;
    }

    // Boucle de jeu principale
    function gameLoop() {
        if (gameState === 'active') {
            // Mise √† jour IA robots
            updateRobots();

            // Mise √† jour zombies
            updateZombies();

            // Mise √† jour projectiles
            updateBullets();

            // Gestion des vagues
            updateWaveSystem();

            // V√©rifier conditions de victoire/d√©faite
            checkGameConditions();
        }

        if (robotVisionMode) {
            updateRobotVision();
        }

        updateUI();
        renderer.render(scene, camera);
        requestAnimationFrame(gameLoop);
    }

    function updateWaveSystem() {
        const aliveZombies = zombies.filter(z => z.alive).length;

        if (aliveZombies === 0 && gameState === 'active') {
            waveTimer--;

            if (waveTimer <= 0) {
                currentWave++;
                stats.wavesCompleted++;
                waveTimer = CONFIG.WAVE_DELAY;
                spawnWave();
                addLog(`‚úÖ Vague ${currentWave - 1} termin√©e ! Pr√©paration vague ${currentWave}`, 'wave');
            }
        }
    }

    function checkGameConditions() {
        const aliveRobots = robots.filter(r => r.alive).length;

        if (aliveRobots === 0) {
            gameState = 'defeat';
            addLog('üíÄ D√âFAITE ! Tous les robots sont d√©truits !', 'wave');
            showGameOverScreen(false);
        } else if (currentWave > 20) {
            gameState = 'victory';
            addLog('üèÜ VICTOIRE ! Toutes les vagues repouss√©es !', 'wave');
            showGameOverScreen(true);
        }
    }

    function showGameOverScreen(victory) {
        const div = document.createElement('div');
        div.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(20px);
                border: 3px solid ${victory ? '#00ff41' : '#ff4444'}; border-radius: 20px;
                padding: 40px; color: white; text-align: center; z-index: 400;
                font-family: 'Orbitron', monospace;
            `;

        const bestRobot = robots.reduce((best, robot) => robot.killCount > best.killCount ? robot : best, robots[0]);

        div.innerHTML = `
                <h1 style="color: ${victory ? '#00ff41' : '#ff4444'}; margin-bottom: 20px;">
                    ${victory ? 'üèÜ VICTOIRE !' : 'üíÄ D√âFAITE !'}
                </h1>
                <p>Vagues Termin√©es: ${stats.wavesCompleted}</p>
                <p>Zombies √âlimin√©s: ${stats.zombiesKilled}</p>
                <p>Score Total: ${stats.totalScore}</p>
                <p>Meilleur Robot: ${bestRobot.type.icon} ${bestRobot.name} (${bestRobot.killCount} kills)</p>
                <p style="margin-top: 20px; opacity: 0.8;">Red√©marrage automatique dans 5s...</p>
            `;

        document.body.appendChild(div);

        setTimeout(() => {
            document.body.removeChild(div);
            resetGame();
        }, 5000);
    }

    function updateUI() {
        const aliveRobots = robots.filter(r => r.alive).length;
        const aliveZombies = zombies.filter(z => z.alive).length;

        document.getElementById('aliveRobots').textContent = aliveRobots;
        document.getElementById('zombiesKilled').textContent = stats.zombiesKilled;
        document.getElementById('totalScore').textContent = stats.totalScore;
        document.getElementById('currentWave').textContent = currentWave;
        document.getElementById('zombiesLeft').textContent = aliveZombies;
        document.getElementById('nextWaveTimer').textContent = aliveZombies === 0 ? `${Math.ceil(waveTimer / 60)}s` : 'Combat';
        document.getElementById('difficulty').textContent = currentWave < 5 ? 'Facile' : currentWave < 10 ? 'Moyen' : currentWave < 15 ? 'Difficile' : 'Extr√™me';

        updateAIStatus();
    }

    function updateAIStatus() {
        const aiContent = document.getElementById('aiStatusContent');
        aiContent.innerHTML = '';

        robots.filter(r => r.alive).slice(0, 8).forEach(robot => {
            const healthPercent = Math.round((robot.health / robot.maxHealth) * 100);
            const accuracyPercent = Math.round(robot.accuracy * 100);

            const robotDiv = document.createElement('div');
            robotDiv.className = 'robot-ai';
            robotDiv.innerHTML = `
                    <strong style="color: ${robot.type.color};">${robot.type.icon} ${robot.name}</strong><br>
                    ‚ù§Ô∏è${healthPercent}% üéØ${accuracyPercent}% üíÄ${robot.killCount} üß†${robot.behavior}
                `;
            aiContent.appendChild(robotDiv);
        });
    }

    function startGame() {
        gameState = 'active';
        document.getElementById('timer').style.display = 'block';
        document.getElementById('startBtn').disabled = true;
        spawnWave();
        addLog('üö® D√âBUT DE LA D√âFENSE ! Premi√®re vague d√©tect√©e !', 'wave');
    }

    function resetGame() {
        gameState = 'idle';
        currentWave = 1;
        document.getElementById('timer').style.display = 'none';
        document.getElementById('startBtn').disabled = false;
        initGame();
        addLog('üîÑ Syst√®me r√©initialis√© - Pr√™t pour nouvelle d√©fense', 'system');
    }

    // Contr√¥les
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('resetBtn').addEventListener('click', resetGame);

    // Initialisation
    initThreeJS();
    initGame();
    gameLoop();

    addLog('ü§ñ Syst√®me de d√©fense robotique en ligne', 'system');
    addLog('üß† IA adaptative calibr√©e - Apprentissage automatique activ√©', 'ai');
    addLog('‚ö° Appuyez sur D√âMARRER pour commencer la d√©fense', 'system');
</script>
</body>
</html>