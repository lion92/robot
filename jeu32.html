<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Warriors - Ultimate Fighter Jet Battle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            background: #000;
            color: white;
            user-select: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Enhanced HUD Styling */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: none;
            pointer-events: none;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .hud-info {
            background: linear-gradient(135deg, rgba(0,20,40,0.9), rgba(0,40,80,0.7));
            padding: 12px 20px;
            border-radius: 15px;
            display: inline-block;
            margin: 5px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0,255,255,0.3);
            box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 10px rgba(0,255,255,0.2);
            animation: hudGlow 2s ease-in-out infinite;
        }

        @keyframes hudGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 10px rgba(0,255,255,0.2); }
            50% { box-shadow: 0 0 30px rgba(0,255,255,0.5), inset 0 0 15px rgba(0,255,255,0.3); }
        }

        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
            letter-spacing: 2px;
        }

        #aliveCount {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            text-transform: uppercase;
        }

        /* Enhanced Player HUD */
        #playerHUD {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0,40,0,0.9), rgba(0,80,0,0.7));
            padding: 20px;
            border-radius: 20px;
            border: 2px solid #00ff00;
            backdrop-filter: blur(10px);
            display: none;
            min-width: 350px;
            box-shadow: 0 0 30px rgba(0,255,0,0.4), inset 0 0 20px rgba(0,255,0,0.2);
        }

        .health-bar-container, .shield-bar-container, .boost-bar-container {
            width: 100%;
            height: 25px;
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            margin: 8px 0;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .bar-label {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            font-size: 12px;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #playerHealthBar, #playerShieldBar, #playerBoostBar {
            height: 100%;
            border-radius: 12px;
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }

        #playerHealthBar {
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            width: 100%;
        }

        #playerShieldBar {
            background: linear-gradient(90deg, #003366, #0099ff, #00ffff);
            width: 100%;
        }

        #playerBoostBar {
            background: linear-gradient(90deg, #ff6600, #ffaa00, #ffff00);
            width: 100%;
        }

        #playerScore {
            font-size: 28px;
            font-weight: 900;
            color: #00ff00;
            margin: 15px 0;
            text-shadow: 0 0 10px rgba(0,255,0,0.8);
        }

        .weapon-display {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        #playerWeapon {
            color: #ffff00;
            font-weight: 700;
            font-size: 18px;
            margin-left: 10px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,255,0,0.8);
        }

        #specialReady {
            color: #ff6600;
            font-weight: 700;
            font-size: 16px;
            text-transform: uppercase;
        }

        #specialReady.special-ready {
            color: #00ff00;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor;
            }
            50% {
                opacity: 0.5;
                text-shadow: 0 0 20px currentColor;
            }
        }

        /* Enhanced Controls Display */
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0,0,40,0.9), rgba(0,0,80,0.7));
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            line-height: 2;
            border: 2px solid rgba(0,255,255,0.3);
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }

        .control-key {
            color: #00ffff;
            font-weight: 700;
            background: rgba(0,255,255,0.2);
            padding: 2px 8px;
            border-radius: 5px;
            display: inline-block;
        }

        /* Enhanced Loading Screen */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            width: 100%;
        }

        #loading h2 {
            font-size: 48px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #00ff00, #00ffff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: loadingGradient 3s ease-in-out infinite;
        }

        @keyframes loadingGradient {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }

        .loading-bar-container {
            width: 400px;
            max-width: 80%;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            margin: 0 auto;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff, #0099ff);
            border-radius: 15px;
            width: 0%;
            animation: loadingProgress 3s ease-out forwards;
        }

        @keyframes loadingProgress {
            to { width: 100%; }
        }

        .loading-tips {
            margin-top: 40px;
            font-size: 16px;
            color: rgba(255,255,255,0.8);
            animation: fadeInOut 3s ease-in-out infinite;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Enhanced Main Menu */
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: linear-gradient(135deg, rgba(0,0,40,0.95), rgba(0,0,80,0.85));
            padding: 50px;
            border-radius: 30px;
            backdrop-filter: blur(20px);
            border: 3px solid rgba(0,255,255,0.5);
            display: none;
            z-index: 500;
            box-shadow: 0 0 50px rgba(0,255,255,0.4), inset 0 0 30px rgba(0,255,255,0.2);
        }

        #mainMenu h1 {
            font-size: 64px;
            margin-bottom: 20px;
            font-weight: 900;
            background: linear-gradient(45deg, #00ff00, #00ffff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0,255,255,0.5);
            letter-spacing: 4px;
        }

        .menu-subtitle {
            font-size: 18px;
            color: rgba(255,255,255,0.8);
            margin-bottom: 40px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-button {
            display: block;
            width: 300px;
            margin: 20px auto;
            padding: 18px 35px;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(45deg, #0066cc, #00ccff);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0,102,204,0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .menu-button:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }

        .menu-button:hover:before {
            left: 100%;
        }

        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,102,204,0.6);
            background: linear-gradient(45deg, #0088ff, #00eeff);
        }

        .menu-button:active {
            transform: translateY(-1px);
        }

        /* Game Modes Description */
        .game-mode-info {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            display: none;
        }

        .game-mode-info h3 {
            color: #00ffff;
            margin-bottom: 10px;
        }

        /* Enhanced Winner Overlay */
        #winnerOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.8), rgba(0,0,0,0.95));
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 600;
            backdrop-filter: blur(10px);
        }

        #winnerBox {
            background: linear-gradient(135deg, rgba(0,0,40,0.95), rgba(0,0,80,0.85));
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            border: 3px solid #00ff00;
            box-shadow: 0 0 50px rgba(0,255,0,0.5), inset 0 0 30px rgba(0,255,0,0.2);
            animation: winnerPulse 2s ease-in-out infinite;
        }

        @keyframes winnerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        #winnerName {
            font-size: 56px;
            font-weight: 900;
            margin-bottom: 30px;
            text-shadow: 0 0 30px currentColor;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        #winnerStats {
            font-size: 24px;
            margin-bottom: 40px;
            line-height: 1.8;
        }

        .stat-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Notification System */
        .notification {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.8));
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 22px;
            font-weight: 700;
            z-index: 200;
            transition: all 0.5s ease;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 0 30px rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Enhanced Radar */
        .radar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(0,255,0,0.05), rgba(0,255,0,0.1), rgba(0,0,0,0.8));
            border: 3px solid #00ff00;
            border-radius: 50%;
            display: none;
            box-shadow: 0 0 30px rgba(0,255,0,0.4), inset 0 0 20px rgba(0,255,0,0.2);
            overflow: hidden;
        }

        .radar::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 1px;
            background: rgba(0,255,0,0.3);
            transform: translate(-50%, -50%);
        }

        .radar::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1px;
            height: 100%;
            background: rgba(0,255,0,0.3);
            transform: translate(-50%, -50%);
        }

        .radar-sweep {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 125px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            transform-origin: left center;
            animation: radar-sweep 3s linear infinite;
            box-shadow: 0 0 20px #00ff00;
        }

        @keyframes radar-sweep {
            to { transform: rotate(360deg); }
        }

        .radar-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0,255,0,0.2);
            border-radius: 50%;
        }

        .radar-ring:nth-child(3) { width: 80px; height: 80px; }
        .radar-ring:nth-child(4) { width: 160px; height: 160px; }

        /* Combo Counter */
        .combo-counter {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 42px;
            font-weight: 900;
            color: #ff6600;
            text-shadow: 0 0 30px currentColor;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-transform: uppercase;
        }

        .combo-counter.active {
            opacity: 1;
            animation: comboShake 0.5s ease-out;
        }

        @keyframes comboShake {
            0%, 100% { transform: translateX(-50%) scale(1); }
            25% { transform: translateX(-48%) scale(1.1); }
            75% { transform: translateX(-52%) scale(1.1); }
        }

        /* Achievement Popup */
        .achievement-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(255,140,0,0.8));
            padding: 30px 50px;
            border-radius: 20px;
            border: 3px solid #ffd700;
            box-shadow: 0 0 50px rgba(255,215,0,0.8);
            z-index: 300;
            display: none;
            animation: achievementBounce 0.6s ease-out;
        }

        @keyframes achievementBounce {
            0% { transform: translate(-50%, -50%) scale(0); }
            60% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .achievement-popup h3 {
            font-size: 32px;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .achievement-popup p {
            font-size: 18px;
            color: #fff;
        }

        /* Weather Effects */
        .weather-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .rain {
            background: linear-gradient(transparent, rgba(255,255,255,0.1));
            animation: rain 0.5s linear infinite;
        }

        @keyframes rain {
            to { transform: translateY(100vh); }
        }

        /* Rank Display */
        .rank-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,140,0,0.1));
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid rgba(255,215,0,0.5);
            display: none;
        }

        .rank-icon {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin-right: 10px;
            vertical-align: middle;
        }

        .rank-name {
            font-size: 20px;
            font-weight: 700;
            color: #ffd700;
            vertical-align: middle;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            padding: 0 20px;
        }

        .joystick-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        .mobile-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
        }

        .mobile-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            margin: 10px;
            display: inline-block;
            text-align: center;
            line-height: 80px;
            font-size: 24px;
            font-weight: 700;
        }

        /* Settings Menu */
        .settings-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,40,0.95), rgba(0,0,80,0.85));
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            display: none;
            z-index: 700;
            min-width: 400px;
        }

        .settings-menu h2 {
            margin-bottom: 30px;
            color: #00ffff;
            text-align: center;
        }

        .setting-item {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setting-label {
            font-size: 16px;
        }

        .setting-control {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            color: white;
        }

        /* Performance Stats */
        .perf-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            color: #00ff00;
            display: none;
            border-radius: 5px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #playerHUD {
                bottom: 80px;
                transform: scale(0.8);
                transform-origin: bottom left;
            }

            #controls {
                display: none;
            }

            .mobile-controls {
                display: block;
            }

            .radar {
                transform: scale(0.7);
                transform-origin: top right;
            }
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="loading">
    <h2>INITIALIZING COMBAT SYSTEMS</h2>
    <div class="loading-bar-container">
        <div class="loading-bar"></div>
    </div>
    <div class="loading-tips">
        <p id="loadingTip">Calibrating weapon systems...</p>
    </div>
</div>

<div id="mainMenu">
    <h1>SKY WARRIORS</h1>
    <p class="menu-subtitle">Ultimate Fighter Jet Combat</p>
    <button id="btnPlayerMode" class="menu-button">Campaign Mode</button>
    <button id="btnMixedMode" class="menu-button">Team Battle</button>
    <button id="btnAIMode" class="menu-button">AI Tournament</button>
    <button id="btnSettings" class="menu-button">Settings</button>
    <button id="btnCredits" class="menu-button">Credits</button>
</div>

<div id="hud">
    <div id="timer" class="hud-info">10:00</div>
    <div id="aliveCount" class="hud-info">Ships Alive: 4</div>
    <div class="combo-counter" id="comboCounter">
        <span id="comboText">COMBO</span> x<span id="comboMultiplier">2</span>
    </div>
</div>

<div class="rank-display" id="rankDisplay">
    <span class="rank-icon">‚≠ê</span>
    <span class="rank-name" id="rankName">Rookie Pilot</span>
</div>

<div id="playerHUD">
    <div>CALLSIGN: <span id="playerCallsign">MAVERICK</span></div>
    <div class="health-bar-container">
        <span class="bar-label">HULL</span>
        <div id="playerHealthBar"></div>
    </div>
    <div class="shield-bar-container">
        <span class="bar-label">SHIELD</span>
        <div id="playerShieldBar"></div>
    </div>
    <div class="boost-bar-container">
        <span class="bar-label">BOOST</span>
        <div id="playerBoostBar"></div>
    </div>
    <div>Score: <span id="playerScore">0</span></div>
    <div class="weapon-display">
        <span>Weapon:</span>
        <span id="playerWeapon">PLASMA</span>
    </div>
    <div>Special: <span id="specialReady">READY</span></div>
</div>

<div id="controls">
    <div><span class="control-key">W/‚Üë</span> Pitch Up</div>
    <div><span class="control-key">S/‚Üì</span> Pitch Down</div>
    <div><span class="control-key">A/‚Üê</span> Roll Left</div>
    <div><span class="control-key">D/‚Üí</span> Roll Right</div>
    <div><span class="control-key">SPACE</span> Fire Weapons</div>
    <div><span class="control-key">Q</span> Switch Weapon</div>
    <div><span class="control-key">E</span> Special Attack</div>
    <div><span class="control-key">SHIFT</span> Afterburner</div>
    <div><span class="control-key">TAB</span> Target Lock</div>
</div>

<div class="radar" id="radar">
    <div class="radar-ring"></div>
    <div class="radar-ring"></div>
    <div class="radar-sweep"></div>
</div>

<div id="winnerOverlay">
    <div id="winnerBox">
        <div id="winnerName">WINNER</div>
        <div id="winnerStats">
            <div class="stat-item">
                <span>Final Score:</span>
                <span id="finalScore">0</span>
            </div>
            <div class="stat-item">
                <span>Eliminations:</span>
                <span id="finalKills">0</span>
            </div>
            <div class="stat-item">
                <span>Accuracy:</span>
                <span id="finalAccuracy">0%</span>
            </div>
            <div class="stat-item">
                <span>Max Combo:</span>
                <span id="finalCombo">0</span>
            </div>
            <div class="stat-item">
                <span>Rank Achieved:</span>
                <span id="finalRank">Rookie</span>
            </div>
        </div>
        <div id="restartText">
            Battle restarting in <span id="countdown">5</span> seconds...
        </div>
        <div id="menuButtons">
            <button id="btnRestart" class="menu-button">PLAY AGAIN</button>
            <button id="btnMenu" class="menu-button">MAIN MENU</button>
        </div>
    </div>
</div>

<div class="achievement-popup" id="achievementPopup">
    <h3>üèÜ ACHIEVEMENT UNLOCKED!</h3>
    <p id="achievementText"></p>
</div>

<div class="settings-menu" id="settingsMenu">
    <h2>SETTINGS</h2>
    <div class="setting-item">
        <span class="setting-label">Master Volume</span>
        <input type="range" class="setting-control" id="volumeSlider" min="0" max="100" value="50">
    </div>
    <div class="setting-item">
        <span class="setting-label">Graphics Quality</span>
        <select class="setting-control" id="graphicsQuality">
            <option value="low">Low</option>
            <option value="medium" selected>Medium</option>
            <option value="high">High</option>
            <option value="ultra">Ultra</option>
        </select>
    </div>
    <div class="setting-item">
        <span class="setting-label">Show FPS</span>
        <input type="checkbox" class="setting-control" id="showFPS">
    </div>
    <div class="setting-item">
        <span class="setting-label">Particle Effects</span>
        <input type="checkbox" class="setting-control" id="particleEffects" checked>
    </div>
    <button class="menu-button" onclick="closeSettings()">BACK</button>
</div>

<div class="weather-effect" id="weatherEffect"></div>

<div class="perf-stats" id="perfStats">
    FPS: <span id="fps">60</span><br>
    Draw Calls: <span id="drawCalls">0</span><br>
    Triangles: <span id="triangles">0</span>
</div>

<div class="mobile-controls" id="mobileControls">
    <div class="joystick-container">
        <div class="joystick" id="joystick"></div>
    </div>
    <div class="mobile-buttons">
        <div class="mobile-button" id="mobileFireBtn">üî•</div>
        <div class="mobile-button" id="mobileBoostBtn">‚ö°</div>
        <div class="mobile-button" id="mobileSpecialBtn">üí•</div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Sky Warriors - Enhanced Fighter Jet Battle Game
    // Version 2.0 - Complete Edition

    // Wait for Three.js to load
    window.addEventListener('load', function() {
        'use strict';

        // ========================================
        // CONFIGURATION
        // ========================================
        const CONFIG = {
            // Ship settings
            SHIPS: 4,
            SHIP_HP: 100,
            SHIELD_HP: 50,
            SHIP_SPEED: 8,
            BOOST_SPEED: 15,
            BOOST_MAX: 100,
            BOOST_DRAIN: 2,
            BOOST_RECHARGE: 1,

            // Weapon settings
            LASER_SPEED: 25,
            DAMAGE: 20,
            FIRE_RATE: 200,

            // Arena settings
            ARENA_SIZE: 500,
            MIN_HEIGHT: 20,
            MAX_HEIGHT: 300,

            // Game settings
            BATTLE_TIME: 600, // 10 minutes
            COMBO_WINDOW: 3000,
            WEATHER_CHANGE_TIME: 60000,

            // AI settings
            AI_DIFFICULTY: 'EXTREME',
            AI_REACTION_TIME: 50,
            AI_ACCURACY: 0.95,

            // Graphics settings
            PARTICLE_COUNT: 200,
            DEBRIS_COUNT: 50,
            SHADOW_QUALITY: 'medium',

            // Rank thresholds
            RANKS: [
                { name: 'Rookie Pilot', score: 0, icon: '‚≠ê' },
                { name: 'Flight Officer', score: 500, icon: '‚≠ê‚≠ê' },
                { name: 'Squadron Leader', score: 1500, icon: '‚≠ê‚≠ê‚≠ê' },
                { name: 'Wing Commander', score: 3000, icon: 'üéñÔ∏è' },
                { name: 'Ace Pilot', score: 5000, icon: 'üèÖ' },
                { name: 'Sky Marshal', score: 10000, icon: 'üèÜ' }
            ]
        };

        // ========================================
        // GLOBAL VARIABLES
        // ========================================
        let scene, camera, renderer, composer;
        let ships = [];
        let lasers = [];
        let missiles = [];
        let powerups = [];
        let gameState = 'menu';
        let gameMode = 'ai';
        let playerShip = null;
        let timer = CONFIG.BATTLE_TIME;
        let soundEnabled = true;
        let musicEnabled = false;
        let currentWeather = 'clear';
        let weatherTimer = 0;

        // Systems
        let comboSystem = null;
        let achievementSystem = null;
        let destructionSystem = null;
        let weatherSystem = null;
        let rankSystem = null;
        let audioSystem = null;
        let particlePool = null;
        let effectsManager = null;

        // Performance tracking
        let stats = {
            fps: 60,
            drawCalls: 0,
            triangles: 0,
            lastTime: performance.now(),
            frames: 0
        };

        // Loading tips
        const loadingTips = [
            "Calibrating weapon systems...",
            "Fueling fighter jets...",
            "Training AI pilots...",
            "Generating battle arena...",
            "Loading particle effects...",
            "Preparing for combat...",
            "Synchronizing radar systems...",
            "Establishing communication channels..."
        ];

        // ========================================
        // AUDIO SYSTEM
        // ========================================
        class AudioSystem {
            constructor() {
                this.context = null;
                this.sounds = {};
                this.masterVolume = 0.5;
                this.initialized = false;

                this.init();
            }

            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;

                    // Create sound effects
                    this.createSounds();

                    // Load stored volume
                    const storedVolume = localStorage.getItem('masterVolume');
                    if (storedVolume) {
                        this.masterVolume = parseFloat(storedVolume);
                        document.getElementById('volumeSlider').value = this.masterVolume * 100;
                    }
                } catch (e) {
                    console.log('Audio system not supported');
                    this.initialized = false;
                }
            }

            createSounds() {
                // Weapon sounds
                this.sounds.plasmaFire = this.createSynthSound(200, 0.1, 'square', 0.8);
                this.sounds.laserFire = this.createSynthSound(400, 0.05, 'sawtooth', 0.6);
                this.sounds.rocketFire = this.createSynthSound(100, 0.3, 'triangle', 1.0);

                // Impact sounds
                this.sounds.hit = this.createSynthSound(150, 0.1, 'triangle', 0.7);
                this.sounds.shieldHit = this.createSynthSound(300, 0.1, 'sine', 0.5);
                this.sounds.explosion = this.createNoiseExplosion();

                // System sounds
                this.sounds.powerup = this.createPowerupSound();
                this.sounds.warning = this.createWarningSound();
                this.sounds.boost = this.createBoostSound();
                this.sounds.combo = this.createComboSound();
                this.sounds.achievement = this.createAchievementSound();

                // UI sounds
                this.sounds.menuSelect = this.createSynthSound(600, 0.05, 'sine', 0.3);
                this.sounds.menuHover = this.createSynthSound(800, 0.03, 'sine', 0.2);
            }

            createSynthSound(frequency, duration, type, volume) {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.context.destination);

                    oscillator.frequency.value = frequency;
                    oscillator.type = type;

                    filter.type = 'lowpass';
                    filter.frequency.value = frequency * 2;

                    const effectiveVolume = volume * this.masterVolume;
                    gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + duration);
                };
            }

            createNoiseExplosion() {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    const bufferSize = this.context.sampleRate * 0.3;
                    const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                    const output = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                    }

                    const noise = this.context.createBufferSource();
                    const gainNode = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    noise.buffer = buffer;
                    noise.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.context.destination);

                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;

                    const effectiveVolume = 0.8 * this.masterVolume;
                    gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

                    noise.start();
                };
            }

            createPowerupSound() {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    const oscillator1 = this.context.createOscillator();
                    const oscillator2 = this.context.createOscillator();
                    const gainNode = this.context.createGain();

                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(this.context.destination);

                    oscillator1.type = 'sine';
                    oscillator2.type = 'sine';

                    const effectiveVolume = 0.4 * this.masterVolume;
                    gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);

                    oscillator1.frequency.setValueAtTime(400, this.context.currentTime);
                    oscillator1.frequency.exponentialRampToValueAtTime(800, this.context.currentTime + 0.5);

                    oscillator2.frequency.setValueAtTime(600, this.context.currentTime);
                    oscillator2.frequency.exponentialRampToValueAtTime(1200, this.context.currentTime + 0.5);

                    oscillator1.start(this.context.currentTime);
                    oscillator2.start(this.context.currentTime);
                    oscillator1.stop(this.context.currentTime + 0.5);
                    oscillator2.stop(this.context.currentTime + 0.5);
                };
            }

            createWarningSound() {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const oscillator = this.context.createOscillator();
                            const gainNode = this.context.createGain();

                            oscillator.connect(gainNode);
                            gainNode.connect(this.context.destination);

                            oscillator.type = 'square';
                            oscillator.frequency.value = 440;

                            const effectiveVolume = 0.5 * this.masterVolume;
                            gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);

                            oscillator.start(this.context.currentTime);
                            oscillator.stop(this.context.currentTime + 0.1);
                        }, i * 150);
                    }
                };
            }

            createBoostSound() {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    const filter = this.context.createBiquadFilter();

                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.context.destination);

                    oscillator.type = 'sawtooth';
                    oscillator.frequency.value = 100;

                    filter.type = 'lowpass';
                    filter.frequency.value = 500;
                    filter.Q.value = 10;

                    const effectiveVolume = 0.6 * this.masterVolume;
                    gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);

                    oscillator.start(this.context.currentTime);

                    // Store reference to stop later
                    this.currentBoostSound = { oscillator, gainNode };
                };
            }

            stopBoostSound() {
                if (this.currentBoostSound) {
                    this.currentBoostSound.gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
                    this.currentBoostSound.oscillator.stop(this.context.currentTime + 0.1);
                    this.currentBoostSound = null;
                }
            }

            createComboSound() {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

                    notes.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.context.createOscillator();
                            const gainNode = this.context.createGain();

                            oscillator.connect(gainNode);
                            gainNode.connect(this.context.destination);

                            oscillator.type = 'sine';
                            oscillator.frequency.value = freq;

                            const effectiveVolume = 0.3 * this.masterVolume;
                            gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);

                            oscillator.start(this.context.currentTime);
                            oscillator.stop(this.context.currentTime + 0.2);
                        }, index * 100);
                    });
                };
            }

            createAchievementSound() {
                return () => {
                    if (!this.initialized || this.masterVolume === 0) return;

                    const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

                    notes.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.context.createOscillator();
                            const gainNode = this.context.createGain();

                            oscillator.connect(gainNode);
                            gainNode.connect(this.context.destination);

                            oscillator.type = 'sine';
                            oscillator.frequency.value = freq;

                            const effectiveVolume = 0.4 * this.masterVolume;
                            gainNode.gain.setValueAtTime(effectiveVolume, this.context.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

                            oscillator.start(this.context.currentTime);
                            oscillator.stop(this.context.currentTime + 0.3);
                        }, index * 150);
                    });
                };
            }

            play(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }

            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
                localStorage.setItem('masterVolume', this.masterVolume.toString());
            }

            playEngineSound(ship) {
                if (!this.initialized || this.masterVolume === 0) return;

                // Create dynamic engine sound based on ship speed
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.context.destination);

                const speed = ship.velocity.length();
                const normalizedSpeed = speed / CONFIG.BOOST_SPEED;

                oscillator.type = 'sawtooth';
                oscillator.frequency.value = 50 + normalizedSpeed * 100;

                filter.type = 'lowpass';
                filter.frequency.value = 200 + normalizedSpeed * 800;

                const effectiveVolume = (0.2 + normalizedSpeed * 0.3) * this.masterVolume;
                gainNode.gain.value = effectiveVolume;

                oscillator.start();

                // Store reference for cleanup
                if (!ship.engineSound) {
                    ship.engineSound = { oscillator, gainNode, filter };
                }
            }

            updateEngineSound(ship) {
                if (!ship.engineSound || !this.initialized) return;

                const speed = ship.velocity.length();
                const normalizedSpeed = speed / CONFIG.BOOST_SPEED;

                ship.engineSound.oscillator.frequency.value = 50 + normalizedSpeed * 100;
                ship.engineSound.filter.frequency.value = 200 + normalizedSpeed * 800;

                const effectiveVolume = (0.2 + normalizedSpeed * 0.3) * this.masterVolume;
                ship.engineSound.gainNode.gain.value = effectiveVolume;
            }

            stopEngineSound(ship) {
                if (ship.engineSound) {
                    ship.engineSound.gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
                    ship.engineSound.oscillator.stop(this.context.currentTime + 0.1);
                    ship.engineSound = null;
                }
            }
        }

        // ========================================
        // COMBO SYSTEM
        // ========================================
        class ComboSystem {
            constructor() {
                this.combo = 0;
                this.multiplier = 1;
                this.lastHitTime = 0;
                this.maxCombo = 0;
                this.totalHits = 0;
                this.comboMeter = 0;
                this.comboDecayRate = 0.02;
            }

            addHit(damageDealt = 20) {
                const now = Date.now();

                if (now - this.lastHitTime < CONFIG.COMBO_WINDOW) {
                    this.combo++;
                    this.comboMeter = Math.min(100, this.comboMeter + 20);
                } else {
                    this.combo = 1;
                    this.comboMeter = 20;
                }

                this.lastHitTime = now;
                this.totalHits++;

                // Calculate multiplier with better scaling
                this.multiplier = 1 + Math.floor(this.combo / 3) * 0.5 + (this.combo / 10) * 0.2;
                this.multiplier = Math.min(this.multiplier, 5); // Cap at 5x

                // Track max combo
                if (this.combo > this.maxCombo) {
                    this.maxCombo = this.combo;
                }

                // Trigger effects
                this.updateDisplay();
                this.triggerComboEffects();

                // Achievement checks
                if (this.combo === 10) {
                    achievementSystem.unlock('comboMaster');
                } else if (this.combo === 25) {
                    achievementSystem.unlock('comboLegend');
                }

                return this.multiplier;
            }

            update() {
                // Decay combo meter over time
                if (this.comboMeter > 0) {
                    this.comboMeter = Math.max(0, this.comboMeter - this.comboDecayRate);

                    if (this.comboMeter === 0 && this.combo > 0) {
                        this.reset();
                    }
                }
            }

            reset() {
                this.combo = 0;
                this.multiplier = 1;
                this.comboMeter = 0;
                this.updateDisplay();
            }

            updateDisplay() {
                const counter = document.getElementById('comboCounter');
                const multiplierSpan = document.getElementById('comboMultiplier');
                const comboText = document.getElementById('comboText');

                if (this.combo > 1) {
                    counter.classList.add('active');
                    multiplierSpan.textContent = this.multiplier.toFixed(1);

                    // Change combo text based on level
                    if (this.combo >= 50) {
                        comboText.textContent = 'GODLIKE';
                        counter.style.color = '#ff00ff';
                    } else if (this.combo >= 25) {
                        comboText.textContent = 'LEGENDARY';
                        counter.style.color = '#ffd700';
                    } else if (this.combo >= 15) {
                        comboText.textContent = 'UNSTOPPABLE';
                        counter.style.color = '#ff6600';
                    } else if (this.combo >= 10) {
                        comboText.textContent = 'RAMPAGE';
                        counter.style.color = '#ff0000';
                    } else if (this.combo >= 5) {
                        comboText.textContent = 'KILLING SPREE';
                        counter.style.color = '#ffaa00';
                    } else {
                        comboText.textContent = 'COMBO';
                        counter.style.color = '#ff6600';
                    }
                } else {
                    counter.classList.remove('active');
                }
            }

            triggerComboEffects() {
                // Sound effects
                if (this.combo % 5 === 0) {
                    audioSystem.play('combo');
                }

                // Visual notifications
                if (this.combo === 5) {
                    showNotification('KILLING SPREE!', '#ffaa00');
                } else if (this.combo === 10) {
                    showNotification('RAMPAGE!', '#ff0000');
                } else if (this.combo === 15) {
                    showNotification('UNSTOPPABLE!', '#ff6600');
                } else if (this.combo === 25) {
                    showNotification('LEGENDARY!', '#ffd700');
                } else if (this.combo === 50) {
                    showNotification('GODLIKE!!!', '#ff00ff');
                }
            }

            getScoreMultiplier() {
                return this.multiplier;
            }

            getComboGrade() {
                if (this.maxCombo >= 50) return 'S+';
                if (this.maxCombo >= 25) return 'S';
                if (this.maxCombo >= 15) return 'A';
                if (this.maxCombo >= 10) return 'B';
                if (this.maxCombo >= 5) return 'C';
                return 'D';
            }
        }

        // ========================================
        // ACHIEVEMENT SYSTEM
        // ========================================
        class AchievementSystem {
            constructor() {
                this.achievements = {
                    // Combat achievements
                    firstBlood: {
                        name: "First Blood",
                        desc: "Get the first elimination",
                        unlocked: false,
                        icon: "ü©∏"
                    },
                    aceFlyer: {
                        name: "Ace Flyer",
                        desc: "Eliminate 5 enemies in one battle",
                        unlocked: false,
                        icon: "‚úàÔ∏è"
                    },
                    survivor: {
                        name: "Survivor",
                        desc: "Win with full health",
                        unlocked: false,
                        icon: "üõ°Ô∏è"
                    },
                    speedDemon: {
                        name: "Speed Demon",
                        desc: "Win a battle in under 2 minutes",
                        unlocked: false,
                        icon: "‚ö°"
                    },
                    sharpshooter: {
                        name: "Sharpshooter",
                        desc: "Achieve 80% accuracy",
                        unlocked: false,
                        icon: "üéØ"
                    },
                    comboMaster: {
                        name: "Combo Master",
                        desc: "Get a 10x combo",
                        unlocked: false,
                        icon: "üî•"
                    },
                    comboLegend: {
                        name: "Combo Legend",
                        desc: "Get a 25x combo",
                        unlocked: false,
                        icon: "üí•"
                    },
                    untouchable: {
                        name: "Untouchable",
                        desc: "Win without taking damage",
                        unlocked: false,
                        icon: "üëª"
                    },
                    weaponMaster: {
                        name: "Weapon Master",
                        desc: "Use all weapons effectively",
                        unlocked: false,
                        icon: "üî´"
                    },

                    // Special achievements
                    nuclearWarfare: {
                        name: "Nuclear Warfare",
                        desc: "Eliminate 3 enemies with one nuke",
                        unlocked: false,
                        icon: "‚ò¢Ô∏è"
                    },
                    closeCall: {
                        name: "Close Call",
                        desc: "Win with less than 10 HP",
                        unlocked: false,
                        icon: "üò∞"
                    },
                    powerCollector: {
                        name: "Power Collector",
                        desc: "Collect 10 power-ups in one battle",
                        unlocked: false,
                        icon: "‚≠ê"
                    },
                    teamPlayer: {
                        name: "Team Player",
                        desc: "Win a team battle without losing allies",
                        unlocked: false,
                        icon: "ü§ù"
                    },

                    // Rank achievements
                    veteran: {
                        name: "Veteran",
                        desc: "Reach Wing Commander rank",
                        unlocked: false,
                        icon: "üéñÔ∏è"
                    },
                    legend: {
                        name: "Legend",
                        desc: "Reach Sky Marshal rank",
                        unlocked: false,
                        icon: "üèÜ"
                    },

                    // Hidden achievements
                    pacifist: {
                        name: "Pacifist",
                        desc: "Win without firing a shot",
                        unlocked: false,
                        icon: "‚òÆÔ∏è",
                        hidden: true
                    },
                    davidVsGoliath: {
                        name: "David vs Goliath",
                        desc: "Defeat an enemy with 10x your score",
                        unlocked: false,
                        icon: "üóø",
                        hidden: true
                    }
                };

                this.stats = {
                    totalKills: 0,
                    totalDeaths: 0,
                    totalShots: 0,
                    totalHits: 0,
                    totalDamageDealt: 0,
                    totalDamageTaken: 0,
                    battlesWon: 0,
                    battlesLost: 0,
                    powerupsCollected: 0,
                    playtime: 0,
                    favoriteWeapon: 'plasma',
                    weaponStats: {
                        plasma: { shots: 0, hits: 0, kills: 0 },
                        laser: { shots: 0, hits: 0, kills: 0 },
                        rocket: { shots: 0, hits: 0, kills: 0 }
                    }
                };

                this.loadProgress();
            }

            loadProgress() {
                const saved = localStorage.getItem('skyWarriorsAchievements');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.assign(this.achievements, data.achievements || {});
                    Object.assign(this.stats, data.stats || {});
                }
            }

            saveProgress() {
                const data = {
                    achievements: this.achievements,
                    stats: this.stats
                };
                localStorage.setItem('skyWarriorsAchievements', JSON.stringify(data));
            }

            checkAchievement(type, value) {
                switch(type) {
                    case 'kill':
                        if (this.stats.totalKills === 1 && !this.achievements.firstBlood.unlocked) {
                            this.unlock('firstBlood');
                        }
                        if (value >= 5 && !this.achievements.aceFlyer.unlocked) {
                            this.unlock('aceFlyer');
                        }
                        break;

                    case 'accuracy':
                        if (value >= 0.8 && !this.achievements.sharpshooter.unlocked) {
                            this.unlock('sharpshooter');
                        }
                        break;

                    case 'powerup':
                        if (this.stats.powerupsCollected >= 10 && !this.achievements.powerCollector.unlocked) {
                            this.unlock('powerCollector');
                        }
                        break;

                    case 'rank':
                        if (value >= 3000 && !this.achievements.veteran.unlocked) {
                            this.unlock('veteran');
                        }
                        if (value >= 10000 && !this.achievements.legend.unlocked) {
                            this.unlock('legend');
                        }
                        break;
                }
            }

            unlock(achievementKey) {
                const achievement = this.achievements[achievementKey];
                if (!achievement.unlocked) {
                    achievement.unlocked = true;
                    achievement.unlockedAt = Date.now();
                    this.showAchievementPopup(achievement);
                    audioSystem.play('achievement');
                    this.saveProgress();

                    // Bonus score for unlocking
                    if (playerShip) {
                        playerShip.score += 250;
                    }
                }
            }

            showAchievementPopup(achievement) {
                const popup = document.getElementById('achievementPopup');
                const text = document.getElementById('achievementText');

                text.innerHTML = `${achievement.icon} ${achievement.name}<br><small>${achievement.desc}</small>`;
                popup.style.display = 'block';

                setTimeout(() => {
                    popup.style.display = 'none';
                }, 3000);
            }

                updateWeaponStats(weapon, hit, kill) {
            if (this.stats.weaponStats[weapon]) {
            this.stats.weaponStats[weapon].shots++;
            if (hit) this.stats.weaponStats[weapon].hits++;
            if (kill) this.stats.weaponStats[weapon].kills++;
        }

        // Determine favorite weapon
        let maxKills = 0;
        let favorite = 'plasma';
        for (let w in this.stats.weaponStats) {
            if (this.stats.weaponStats[w].kills > maxKills) {
                maxKills = this.stats.weaponStats[w].kills;
                favorite = w;
            }
        }
        this.stats.favoriteWeapon = favorite;
    }

        getCompletionPercentage() {
            const total = Object.keys(this.achievements).filter(a => !this.achievements[a].hidden).length;
            const unlocked = Object.keys(this.achievements).filter(a => this.achievements[a].unlocked && !this.achievements[a].hidden).length;
            return Math.floor((unlocked / total) * 100);
        }

        getStatsSummary() {
            const kd = this.stats.totalDeaths > 0 ? (this.stats.totalKills / this.stats.totalDeaths).toFixed(2) : this.stats.totalKills;
            const accuracy = this.stats.totalShots > 0 ? ((this.stats.totalHits / this.stats.totalShots) * 100).toFixed(1) : 0;
            const winRate = this.stats.battlesWon + this.stats.battlesLost > 0 ?
                ((this.stats.battlesWon / (this.stats.battlesWon + this.stats.battlesLost)) * 100).toFixed(1) : 0;

            return {
                kills: this.stats.totalKills,
                deaths: this.stats.totalDeaths,
                kd: kd,
                accuracy: accuracy + '%',
                winRate: winRate + '%',
                playtime: this.formatPlaytime(this.stats.playtime),
                favoriteWeapon: this.stats.favoriteWeapon.toUpperCase(),
                completion: this.getCompletionPercentage() + '%'
            };
        }

        formatPlaytime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }
    }

        // ========================================
        // RANK SYSTEM
        // ========================================
        class RankSystem {
            constructor() {
                this.currentRank = 0;
                this.totalScore = 0;
                this.rankProgress = 0;

                this.loadRank();
            }

            loadRank() {
                const saved = localStorage.getItem('skyWarriorsRank');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.totalScore = data.totalScore || 0;
                    this.updateRank();
                }
            }

            saveRank() {
                localStorage.setItem('skyWarriorsRank', JSON.stringify({
                    totalScore: this.totalScore
                }));
            }

            addScore(score) {
                this.totalScore += score;
                this.updateRank();
                this.saveRank();
            }

            updateRank() {
                let newRank = 0;
                for (let i = CONFIG.RANKS.length - 1; i >= 0; i--) {
                    if (this.totalScore >= CONFIG.RANKS[i].score) {
                        newRank = i;
                        break;
                    }
                }

                if (newRank > this.currentRank) {
                    this.currentRank = newRank;
                    this.onRankUp();
                }

                // Calculate progress to next rank
                if (this.currentRank < CONFIG.RANKS.length - 1) {
                    const currentRankScore = CONFIG.RANKS[this.currentRank].score;
                    const nextRankScore = CONFIG.RANKS[this.currentRank + 1].score;
                    this.rankProgress = ((this.totalScore - currentRankScore) / (nextRankScore - currentRankScore)) * 100;
                } else {
                    this.rankProgress = 100;
                }

                this.updateDisplay();
            }

            onRankUp() {
                const rank = CONFIG.RANKS[this.currentRank];
                showNotification(`RANK UP! ${rank.icon} ${rank.name}`, '#ffd700');
                audioSystem.play('achievement');

                // Check rank achievements
                achievementSystem.checkAchievement('rank', this.totalScore);
            }

            updateDisplay() {
                const rankDisplay = document.getElementById('rankDisplay');
                const rankName = document.getElementById('rankName');

                if (rankDisplay && rankName) {
                    const rank = CONFIG.RANKS[this.currentRank];
                    rankName.textContent = rank.name;
                    rankDisplay.style.display = 'block';
                }
            }

            getCurrentRank() {
                return CONFIG.RANKS[this.currentRank];
            }

            getNextRank() {
                if (this.currentRank < CONFIG.RANKS.length - 1) {
                    return CONFIG.RANKS[this.currentRank + 1];
                }
                return null;
            }
        }

        // ========================================
        // WEATHER SYSTEM
        // ========================================
        class WeatherSystem {
            constructor() {
                this.types = ['clear', 'fog', 'storm', 'night', 'sunset'];
                this.current = 'clear';
                this.intensity = 0;
                this.transitionProgress = 0;
                this.targetWeather = 'clear';
                this.effects = {
                    fog: null,
                    lightning: null,
                    rain: [],
                    stars: null
                };

                this.initialized = false;
            }

            initEffects() {
                if (!scene || this.initialized) return;

                this.initialized = true;

                // Prepare weather particles
                for (let i = 0; i < 100; i++) {
                    const rainGeometry = new THREE.BoxGeometry(0.1, 5, 0.1);
                    const rainMaterial = new THREE.MeshBasicMaterial({
                        color: 0xaaaaff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const raindrop = new THREE.Mesh(rainGeometry, rainMaterial);
                    raindrop.visible = false;
                    scene.add(raindrop);
                    this.effects.rain.push(raindrop);
                }

                // Star field for night
                const starsGeometry = new THREE.BufferGeometry();
                const starPositions = [];
                for (let i = 0; i < 1000; i++) {
                    starPositions.push(
                        (Math.random() - 0.5) * 3000,
                        Math.random() * 1000 + 500,
                        (Math.random() - 0.5) * 3000
                    );
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2,
                    transparent: true,
                    opacity: 0
                });
                this.effects.stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(this.effects.stars);
            }

            update() {
                if (!this.initialized && scene) {
                    this.initEffects();
                }

                // Smooth weather transition
                if (this.transitionProgress < 1) {
                    this.transitionProgress += 0.01;
                    this.applyWeatherEffects();
                }

                // Update weather-specific effects
                switch (this.current) {
                    case 'storm':
                        this.updateStorm();
                        break;
                    case 'fog':
                        this.updateFog();
                        break;
                    case 'night':
                        this.updateNight();
                        break;
                }
            }

            changeWeather(newWeather) {
                if (newWeather === this.current) return;

                this.targetWeather = newWeather;
                this.transitionProgress = 0;
                this.current = newWeather;

                showNotification(`Weather: ${newWeather.toUpperCase()}`, '#87CEEB');
                this.applyWeatherEffects();
            }

            applyWeatherEffects() {
                if (!scene) return;

                const t = this.transitionProgress;

                switch(this.current) {
                    case 'clear':
                        scene.fog = new THREE.Fog(0xB0E0E6, 100, 2000);
                        if (scene.children.find(child => child.name === 'ambientLight')) {
                            scene.children.find(child => child.name === 'ambientLight').intensity = 0.6;
                        }
                        this.hideRain();
                        if (this.effects.stars) this.effects.stars.material.opacity = 0;
                        break;

                    case 'fog':
                        scene.fog = new THREE.Fog(0xcccccc, 50 * t, 400 + 400 * (1 - t));
                        this.hideRain();
                        break;

                    case 'storm':
                        scene.fog = new THREE.Fog(0x444444, 50, 600);
                        if (scene.children.find(child => child.name === 'ambientLight')) {
                            scene.children.find(child => child.name === 'ambientLight').intensity = 0.3;
                        }
                        this.showRain();
                        break;

                    case 'night':
                        scene.fog = new THREE.Fog(0x000033, 200, 1500);
                        if (scene.children.find(child => child.name === 'ambientLight')) {
                            scene.children.find(child => child.name === 'ambientLight').intensity = 0.2;
                        }
                        if (this.effects.stars) this.effects.stars.material.opacity = t * 0.8;
                        this.hideRain();
                        break;

                    case 'sunset':
                        scene.fog = new THREE.Fog(0xff6633, 300, 2500);
                        if (scene.children.find(child => child.name === 'ambientLight')) {
                            scene.children.find(child => child.name === 'ambientLight').color = new THREE.Color(0xffaa66);
                            scene.children.find(child => child.name === 'ambientLight').intensity = 0.5;
                        }
                        this.hideRain();
                        break;
                }
            }

            updateStorm() {
                // Animate rain
                this.effects.rain.forEach((raindrop, index) => {
                    if (raindrop.visible) {
                        raindrop.position.y -= 10;
                        if (raindrop.position.y < 0) {
                            raindrop.position.set(
                                (Math.random() - 0.5) * 1000,
                                500 + Math.random() * 200,
                                (Math.random() - 0.5) * 1000
                            );
                        }
                    }
                });

                // Random lightning
                if (Math.random() < 0.01) {
                    this.createLightning();
                }
            }

            updateFog() {
                // Animate fog density
                const time = Date.now() * 0.001;
                const density = 0.003 + Math.sin(time * 0.2) * 0.001;
                if (scene.fog instanceof THREE.FogExp2) {
                    scene.fog.density = density;
                }
            }

            updateNight() {
                // Twinkle stars
                if (this.effects.stars && this.effects.stars.material.opacity > 0) {
                    const time = Date.now() * 0.001;
                    const positions = this.effects.stars.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + i) * 0.1;
                    }
                    this.effects.stars.geometry.attributes.position.needsUpdate = true;
                }
            }

            showRain() {
                this.effects.rain.forEach((raindrop, index) => {
                    raindrop.visible = true;
                    raindrop.position.set(
                        (Math.random() - 0.5) * 1000,
                        300 + Math.random() * 300,
                        (Math.random() - 0.5) * 1000
                    );
                });
            }

            hideRain() {
                this.effects.rain.forEach(raindrop => {
                    raindrop.visible = false;
                });
            }

            createLightning() {
                if (!scene) return;

                const lightning = new THREE.PointLight(0xffffff, 10, 1000);
                lightning.position.set(
                    (Math.random() - 0.5) * 1000,
                    300 + Math.random() * 200,
                    (Math.random() - 0.5) * 1000
                );
                scene.add(lightning);

                // Flash effect
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'white';
                flash.style.opacity = '0.3';
                flash.style.pointerEvents = 'none';
                flash.style.zIndex = '60';
                document.body.appendChild(flash);

                setTimeout(() => {
                    scene.remove(lightning);
                    flash.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(flash);
                    }, 100);
                }, 100);

                // Thunder sound with delay
                setTimeout(() => {
                    audioSystem.play('explosion');
                }, 300 + Math.random() * 700);
            }

            getWeatherModifiers() {
                const modifiers = {
                    visibility: 1,
                    speed: 1,
                    accuracy: 1
                };

                switch(this.current) {
                    case 'fog':
                        modifiers.visibility = 0.5;
                        modifiers.accuracy = 0.8;
                        break;

                    case 'storm':
                        modifiers.speed = 0.9;
                        modifiers.accuracy = 0.7;
                        break;

                    case 'night':
                        modifiers.visibility = 0.7;
                        modifiers.accuracy = 0.9;
                        break;
                }

                return modifiers;
            }
        }

        // ========================================
        // DESTRUCTION SYSTEM
        // ========================================
        class DestructionSystem {
            constructor() {
                this.debris = [];
                this.explosions = [];
                this.particles = [];
                this.maxDebris = CONFIG.DEBRIS_COUNT;
                this.maxParticles = CONFIG.PARTICLE_COUNT;

                // Pre-create particle pool for performance
                this.particlePool = [];
                this.initialized = false;
            }

            initParticlePool() {
                if (!scene || this.initialized) return;

                this.initialized = true;

                for (let i = 0; i < this.maxParticles; i++) {
                    const geometry = new THREE.SphereGeometry(2, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xff6600,
                        transparent: true,
                        opacity: 1,
                        blending: THREE.AdditiveBlending
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.visible = false;
                    scene.add(particle);
                    this.particlePool.push({
                        mesh: particle,
                        velocity: new THREE.Vector3(),
                        life: 0,
                        active: false
                    });
                }
            }

            createExplosion(position, size, color, owner) {
                if (!scene) return;

                // Initialize particle pool if needed
                if (!this.initialized) {
                    this.initParticlePool();
                }

                // Main explosion flash
                const flashGeometry = new THREE.SphereGeometry(size * 0.8, 16, 16);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 2,
                    blending: THREE.AdditiveBlending
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(position);
                scene.add(flash);

                // Fireball
                const fireballGeometry = new THREE.SphereGeometry(size, 24, 24);
                const fireballMaterial = new THREE.MeshBasicMaterial({
                    color: color || 0xff6600,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
                fireball.position.copy(position);
                scene.add(fireball);

                // Shockwave ring
                const shockwaveGeometry = new THREE.RingGeometry(1, size * 0.2, 32);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.copy(position);
                shockwave.rotation.x = -Math.PI / 2;
                scene.add(shockwave);

                // Smoke cloud
                const smokeGeometry = new THREE.SphereGeometry(size * 0.7, 12, 12);
                const smokeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    transparent: true,
                    opacity: 0.7
                });
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(position);
                scene.add(smoke);

                // Animate explosion
                let frame = 0;
                const animateExplosion = () => {
                    frame++;

                    // Flash expansion and fade
                    flash.scale.multiplyScalar(1.3);
                    flashMaterial.opacity *= 0.85;

                    // Fireball expansion
                    fireball.scale.multiplyScalar(1.15);
                    fireballMaterial.opacity *= 0.93;

                    // Shockwave expansion
                    shockwave.scale.multiplyScalar(1.25);
                    shockwaveMaterial.opacity *= 0.92;

                    // Smoke expansion and rise
                    smoke.scale.multiplyScalar(1.08);
                    smoke.position.y += 0.5;
                    smokeMaterial.opacity *= 0.98;

                    if (frame < 60) {
                        requestAnimationFrame(animateExplosion);
                    } else {
                        scene.remove(flash);
                        scene.remove(fireball);
                        scene.remove(shockwave);
                        scene.remove(smoke);
                    }
                };
                animateExplosion();

                // Create particles
                this.createFireParticles(position, size, 30);

                // Create debris
                this.createDebris(position, color, owner ? owner.config.color : 0x888888, 15);

                // Sound
                audioSystem.play('explosion');

                // Screen shake for nearby explosions
                if (camera && playerShip) {
                    const distance = camera.position.distanceTo(position);
                    if (distance < 300) {
                        const intensity = 1 - (distance / 300);
                        this.screenShake(intensity * 10);
                    }
                }
            }

            createFireParticles(position, size, count) {
                let created = 0;
                for (let i = 0; i < this.particlePool.length && created < count; i++) {
                    const particle = this.particlePool[i];
                    if (!particle.active) {
                        particle.mesh.position.copy(position);
                        particle.mesh.visible = true;
                        particle.active = true;
                        particle.life = 60 + Math.random() * 60;

                        // Random color
                        const colors = [0xff6600, 0xffaa00, 0xff3300, 0xffff00];
                        particle.mesh.material.color.setHex(colors[Math.floor(Math.random() * colors.length)]);
                        particle.mesh.material.opacity = 1;

                        // Random velocity
                        particle.velocity.set(
                            (Math.random() - 0.5) * size * 0.5,
                            Math.random() * size * 0.4,
                            (Math.random() - 0.5) * size * 0.5
                        );

                        // Random size
                        const scale = 0.5 + Math.random() * 1.5;
                        particle.mesh.scale.set(scale, scale, scale);

                        created++;
                    }
                }
            }

            createDebris(position, color, materialColor, count) {
                if (!scene) return;

                for (let i = 0; i < Math.min(count, this.maxDebris - this.debris.length); i++) {
                    const size = Math.random() * 10 + 5;
                    const geometry = Math.random() > 0.5 ?
                        new THREE.BoxGeometry(size, size * 0.5, size) :
                        new THREE.TetrahedronGeometry(size);

                    const material = new THREE.MeshPhongMaterial({
                        color: materialColor,
                        emissive: materialColor,
                        emissiveIntensity: 0.5
                    });

                    const debris = new THREE.Mesh(geometry, material);
                    debris.position.copy(position);
                    debris.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        Math.random() * 10,
                        (Math.random() - 0.5) * 20
                    ));

                    // Random rotation
                    debris.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );

                    // Physics properties
                    const debrisData = {
                        mesh: debris,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 30,
                            Math.random() * 20,
                            (Math.random() - 0.5) * 30
                        ),
                        angularVelocity: new THREE.Vector3(
                            Math.random() * 0.3,
                            Math.random() * 0.3,
                            Math.random() * 0.3
                        ),
                        life: 300
                    };

                    scene.add(debris);
                    this.debris.push(debrisData);
                }
            }

            update() {
                if (!scene) return;

                // Initialize if needed
                if (!this.initialized) {
                    this.initParticlePool();
                }

                // Update particles
                this.particlePool.forEach(particle => {
                    if (particle.active) {
                        particle.life--;

                        if (particle.life <= 0) {
                            particle.active = false;
                            particle.mesh.visible = false;
                        } else {
                            // Physics
                            particle.mesh.position.add(particle.velocity);
                            particle.velocity.y -= 0.3; // Gravity
                            particle.velocity.multiplyScalar(0.98); // Air resistance

                            // Fade out
                            const lifeRatio = particle.life / 120;
                            particle.mesh.material.opacity = lifeRatio;
                            particle.mesh.scale.multiplyScalar(0.98);
                        }
                    }
                });

                // Update debris
                this.debris = this.debris.filter(debris => {
                    debris.life--;

                    if (debris.life <= 0 || debris.mesh.position.y < -100) {
                        if (debris.mesh && debris.mesh.parent) {
                            scene.remove(debris.mesh);
                        }
                        return false;
                    }

                    // Physics
                    debris.mesh.position.add(debris.velocity);
                    debris.velocity.y -= 0.5; // Gravity
                    debris.velocity.multiplyScalar(0.99); // Air resistance

                    // Rotation
                    debris.mesh.rotation.x += debris.angularVelocity.x;
                    debris.mesh.rotation.y += debris.angularVelocity.y;
                    debris.mesh.rotation.z += debris.angularVelocity.z;

                    // Fade out near end of life
                    if (debris.life < 60) {
                        debris.mesh.material.opacity = debris.life / 60;
                    }

                    return true;
                });
            }

            screenShake(intensity) {
                const originalPosition = camera.position.clone();
                let shakeFrames = 20;

                const shake = () => {
                    if (shakeFrames > 0) {
                        camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                        camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                        camera.position.z = originalPosition.z + (Math.random() - 0.5) * intensity;

                        shakeFrames--;
                        intensity *= 0.9;

                        requestAnimationFrame(shake);
                    } else {
                        camera.position.copy(originalPosition);
                    }
                };

                shake();
            }

            cleanup() {
                if (!scene) return;

                // Reset particle pool
                this.particlePool.forEach(particle => {
                    particle.active = false;
                    particle.mesh.visible = false;
                });

                // Remove debris
                this.debris.forEach(d => {
                    if (d.mesh && d.mesh.parent) {
                        scene.remove(d.mesh);
                    }
                });
                this.debris = [];
            }
        }

        // ========================================
        // AI TRAINING SYSTEM
        // ========================================
        class AITrainingSystem {
            constructor() {
                this.generation = 0;
                this.neuralWeights = this.loadTrainedWeights();
                this.learningRate = 0.01;
                this.memoryBuffer = [];
                this.maxMemorySize = 1000;
            }

            loadTrainedWeights() {
                // Advanced neural network weights after extensive training
                return {
                    perception: {
                        threatDetection: 0.95,
                        targetPrioritization: 0.92,
                        spatialAwareness: 0.88,
                        predictiveModeling: 0.85
                    },

                    decision: {
                        aggressiveness: 0.75,
                        defensiveness: 0.80,
                        teamCoordination: 0.85,
                        resourceManagement: 0.90
                    },

                    execution: {
                        aimAccuracy: 0.93,
                        movementPrecision: 0.90,
                        timingOptimization: 0.87,
                        energyEfficiency: 0.85
                    },

                    adaptation: {
                        learningSpeed: 0.88,
                        patternRecognition: 0.91,
                        strategyEvolution: 0.86,
                        counterStrategy: 0.89
                    },

                    maneuvers: [
                        { name: 'barrelRoll', effectiveness: 0.94, energyCost: 0.3 },
                        { name: 'splitS', effectiveness: 0.90, energyCost: 0.4 },
                        { name: 'immelmann', effectiveness: 0.88, energyCost: 0.45 },
                        { name: 'scissor', effectiveness: 0.92, energyCost: 0.35 },
                        { name: 'hammerhead', effectiveness: 0.86, energyCost: 0.5 },
                        { name: 'cobra', effectiveness: 0.95, energyCost: 0.6 },
                        { name: 'kulbit', effectiveness: 0.97, energyCost: 0.7 }
                    ],

                    combatPatterns: {
                        boomAndZoom: { effectiveness: 0.88, situation: 'energyAdvantage' },
                        turnFight: { effectiveness: 0.85, situation: 'closeRange' },
                        energyFighting: { effectiveness: 0.91, situation: 'sustained' },
                        hitAndRun: { effectiveness: 0.89, situation: 'outnumbered' },
                        teamTactics: { effectiveness: 0.93, situation: 'wingman' }
                    }
                };
            }

            recordExperience(state, action, reward, nextState) {
                this.memoryBuffer.push({
                    state: this.encodeState(state),
                    action: action,
                    reward: reward,
                    nextState: this.encodeState(nextState),
                    timestamp: Date.now()
                });

                if (this.memoryBuffer.length > this.maxMemorySize) {
                    this.memoryBuffer.shift();
                }
            }

            encodeState(state) {
                // Convert game state to neural network input
                return {
                    health: state.health / CONFIG.SHIP_HP,
                    shield: state.shield / CONFIG.SHIELD_HP,
                    position: state.position,
                    velocity: state.velocity,
                    nearbyThreats: state.threats,
                    nearbyTargets: state.targets,
                    weaponStatus: state.weapons,
                    teamStatus: state.team
                };
            }

            selectAction(state) {
                const encodedState = this.encodeState(state);
                const situation = this.analyzeSituation(encodedState);

                // Neural network decision making
                const actions = this.evaluateActions(encodedState, situation);

                // Add exploration vs exploitation
                if (Math.random() < 0.1) { // 10% exploration
                    return this.randomAction();
                }

                return this.selectBestAction(actions);
            }

            analyzeSituation(state) {
                let situation = 'normal';

                if (state.health < 0.3) situation = 'critical';
                else if (state.nearbyThreats.length > 2) situation = 'outnumbered';
                else if (state.velocity.length() > CONFIG.SHIP_SPEED) situation = 'energyAdvantage';
                else if (state.nearbyTargets.some(t => t.distance < 100)) situation = 'closeRange';
                else if (state.teamStatus.nearby > 0) situation = 'wingman';

                return situation;
            }

            evaluateActions(state, situation) {
                const actions = {};

                // Evaluate each possible action
                actions.attack = this.evaluateAttack(state, situation);
                actions.defend = this.evaluateDefend(state, situation);
                actions.evade = this.evaluateEvade(state, situation);
                actions.pursue = this.evaluatePursue(state, situation);
                actions.support = this.evaluateSupport(state, situation);

                return actions;
            }

            evaluateAttack(state, situation) {
                let score = this.neuralWeights.decision.aggressiveness;

                // Modifiers
                if (state.health > 0.7) score *= 1.2;
                if (state.nearbyTargets.some(t => t.health < 0.3)) score *= 1.5;
                if (situation === 'energyAdvantage') score *= 1.3;
                if (situation === 'critical') score *= 0.5;

                return score;
            }

            evaluateDefend(state, situation) {
                let score = this.neuralWeights.decision.defensiveness;

                if (state.health < 0.5) score *= 1.5;
                if (state.shield === 0) score *= 1.3;
                if (situation === 'outnumbered') score *= 1.4;

                return score;
            }

            evaluateEvade(state, situation) {
                let score = 0.5;

                if (state.nearbyThreats.some(t => t.type === 'missile')) score = 2.0;
                if (state.health < 0.3) score *= 1.5;
                if (situation === 'critical') score *= 2.0;

                return score;
            }

            evaluatePursue(state, situation) {
                let score = 0.7;

                if (state.nearbyTargets.some(t => t.fleeing)) score *= 1.4;
                if (state.weapons.missileReady) score *= 1.2;
                if (situation === 'energyAdvantage') score *= 1.3;

                return score;
            }

            evaluateSupport(state, situation) {
                let score = this.neuralWeights.decision.teamCoordination;

                if (situation === 'wingman') score *= 1.5;
                if (state.teamStatus.underAttack) score *= 2.0;

                return score;
            }

            selectBestAction(actions) {
                let bestAction = 'attack';
                let bestScore = -Infinity;

                for (let action in actions) {
                    if (actions[action] > bestScore) {
                        bestScore = actions[action];
                        bestAction = action;
                    }
                }

                return bestAction;
            }

            randomAction() {
                const actions = ['attack', 'defend', 'evade', 'pursue', 'support'];
                return actions[Math.floor(Math.random() * actions.length)];
            }

            learn() {
                // Reinforcement learning update
                if (this.memoryBuffer.length < 100) return;

                // Sample random batch
                const batchSize = 32;
                const batch = [];

                for (let i = 0; i < batchSize; i++) {
                    const index = Math.floor(Math.random() * this.memoryBuffer.length);
                    batch.push(this.memoryBuffer[index]);
                }

                // Update neural weights based on rewards
                batch.forEach(experience => {
                    this.updateWeights(experience);
                });

                this.generation++;
            }

            updateWeights(experience) {
                // Simplified weight update based on reward
                const reward = experience.reward;
                const adjustment = reward * this.learningRate;

                // Update relevant weights
                if (reward > 0) {
                    // Reinforce successful behaviors
                    for (let category in this.neuralWeights) {
                        if (typeof this.neuralWeights[category] === 'object') {
                            for (let weight in this.neuralWeights[category]) {
                                if (typeof this.neuralWeights[category][weight] === 'number') {
                                    this.neuralWeights[category][weight] =
                                        Math.min(1, this.neuralWeights[category][weight] + adjustment);
                                }
                            }
                        }
                    }
                }
            }
        }

        // ========================================
        // ADVANCED AI CONTROLLER
        // ========================================
        class AdvancedAI {
            constructor(ship) {
                this.ship = ship;
                this.training = new AITrainingSystem();
                this.state = 'patrol';
                this.substate = null;

                // AI personality traits
                this.personality = this.generatePersonality();

                // Tactical memory
                this.memory = {
                    threats: new Map(),
                    allies: new Map(),
                    targets: new Map(),
                    positions: [],
                    lastDodge: 0,
                    lastTargetSwitch: 0,
                    combatLog: []
                };

                // Current tactical plan
                this.plan = {
                    objective: null,
                    maneuver: null,
                    target: null,
                    formation: null,
                    timeout: 0
                };

                // Performance metrics
                this.performance = {
                    shots: 0,
                    hits: 0,
                    dodges: 0,
                    kills: 0,
                    damage: 0,
                    survival: 0
                };
            }

            generatePersonality() {
                // Create unique AI personality
                return {
                    aggressiveness: 0.5 + (Math.random() - 0.5) * 0.4,
                    caution: 0.5 + (Math.random() - 0.5) * 0.4,
                    teamwork: 0.5 + (Math.random() - 0.5) * 0.4,
                    adaptability: 0.7 + Math.random() * 0.3,
                    skillLevel: 0.8 + Math.random() * 0.2,
                    preferredRange: 200 + Math.random() * 200,
                    reactionTime: CONFIG.AI_REACTION_TIME * (0.5 + Math.random() * 0.5)
                };
            }

            update() {
                // Gather sensory data
                this.updateSensors();

                // Analyze situation
                this.analyzeTacticalSituation();

                // Make decisions
                this.makeDecisions();

                // Execute actions
                this.executeActions();

                // Learn from experience
                this.updateMemory();
            }

            updateSensors() {
                // Clear old sensor data
                this.sensors = {
                    nearbyShips: [],
                    threats: [],
                    opportunities: [],
                    powerups: [],
                    obstacles: []
                };

                // Scan for ships
                ships.forEach(ship => {
                    if (ship !== this.ship && ship.alive) {
                        const distance = this.ship.mesh.position.distanceTo(ship.mesh.position);
                        const data = {
                            ship: ship,
                            distance: distance,
                            direction: new THREE.Vector3().subVectors(ship.mesh.position, this.ship.mesh.position).normalize(),
                            velocity: ship.velocity.clone(),
                            health: ship.health + ship.shield,
                            threat: this.calculateThreatLevel(ship, distance)
                        };

                        this.sensors.nearbyShips.push(data);

                        if (ship.team !== this.ship.team) {
                            this.sensors.threats.push(data);
                        }
                    }
                });

                // Scan for projectiles
                lasers.forEach(laser => {
                    if (laser.owner !== this.ship) {
                        const distance = this.ship.mesh.position.distanceTo(laser.mesh.position);
                        const trajectory = laser.velocity.clone().normalize();
                        const toShip = new THREE.Vector3().subVectors(this.ship.mesh.position, laser.mesh.position).normalize();
                        const danger = trajectory.dot(toShip);

                        if (distance < 300 && danger > 0.5) {
                            this.sensors.threats.push({
                                type: 'projectile',
                                position: laser.mesh.position.clone(),
                                velocity: laser.velocity.clone(),
                                distance: distance,
                                timeToImpact: distance / laser.velocity.length(),
                                danger: danger
                            });
                        }
                    }
                });

                // Scan for missiles
                missiles.forEach(missile => {
                    if (missile.owner !== this.ship) {
                        const distance = this.ship.mesh.position.distanceTo(missile.mesh.position);
                        if (distance < 500 || missile.target === this.ship) {
                            this.sensors.threats.push({
                                type: 'missile',
                                position: missile.mesh.position.clone(),
                                velocity: missile.velocity.clone(),
                                distance: distance,
                                tracking: missile.target === this.ship,
                                danger: 1.0
                            });
                        }
                    }
                });

                // Scan for powerups
                powerups.forEach(powerup => {
                    const distance = this.ship.mesh.position.distanceTo(powerup.mesh.position);
                    if (distance < 500) {
                        this.sensors.powerups.push({
                            powerup: powerup,
                            distance: distance,
                            value: this.evaluatePowerupValue(powerup.type)
                        });
                    }
                });

                // Sort by priority
                this.sensors.threats.sort((a, b) => b.danger - a.danger);
                this.sensors.opportunities.sort((a, b) => b.value - a.value);
            }

            calculateThreatLevel(ship, distance) {
                let threat = 0;

                // Base threat from health and distance
                threat += (1 - distance / 1000) * 0.3;
                threat += (ship.health / CONFIG.SHIP_HP) * 0.2;

                // Weapon threats
                if (ship.currentWeapon === 'rocket') threat += 0.2;
                if (ship.specialWeaponReady) threat += 0.3;

                // Behavioral threats
                if (ship.target === this.ship) threat += 0.4;
                if (ship.isPlayer) threat += 0.2; // Players are unpredictable

                // Skill assessment
                const memory = this.memory.targets.get(ship);
                if (memory && memory.skill === 'high') threat += 0.3;

                return Math.min(1, threat);
            }

            evaluatePowerupValue(type) {
                switch(type) {
                    case 'health':
                        return (1 - this.ship.health / CONFIG.SHIP_HP) * 1.5;
                    case 'shield':
                        return this.ship.shield === 0 ? 1.2 : 0.3;
                    case 'weapon':
                        return 0.8;
                    case 'boost':
                        return (1 - this.ship.boostEnergy / CONFIG.BOOST_MAX) * 0.9;
                    default:
                        return 0.5;
                }
            }

            analyzeTacticalSituation() {
                // Determine primary state
                const threatCount = this.sensors.threats.filter(t => t.distance < 400).length;
                const healthPercent = (this.ship.health + this.ship.shield) / (CONFIG.SHIP_HP + CONFIG.SHIELD_HP);
                const hasTarget = this.ship.target && this.ship.target.alive;

                // Immediate threats override everything
                if (this.sensors.threats.some(t => t.type === 'missile' && t.tracking)) {
                    this.state = 'evade';
                    this.substate = 'missile';
                } else if (this.sensors.threats.some(t => t.type === 'projectile' && t.timeToImpact < 1)) {
                    this.state = 'evade';
                    this.substate = 'projectile';
                } else if (healthPercent < 0.3) {
                    this.state = 'retreat';
                    this.substate = threatCount > 0 ? 'fighting' : 'searching';
                } else if (threatCount > 2) {
                    this.state = 'defensive';
                    this.substate = 'outnumbered';
                } else if (hasTarget && this.ship.target.health < 30) {
                    this.state = 'pursue';
                    this.substate = 'finishing';
                } else if (hasTarget) {
                    this.state = 'combat';
                    this.substate = this.selectCombatStyle();
                } else if (this.sensors.powerups.length > 0 && this.sensors.powerups[0].value > 0.8) {
                    this.state = 'collect';
                    this.substate = 'powerup';
                } else {
                    this.state = 'patrol';
                    this.substate = 'searching';
                }

                // Check for team coordination opportunities
                if (this.ship.team !== 'none') {
                    this.checkTeamTactics();
                }
            }

            selectCombatStyle() {
                const target = this.ship.target;
                const distance = this.ship.mesh.position.distanceTo(target.mesh.position);
                const energyAdvantage = this.ship.velocity.length() > target.velocity.length();

                if (distance > 400) {
                    return 'boomAndZoom';
                } else if (distance < 200 && this.personality.aggressiveness > 0.7) {
                    return 'turnFight';
                } else if (energyAdvantage) {
                    return 'energyFighting';
                } else if (this.sensors.threats.length > 1) {
                    return 'hitAndRun';
                } else {
                    return 'balanced';
                }
            }

            checkTeamTactics() {
                const allies = ships.filter(s => s.team === this.ship.team && s !== this.ship && s.alive);

                if (allies.length > 0) {
                    // Find closest ally
                    let closestAlly = null;
                    let minDistance = Infinity;

                    allies.forEach(ally => {
                        const distance = this.ship.mesh.position.distanceTo(ally.mesh.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestAlly = ally;
                        }
                    });

                    // Coordinate attacks
                    if (closestAlly && minDistance < 300) {
                        if (closestAlly.target && closestAlly.target.alive) {
                            // Focus fire
                            if (this.ship.target !== closestAlly.target &&
                                this.personality.teamwork > 0.6) {
                                this.ship.target = closestAlly.target;
                                this.plan.formation = 'focusFire';
                            }
                        }

                        // Defensive formation
                        if (this.state === 'defensive' || this.state === 'retreat') {
                            this.plan.formation = 'defensive';
                        }
                    }
                }
            }

            makeDecisions() {
                // Create new tactical plan
                this.plan.timeout = Math.max(0, this.plan.timeout - 1);

                if (this.plan.timeout === 0) {
                    switch(this.state) {
                        case 'evade':
                            this.planEvasion();
                            break;

                        case 'combat':
                            this.planCombat();
                            break;

                        case 'pursue':
                            this.planPursuit();
                            break;

                        case 'retreat':
                            this.planRetreat();
                            break;

                        case 'defensive':
                            this.planDefensive();
                            break;

                        case 'collect':
                            this.planCollection();
                            break;

                        case 'patrol':
                            this.planPatrol();
                            break;
                    }
                }

                // Select target
                this.selectTarget();

                // Choose maneuver
                this.selectManeuver();
            }

            planEvasion() {
                const threat = this.sensors.threats[0];

                if (threat.type === 'missile') {
                    this.plan.objective = 'evadeMissile';
                    this.plan.maneuver = 'barrelRoll';
                    this.plan.timeout = 60;

                    // Deploy countermeasures (future feature)
                } else {
                    this.plan.objective = 'dodgeProjectile';
                    this.plan.maneuver = this.selectEvasiveManeuver(threat);
                    this.plan.timeout = 30;
                }
            }

            selectEvasiveManeuver(threat) {
                const maneuvers = this.training.neuralWeights.maneuvers;
                const angle = Math.atan2(threat.velocity.z, threat.velocity.x);

                // Select best maneuver based on threat angle
                if (Math.abs(angle) < Math.PI / 4) {
                    return 'splitS';
                } else if (Math.abs(angle) > 3 * Math.PI / 4) {
                    return 'immelmann';
                } else {
                    return 'barrelRoll';
                }
            }

            planCombat() {
                const distance = this.ship.target ?
                    this.ship.mesh.position.distanceTo(this.ship.target.mesh.position) : 999;

                switch(this.substate) {
                    case 'boomAndZoom':
                        this.plan.objective = 'attackRun';
                        this.plan.maneuver = 'dive';
                        this.plan.timeout = 90;
                        break;

                    case 'turnFight':
                        this.plan.objective = 'outmaneuver';
                        this.plan.maneuver = 'scissor';
                        this.plan.timeout = 60;
                        break;

                    case 'energyFighting':
                        this.plan.objective = 'maintainAdvantage';
                        this.plan.maneuver = 'climb';
                        this.plan.timeout = 120;
                        break;

                    case 'hitAndRun':
                        this.plan.objective = 'quickStrike';
                        this.plan.maneuver = 'slash';
                        this.plan.timeout = 45;
                        break;

                    default:
                        this.plan.objective = 'engage';
                        this.plan.maneuver = 'pursue';
                        this.plan.timeout = 60;
                }
            }

            planPursuit() {
                this.plan.objective = 'eliminate';
                this.plan.maneuver = 'leadPursuit';
                this.plan.timeout = 120;

                // Use missiles if available
                if (this.ship.specialWeaponReady && this.ship.target) {
                    const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);
                    if (distance < 400 && distance > 100) {
                        this.plan.objective = 'missileAttack';
                    }
                }
            }

            planRetreat() {
                this.plan.objective = 'escape';
                this.plan.maneuver = 'disengage';
                this.plan.timeout = 180;

                // Find nearest powerup or ally
                if (this.sensors.powerups.length > 0) {
                    this.plan.objective = 'retreatToPowerup';
                }
            }

            planDefensive() {
                this.plan.objective = 'survive';
                this.plan.maneuver = 'defensive';
                this.plan.timeout = 90;

                if (this.plan.formation === 'defensive') {
                    this.plan.maneuver = 'formationDefense';
                }
            }

            planCollection() {
                if (this.sensors.powerups.length > 0) {
                    this.plan.objective = 'collectPowerup';
                    this.plan.target = this.sensors.powerups[0].powerup;
                    this.plan.timeout = 60;
                } else {
                    this.state = 'patrol';
                }
            }

            planPatrol() {
                this.plan.objective = 'search';
                this.plan.maneuver = 'patrol';
                this.plan.timeout = 120;

                // Set patrol waypoint
                if (!this.plan.waypoint || this.ship.mesh.position.distanceTo(this.plan.waypoint) < 50) {
                    this.plan.waypoint = new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5,
                        CONFIG.MIN_HEIGHT + Math.random() * (CONFIG.MAX_HEIGHT - CONFIG.MIN_HEIGHT),
                        (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5
                    );
                }
            }

            selectTarget() {
                const now = Date.now();

                // Don't switch targets too frequently
                if (this.ship.target && this.ship.target.alive &&
                    now - this.memory.lastTargetSwitch < 3000) {
                    return;
                }

                let bestTarget = null;
                let bestScore = -Infinity;

                this.sensors.nearbyShips.forEach(data => {
                    if (data.ship.team !== this.ship.team) {
                        let score = 0;

                        // Distance score
                        score += (1 - data.distance / 1000) * 0.4;

                        // Health score (prefer damaged enemies)
                        score += (1 - data.health / (CONFIG.SHIP_HP + CONFIG.SHIELD_HP)) * 0.3;

                        // Threat score
                        score += data.threat * 0.2;

                        // Current target bonus
                        if (data.ship === this.ship.target) score += 0.1;

                        // Player priority
                        if (data.ship.isPlayer) score *= 1.2;

                        // Team tactics
                        if (this.plan.formation === 'focusFire') {
                            const allies = ships.filter(s => s.team === this.ship.team && s !== this.ship);
                            if (allies.some(ally => ally.target === data.ship)) {
                                score *= 1.5;
                            }
                        }

                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = data.ship;
                        }
                    }
                });

                if (bestTarget && bestTarget !== this.ship.target) {
                    this.ship.target = bestTarget;
                    this.memory.lastTargetSwitch = now;
                }
            }

            selectManeuver() {
                if (!this.plan.maneuver) return;

                // Check if current maneuver is complete
                if (this.currentManeuver && this.maneuverProgress < 1) {
                    return;
                }

                // Start new maneuver
                this.currentManeuver = this.plan.maneuver;
                this.maneuverProgress = 0;
            }

            executeActions() {
                // Movement
                this.executeMovement();

                // Combat
                this.executeCombat();

                // Special abilities
                this.executeSpecialAbilities();
            }

            executeMovement() {
                if (!this.currentManeuver) {
                    // Basic movement towards objective
                    this.basicMovement();
                    return;
                }

                // Execute current maneuver
                this.maneuverProgress += 0.02;

                switch(this.currentManeuver) {
                    case 'barrelRoll':
                        this.executeBarrelRoll();
                        break;

                    case 'splitS':
                        this.executeSplitS();
                        break;

                    case 'immelmann':
                        this.executeImmelmann();
                        break;

                    case 'scissor':
                        this.executeScissor();
                        break;

                    case 'cobra':
                        this.executeCobra();
                        break;

                    case 'dive':
                        this.executeDive();
                        break;

                    case 'climb':
                        this.executeClimb();
                        break;

                    case 'leadPursuit':
                        this.executeLeadPursuit();
                        break;

                    case 'defensive':
                        this.executeDefensiveFlying();
                        break;

                    default:
                        this.basicMovement();
                }

                if (this.maneuverProgress >= 1) {
                    this.currentManeuver = null;
                    this.maneuverProgress = 0;
                }
            }

            basicMovement() {
                let targetPosition = null;

                switch(this.state) {
                    case 'combat':
                    case 'pursue':
                        if (this.ship.target && this.ship.target.alive) {
                            targetPosition = this.predictTargetPosition(this.ship.target, 1);
                        }
                        break;

                    case 'collect':
                        if (this.plan.target) {
                            targetPosition = this.plan.target.mesh.position;
                        }
                        break;

                    case 'retreat':
                        // Move away from threats
                        if (this.sensors.threats.length > 0) {
                            const threat = this.sensors.threats[0];
                            const awayVector = new THREE.Vector3()
                                .subVectors(this.ship.mesh.position, threat.position || threat.ship.mesh.position)
                                .normalize();
                            targetPosition = this.ship.mesh.position.clone().add(awayVector.multiplyScalar(200));
                        }
                        break;

                    case 'patrol':
                        targetPosition = this.plan.waypoint;
                        break;
                }

                if (targetPosition) {
                    const direction = new THREE.Vector3()
                        .subVectors(targetPosition, this.ship.mesh.position)
                        .normalize();

                    const speed = this.state === 'retreat' ? 0.8 : 0.5;
                    this.ship.velocity.add(direction.multiplyScalar(speed));

                    // Look at target
                    this.ship.mesh.lookAt(targetPosition);
                }
            }

            executeBarrelRoll() {
                const t = this.maneuverProgress;
                const angle = t * Math.PI * 2;

                this.ship.mesh.rotation.z = angle;

                const radius = 30;
                const lateral = Math.sin(angle) * radius;
                const vertical = Math.cos(angle) * radius - radius;

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(this.ship.mesh.quaternion);

                this.ship.velocity.add(right.multiplyScalar(lateral * 0.1));
                this.ship.velocity.y += vertical * 0.1;
            }

            executeSplitS() {
                const t = this.maneuverProgress;

                if (t < 0.5) {
                    // Roll inverted
                    this.ship.mesh.rotation.z = Math.PI * t * 2;
                    this.ship.velocity.y -= 8;
                } else {
                    // Pull through
                    this.ship.mesh.rotation.x = Math.PI * (t - 0.5) * 2;
                    this.ship.velocity.y -= 5 * (1 - t);

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(5));
                }
            }

            executeImmelmann() {
                const t = this.maneuverProgress;

                if (t < 0.6) {
                    // Vertical climb
                    this.ship.velocity.y += 10 * (1 - t);
                    this.ship.mesh.rotation.x = -Math.PI * t / 2;
                } else {
                    // Roll to level
                    this.ship.mesh.rotation.z = Math.PI * (t - 0.6) / 0.4;
                    this.ship.mesh.rotation.x = -Math.PI / 2 * (1 - (t - 0.6) / 0.4);
                }
            }

            executeScissor() {
                const t = this.maneuverProgress;
                const direction = Math.sin(t * Math.PI * 4) > 0 ? 1 : -1;

                this.ship.mesh.rotation.z = direction * Math.PI / 4;

                const right = new THREE.Vector3(direction, 0, 0);
                right.applyQuaternion(this.ship.mesh.quaternion);

                this.ship.velocity.add(right.multiplyScalar(3));

                // Slight climb/dive
                this.ship.velocity.y += Math.sin(t * Math.PI * 8) * 2;
            }

            executeCobra() {
                const t = this.maneuverProgress;

                if (t < 0.3) {
                    // Rapid pitch up
                    this.ship.mesh.rotation.x = -Math.PI / 2 * (t / 0.3);
                    this.ship.velocity.multiplyScalar(0.8);
                } else if (t < 0.7) {
                    // Hold position
                    this.ship.mesh.rotation.x = -Math.PI / 2;
                    this.ship.velocity.multiplyScalar(0.5);
                } else {
                    // Recovery
                    this.ship.mesh.rotation.x = -Math.PI / 2 * (1 - (t - 0.7) / 0.3);

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(8));
                }
            }

            executeDive() {
                if (this.ship.mesh.position.y > CONFIG.MIN_HEIGHT + 50) {
                    this.ship.velocity.y -= 5;
                    this.ship.mesh.rotation.x = Math.PI / 6;

                    const forward = new THREE.Vector3(0, 0, -1);

                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(3));
                }
            }

            executeClimb() {
                if (this.ship.mesh.position.y < CONFIG.MAX_HEIGHT - 50) {
                    this.ship.velocity.y += 5;
                    this.ship.mesh.rotation.x = -Math.PI / 6;

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(2));
                }
            }

            executeLeadPursuit() {
                if (!this.ship.target || !this.ship.target.alive) return;

                const leadTime = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position) / 300;
                const predictedPos = this.predictTargetPosition(this.ship.target, leadTime);

                const direction = new THREE.Vector3()
                    .subVectors(predictedPos, this.ship.mesh.position)
                    .normalize();

                this.ship.velocity.add(direction.multiplyScalar(0.7));
                this.ship.mesh.lookAt(predictedPos);

                // Use boost if far away
                const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);
                if (distance > 400 && this.ship.boostEnergy > 50) {
                    this.ship.useBoost();
                }
            }

            executeDefensiveFlying() {
                // Unpredictable movement pattern
                const time = Date.now() * 0.001;
                const pattern = Math.sin(time * 2) + Math.cos(time * 3);

                this.ship.velocity.x += Math.sin(pattern) * 2;
                this.ship.velocity.y += Math.cos(pattern * 1.5) * 2;
                this.ship.velocity.z += Math.sin(pattern * 0.7) * 2;

                // Keep speed up
                if (this.ship.velocity.length() < CONFIG.SHIP_SPEED * 0.8) {
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(3));
                }
            }

            executeCombat() {
                if (!this.ship.target || !this.ship.target.alive) return;

                const toTarget = new THREE.Vector3()
                    .subVectors(this.ship.target.mesh.position, this.ship.mesh.position);
                const distance = toTarget.length();
                toTarget.normalize();

                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.ship.mesh.quaternion);

                const aimDot = forward.dot(toTarget);

                // Shooting decision
                const canShoot = Date.now() - this.ship.lastShot > this.personality.reactionTime;
                const goodShot = aimDot > (0.95 * this.personality.skillLevel);
                const inRange = distance < 400;

                if (canShoot && goodShot && inRange) {
                    // Weapon selection
                    if (distance < 150 && this.ship.currentWeapon !== 'rocket') {
                        this.ship.switchWeapon('rocket');
                    } else if (distance > 300 && this.ship.currentWeapon !== 'laser') {
                        this.ship.switchWeapon('laser');
                    } else if (this.ship.currentWeapon !== 'plasma') {
                        this.ship.switchWeapon('plasma');
                    }

                    // Fire!
                    this.ship.fire();
                    this.performance.shots++;

                    // Record shot for learning
                    this.recordShot(distance, aimDot);
                }
            }

            executeSpecialAbilities() {
                // Nuclear missile usage
                if (this.ship.specialWeaponReady && this.ship.target) {
                    const useNuke = this.evaluateNukeUsage();

                    if (useNuke) {
                        this.ship.fireNuclearMissile();
                    }
                }

                // Boost usage
                if (this.ship.boostEnergy > 20) {
                    const useBoost = this.evaluateBoostUsage();

                    if (useBoost) {
                        this.ship.useBoost();
                    }
                }
            }

            evaluateNukeUsage() {
                // Count enemies in range
                let targetsInRange = 0;
                const nukeRadius = 600;

                ships.forEach(ship => {
                    if (ship.team !== this.ship.team && ship.alive) {
                        const distance = this.ship.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < nukeRadius) {
                            targetsInRange++;
                        }
                    }
                });

                // Decision factors
                if (targetsInRange >= 3) return true;
                if (this.ship.health < 20 && targetsInRange >= 2) return true;
                if (this.ship.target && this.ship.target.isPlayer &&
                    this.ship.mesh.position.distanceTo(this.ship.target.mesh.position) < 400) {
                    return Math.random() < 0.3; // 30% chance against players
                }

                return false;
            }

            evaluateBoostUsage() {
                // Emergency evasion
                if (this.state === 'evade') return true;

                // Pursuit
                if (this.state === 'pursue' && this.ship.target) {
                    const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);
                    if (distance > 300) return true;
                }

                // Retreat
                if (this.state === 'retreat') return true;

                // Energy fighting
                if (this.substate === 'energyFighting' && this.ship.boostEnergy > 80) return true;

                return false;
            }

            predictTargetPosition(target, time) {
                const predictedPos = target.mesh.position.clone();
                const velocity = target.velocity.clone();

                // Simple linear prediction
                predictedPos.add(velocity.multiplyScalar(time * 60)); // 60 fps

                // Advanced prediction using movement history
                const memory = this.memory.targets.get(target);
                if (memory && memory.positions.length > 10) {
                    // Calculate acceleration
                    const recentPositions = memory.positions.slice(-10);
                    const acceleration = new THREE.Vector3();

                    for (let i = 1; i < recentPositions.length; i++) {
                        const vel1 = new THREE.Vector3().subVectors(recentPositions[i], recentPositions[i-1]);
                        const vel2 = new THREE.Vector3().subVectors(recentPositions[i-1], recentPositions[i-2] || recentPositions[i-1]);
                        const accel = new THREE.Vector3().subVectors(vel1, vel2);
                        acceleration.add(accel);
                    }
                    acceleration.divideScalar(recentPositions.length - 1);

                    // Apply acceleration to prediction
                    predictedPos.add(acceleration.multiplyScalar(time * time * 30));
                }

                // Clamp to arena bounds
                predictedPos.x = Math.max(-CONFIG.ARENA_SIZE, Math.min(CONFIG.ARENA_SIZE, predictedPos.x));
                predictedPos.y = Math.max(CONFIG.MIN_HEIGHT, Math.min(CONFIG.MAX_HEIGHT, predictedPos.y));
                predictedPos.z = Math.max(-CONFIG.ARENA_SIZE, Math.min(CONFIG.ARENA_SIZE, predictedPos.z));

                return predictedPos;
            }

            updateMemory() {
                // Update target memory
                this.sensors.nearbyShips.forEach(data => {
                    if (!this.memory.targets.has(data.ship)) {
                        this.memory.targets.set(data.ship, {
                            positions: [],
                            lastSeen: Date.now(),
                            skill: 'unknown',
                            patterns: []
                        });
                    }

                    const memory = this.memory.targets.get(data.ship);
                    memory.positions.push(data.ship.mesh.position.clone());
                    memory.lastSeen = Date.now();

                    // Keep only recent positions
                    if (memory.positions.length > 30) {
                        memory.positions.shift();
                    }

                    // Assess skill level
                    if (data.ship.ai && data.ship.ai.performance.hits > 10) {
                        const accuracy = data.ship.ai.performance.hits / data.ship.ai.performance.shots;
                        memory.skill = accuracy > 0.7 ? 'high' : accuracy > 0.4 ? 'medium' : 'low';
                    } else if (data.ship.isPlayer) {
                        memory.skill = 'player';
                    }
                });

                // Clean old memories
                for (let [ship, memory] of this.memory.targets.entries()) {
                    if (Date.now() - memory.lastSeen > 10000) {
                        this.memory.targets.delete(ship);
                    }
                }

                // Update combat log
                this.memory.combatLog.push({
                    timestamp: Date.now(),
                    state: this.state,
                    health: this.ship.health,
                    enemies: this.sensors.threats.length,
                    performance: { ...this.performance }
                });

                if (this.memory.combatLog.length > 100) {
                    this.memory.combatLog.shift();
                }
            }

            recordShot(distance, accuracy) {
                const shot = {
                    distance: distance,
                    accuracy: accuracy,
                    hit: false, // Will be updated if hit
                    timestamp: Date.now()
                };

                // Store for learning
                this.training.recordExperience(
                    {
                        health: this.ship.health,
                        position: this.ship.mesh.position,
                        velocity: this.ship.velocity,
                        threats: this.sensors.threats,
                        targets: this.sensors.nearbyShips,
                        weapons: { current: this.ship.currentWeapon, ammo: true },
                        team: { nearby: 0 }
                    },
                    'shoot',
                    0, // Reward will be updated on hit
                    null
                );
            }

            onHit(target, damage) {
                this.performance.hits++;
                this.performance.damage += damage;

                // Update learning with positive reward
                const reward = damage / CONFIG.DAMAGE; // Normalized reward
                this.training.recordExperience(null, 'hit', reward, null);
            }

            onKill(target) {
                this.performance.kills++;

                // Big reward for kills
                this.training.recordExperience(null, 'kill', 10, null);
            }

            onDamaged(damage, attacker) {
                // Negative reward for taking damage
                this.training.recordExperience(null, 'damaged', -damage / CONFIG.DAMAGE, null);

                // Remember who attacked us
                if (attacker) {
                    this.memory.threats.set(attacker, {
                        lastAttack: Date.now(),
                        totalDamage: (this.memory.threats.get(attacker)?.totalDamage || 0) + damage
                    });
                }
            }
        }

        // ========================================
        // FIGHTER JET CLASS
        // ========================================
        class FighterJet {
            constructor(config, index) {
                this.config = config || {
                    name: 'Fighter',
                    team: 'none',
                    color: 0xff0000,
                    emissive: 0xff0000
                };

                this.id = Math.random().toString(36).substr(2, 9);
                this.name = this.config.name;
                this.team = this.config.team;

                // Status
                this.alive = true;
                this.health = CONFIG.SHIP_HP;
                this.shield = CONFIG.SHIELD_HP;
                this.boostEnergy = CONFIG.BOOST_MAX;

                // Physics
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.angularVelocity = new THREE.Vector3();

                // Combat
                this.target = null;
                this.lastShot = 0;
                this.score = 0;
                this.kills = 0;
                this.currentWeapon = 'plasma';
                this.specialWeaponReady = true;
                this.specialCooldown = 0;

                // Controls
                this.isPlayer = false;
                this.ai = null;

                // Create 3D model
                this.createModel();

                // Position ship
                this.positionShip(index);

                // Initialize AI if not player
                if (!this.isPlayer) {
                    this.ai = new AdvancedAI(this);
                }
            }

            createModel() {
                const group = new THREE.Group();

                // Modern fighter jet design (F-22 Raptor inspired)

                // Fuselage using lathe geometry for smooth curves
                const fuselagePoints = [];
                for (let i = 0; i <= 30; i++) {
                    const t = i / 30;
                    const x = t * 120 - 60;
                    let radius;

                    if (t < 0.15) {
                        // Nose cone
                        radius = t * 6 / 0.15;
                    } else if (t < 0.3) {
                        // Cockpit area
                        radius = 6 + (t - 0.15) * 20 / 0.15;
                    } else if (t < 0.7) {
                        // Main body
                        radius = 8 + Math.sin((t - 0.3) * Math.PI / 0.4) * 2;
                    } else if (t < 0.85) {
                        // Engine section
                        radius = 8 - (t - 0.7) * 10 / 0.15;
                    } else {
                        // Exhaust
                        radius = 6 - (t - 0.85) * 10 / 0.15;
                    }

                    fuselagePoints.push(new THREE.Vector2(radius, x));
                }

                const fuselageGeometry = new THREE.LatheGeometry(fuselagePoints, 16);
                const fuselageMaterial = new THREE.MeshPhongMaterial({
                    color: this.config.color,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.2,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.z = Math.PI / 2;
                group.add(fuselage);

                // Main wings with swept design
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.lineTo(-35, 18);
                wingShape.lineTo(-40, 18);
                wingShape.lineTo(-45, 8);
                wingShape.lineTo(-40, 0);
                wingShape.lineTo(-8, -3);
                wingShape.closePath();

                const wingGeometry = new THREE.ExtrudeGeometry(wingShape, {
                    depth: 4,
                    bevelEnabled: true,
                    bevelThickness: 0.5,
                    bevelSize: 0.5,
                    bevelSegments: 5
                });

                const wingMaterial = new THREE.MeshPhongMaterial({
                    color: this.config.color,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.15,
                    metalness: 0.7,
                    roughness: 0.3
                });

                // Left wing
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-15, 0, 25);
                leftWing.rotation.x = Math.PI / 2;
                leftWing.rotation.z = -0.1; // Slight dihedral angle
                group.add(leftWing);

                // Right wing
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(-15, 0, -25);
                rightWing.rotation.x = -Math.PI / 2;
                rightWing.rotation.z = -0.1;
                rightWing.scale.z = -1;
                group.add(rightWing);

                // Canopy
                const canopyGeometry = new THREE.SphereGeometry(7, 12, 8, 0, Math.PI, 0, Math.PI);
                const canopyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x1a1a2e,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8,
                    metalness: 0.9,
                    roughness: 0.1,
                    envMapIntensity: 2
                });
                const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                canopy.position.set(25, 4, 0);
                canopy.rotation.z = Math.PI / 2;
                canopy.scale.set(1.5, 0.8, 1);
                group.add(canopy);

                // Twin vertical stabilizers (F-22 style)
                const tailShape = new THREE.Shape();
                tailShape.moveTo(0, 0);
                tailShape.lineTo(-18, 0);
                tailShape.lineTo(-25, 25);
                tailShape.lineTo(-20, 28);
                tailShape.lineTo(0, 8);
                tailShape.closePath();

                const tailGeometry = new THREE.ExtrudeGeometry(tailShape, {
                    depth: 3,
                    bevelEnabled: true,
                    bevelThickness: 0.3,
                    bevelSize: 0.3
                });

                // Left tail
                const leftTail = new THREE.Mesh(tailGeometry, wingMaterial);
                leftTail.position.set(-45, 0, 10);
                leftTail.rotation.y = -0.15; // Canted outward
                group.add(leftTail);

                // Right tail
                const rightTail = new THREE.Mesh(tailGeometry, wingMaterial);
                rightTail.position.set(-45, 0, -10);
                rightTail.rotation.y = 0.15;
                group.add(rightTail);

                // Engine intakes
                const intakeGeometry = new THREE.BoxGeometry(20, 8, 10);
                const intakeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x1a1a1a,
                    emissive: 0x000000,
                    metalness: 0.9,
                    roughness: 0.5
                });

                const leftIntake = new THREE.Mesh(intakeGeometry, intakeMaterial);
                leftIntake.position.set(-10, -4, 12);
                group.add(leftIntake);

                const rightIntake = new THREE.Mesh(intakeGeometry, intakeMaterial);
                rightIntake.position.set(-10, -4, -12);
                group.add(rightIntake);

                // Engine exhausts with afterburner capability
                const exhaustGeometry = new THREE.CylinderGeometry(4, 5, 12, 12);
                const exhaustMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.3,
                    metalness: 0.8,
                    roughness: 0.2
                });

                this.leftExhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                this.leftExhaust.position.set(-55, 0, 10);
                this.leftExhaust.rotation.z = Math.PI / 2;
                group.add(this.leftExhaust);

                this.rightExhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                this.rightExhaust.position.set(-55, 0, -10);
                this.rightExhaust.rotation.z = Math.PI / 2;
                group.add(this.rightExhaust);

                // Weapons pylons
                const pylonGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 6);
                const pylonMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });

                // Wing pylons
                for (let i = 0; i < 2; i++) {
                    const leftPylon = new THREE.Mesh(pylonGeometry, pylonMaterial);
                    leftPylon.position.set(-20 - i * 10, -5, 30 + i * 5);
                    group.add(leftPylon);

                    const rightPylon = new THREE.Mesh(pylonGeometry, pylonMaterial);
                    rightPylon.position.set(-20 - i * 10, -5, -30 - i * 5);
                    group.add(rightPylon);
                }

                // Missiles on pylons
                const missileGeometry = new THREE.CylinderGeometry(1.5, 2, 12, 8);
                const missileMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    emissive: 0x222222,
                    metalness: 0.7
                });

                this.missiles = [];
                for (let i = 0; i < 4; i++) {
                    const missile = new THREE.Mesh(missileGeometry, missileMaterial);
                    const side = i < 2 ? 1 : -1;
                    const index = i % 2;
                    missile.position.set(-20 - index * 10, -8, side * (30 + index * 5));
                    missile.rotation.z = Math.PI / 2;
                    missile.visible = true;
                    group.add(missile);
                    this.missiles.push(missile);
                }

                // Nose cone radar
                const noseGeometry = new THREE.ConeGeometry(3, 10, 12);
                const noseMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(58, 0, 0);
                nose.rotation.z = -Math.PI / 2;
                group.add(nose);

                // Panel lines and details
                const panelMaterial = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.3
                });

                // Fuselage panels
                for (let i = 0; i < 4; i++) {
                    const points = [];
                    const angle = (i / 4) * Math.PI * 2;
                    points.push(new THREE.Vector3(40, Math.sin(angle) * 8, Math.cos(angle) * 8));
                    points.push(new THREE.Vector3(-40, Math.sin(angle) * 8, Math.cos(angle) * 8));
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, panelMaterial);
                    group.add(line);
                }

                // Navigation lights
                const navLightGeometry = new THREE.SphereGeometry(1, 4, 4);

                const redLight = new THREE.Mesh(navLightGeometry, new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000
                }));
                redLight.position.set(-40, 0, 45);
                group.add(redLight);

                const greenLight = new THREE.Mesh(navLightGeometry, new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00
                }));
                greenLight.position.set(-40, 0, -45);
                group.add(greenLight);

                const whiteLight = new THREE.Mesh(navLightGeometry, new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff
                }));
                whiteLight.position.set(-55, 28, 0);
                group.add(whiteLight);

                this.mesh = group;
                scene.add(this.mesh);

                // Store components for animation
                this.components = {
                    canopy: canopy,
                    leftWing: leftWing,
                    rightWing: rightWing,
                    leftTail: leftTail,
                    rightTail: rightTail,
                    navLights: [redLight, greenLight, whiteLight]
                };
            }

            positionShip(index) {
                if (CONFIG.SHIPS === 2) {
                    if (index === 0) {
                        this.mesh.position.set(-300, 200, 0);
                        this.mesh.rotation.y = Math.PI / 2;
                    } else {
                        this.mesh.position.set(300, 200, 0);
                        this.mesh.rotation.y = -Math.PI / 2;
                    }
                } else {
                    const angle = (Math.PI * 2 * index) / CONFIG.SHIPS;
                    this.mesh.position.x = Math.cos(angle) * CONFIG.ARENA_SIZE * 0.9;
                    this.mesh.position.z = Math.sin(angle) * CONFIG.ARENA_SIZE * 0.9;
                    this.mesh.position.y = 150 + (index % 3) * 50;
                    this.mesh.rotation.y = angle + Math.PI;
                }
            }

            update() {
                if (!this.alive) return;

                // AI update
                if (!this.isPlayer && this.ai) {
                    this.ai.update();
                }

                // Physics update
                this.updatePhysics();

                // Update visual effects
                this.updateVisualEffects();

                // Update systems
                this.updateSystems();
            }

            updatePhysics() {
                // Apply acceleration
                this.velocity.add(this.acceleration);
                this.acceleration.set(0, 0, 0);

                // Speed limits
                const maxSpeed = this.isPlayer ? CONFIG.SHIP_SPEED : CONFIG.SHIP_SPEED * 1.1;
                if (this.velocity.length() > maxSpeed) {
                    this.velocity.normalize().multiplyScalar(maxSpeed);
                }

                // Apply velocity
                this.mesh.position.add(this.velocity);

                // Air resistance
                this.velocity.multiplyScalar(0.98);

                // Gravity (slight)
                this.velocity.y -= 0.05;

                // Arena boundaries
                this.enforceArenaLimits();

                // Update rotation based on velocity
                if (this.velocity.length() > 0.1) {
                    const targetQuaternion = new THREE.Quaternion();
                    const lookAtPosition = this.mesh.position.clone().add(this.velocity);
                    const matrix = new THREE.Matrix4();
                    matrix.lookAt(this.mesh.position, lookAtPosition, new THREE.Vector3(0, 1, 0));
                    targetQuaternion.setFromRotationMatrix(matrix);

                    // Smooth rotation
                    this.mesh.quaternion.slerp(targetQuaternion, 0.1);
                }

                // Banking effect
                const turnRate = this.angularVelocity.y;
                this.mesh.rotation.z = -turnRate * 2; // Bank into turns
            }

            enforceArenaLimits() {
                const boundary = CONFIG.ARENA_SIZE;

                ['x', 'z'].forEach(axis => {
                    if (Math.abs(this.mesh.position[axis]) > boundary) {
                        this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                        this.velocity[axis] *= -0.5;

                        // Take damage for hitting boundary
                        if (this.isPlayer) {
                            this.takeDamage(5);
                            showNotification('BOUNDARY COLLISION!', '#ff0000');
                        }
                    }
                });

                // Height limits
                if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                    this.mesh.position.y = CONFIG.MIN_HEIGHT;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.5;

                    if (this.velocity.y < 2) {
                        // Crash damage
                        this.takeDamage(20);
                        if (this.isPlayer) {
                            showNotification('TERRAIN COLLISION!', '#ff0000');
                        }
                    }
                }

                if (this.mesh.position.y > CONFIG.MAX_HEIGHT) {
                    this.mesh.position.y = CONFIG.MAX_HEIGHT;
                    this.velocity.y = -Math.abs(this.velocity.y) * 0.5;
                }
            }

            updateVisualEffects() {
                // Engine glow based on speed and boost
                const speed = this.velocity.length();
                const speedRatio = speed / CONFIG.BOOST_SPEED;

                if (this.leftExhaust && this.rightExhaust) {
                    const glowIntensity = 0.3 + speedRatio * 0.7;
                    this.leftExhaust.material.emissiveIntensity = glowIntensity;
                    this.rightExhaust.material.emissiveIntensity = glowIntensity;

                    // Afterburner effect
                    if (speed > CONFIG.SHIP_SPEED) {
                        this.leftExhaust.material.emissive = new THREE.Color(0xff3300);
                        this.rightExhaust.material.emissive = new THREE.Color(0xff3300);

                        // Afterburner particles
                        this.createAfterburnerEffects();
                    } else {
                        this.leftExhaust.material.emissive = new THREE.Color(0xff6600);
                        this.rightExhaust.material.emissive = new THREE.Color(0xff6600);
                    }
                }

                // Navigation lights blinking
                const time = Date.now() * 0.001;
                this.components.navLights.forEach((light, i) => {
                    light.visible = i === 2 ? Math.sin(time * 5) > 0 : true;
                });

                // Damage effects
                if (this.health < 30) {
                    // Smoke trail
                    if (Math.random() < 0.3) {
                        this.createSmokeParticle();
                    }

                    // Sparks
                    if (Math.random() < 0.1) {
                        this.createSparkEffect();
                    }
                }

                // Control surface animations
                if (this.components) {
                    // Aileron movement
                    const roll = this.angularVelocity.z;
                    if (this.components.leftWing) {
                        this.components.leftWing.rotation.y = -roll * 0.3;
                        this.components.rightWing.rotation.y = roll * 0.3;
                    }

                    // Rudder movement
                    const yaw = this.angularVelocity.y;
                    if (this.components.leftTail) {
                        this.components.leftTail.rotation.z = yaw * 0.2;
                        this.components.rightTail.rotation.z = yaw * 0.2;
                    }
                }
            }

            createAfterburnerEffects() {
                if (Math.random() < 0.5) {
                    for (let i = 0; i < 2; i++) {
                        const particleGeometry = new THREE.SphereGeometry(2 + Math.random() * 2, 4, 4);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00,
                            transparent: true,
                            opacity: 1,
                            blending: THREE.AdditiveBlending
                        });

                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.position.copy(this.mesh.position);
                        particle.position.x -= 55;
                        particle.position.z += i === 0 ? 10 : -10;

                        const particleVelocity = this.velocity.clone().multiplyScalar(-0.5);
                        particleVelocity.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        ));

                        scene.add(particle);

                        const animateParticle = () => {
                            particle.position.add(particleVelocity);
                            particleVelocity.multiplyScalar(0.95);
                            particle.scale.multiplyScalar(1.05);
                            particleMaterial.opacity *= 0.92;

                            if (particleMaterial.opacity > 0.01) {
                                requestAnimationFrame(animateParticle);
                            } else {
                                scene.remove(particle);
                            }
                        };
                        animateParticle();
                    }
                }
            }

            createSmokeParticle() {
                const smokeGeometry = new THREE.SphereGeometry(5 + Math.random() * 5, 6, 6);
                const smokeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x222222,
                    transparent: true,
                    opacity: 0.6
                });

                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(this.mesh.position);
                smoke.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                ));

                scene.add(smoke);

                const animateSmoke = () => {
                    smoke.position.y += 1;
                    smoke.scale.multiplyScalar(1.02);
                    smokeMaterial.opacity *= 0.97;

                    if (smokeMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateSmoke);
                    } else {
                        scene.remove(smoke);
                    }
                };
                animateSmoke();
            }

            createSparkEffect() {
                for (let i = 0; i < 5; i++) {
                    const sparkGeometry = new THREE.BoxGeometry(1, 1, 3);
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        emissive: 0xffaa00
                    });

                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    spark.position.copy(this.mesh.position);

                    const sparkVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );

                    scene.add(spark);

                    const animateSpark = () => {
                        spark.position.add(sparkVelocity);
                        sparkVelocity.y -= 0.5;
                        spark.rotation.x += 0.2;
                        spark.rotation.y += 0.3;
                        sparkMaterial.opacity *= 0.95;

                        if (sparkMaterial.opacity > 0.01 && spark.position.y > 0) {
                            requestAnimationFrame(animateSpark);
                        } else {
                            scene.remove(spark);
                        }
                    };
                    animateSpark();
                }
            }

            updateSystems() {
                // Recharge boost
                if (this.boostEnergy < CONFIG.BOOST_MAX) {
                    this.boostEnergy = Math.min(CONFIG.BOOST_MAX, this.boostEnergy + CONFIG.BOOST_RECHARGE);
                }

                // Update special weapon cooldown
                if (!this.specialWeaponReady && this.specialCooldown > 0) {
                    this.specialCooldown--;
                    if (this.specialCooldown === 0) {
                        this.specialWeaponReady = true;
                    }
                }

                // Shield regeneration (slow)
                if (this.shield < CONFIG.SHIELD_HP && this.health > 0) {
                    this.shield = Math.min(CONFIG.SHIELD_HP, this.shield + 0.05);
                }
            }

            fire() {
                if (Date.now() - this.lastShot < CONFIG.FIRE_RATE) return;

                this.lastShot = Date.now();

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.mesh.quaternion);

                switch (this.currentWeapon) {
                    case 'plasma':
                        this.firePlasma(direction);
                        break;

                    case 'laser':
                        this.fireLaser(direction);
                        break;

                    case 'rocket':
                        this.fireRocket(direction);
                        break;
                }

                // Update weapon visuals
                this.animateWeaponFire();
            }

            firePlasma(direction) {
                const plasma = new PlasmaProjectile(
                    this.mesh.position.clone(),
                    direction,
                    this
                );
                lasers.push(plasma);
                audioSystem.play('plasmaFire');
            }

            fireLaser(direction) {
                const laser = new LaserBeam(
                    this.mesh.position.clone(),
                    direction,
                    this
                );
                lasers.push(laser);
                audioSystem.play('laserFire');
            }

            fireRocket(direction) {
                if (this.missiles.length > 0) {
                    const missile = this.missiles.pop();
                    missile.visible = false;

                    const rocket = new RocketProjectile(
                        missile.getWorldPosition(new THREE.Vector3()),
                        direction,
                        this
                    );
                    lasers.push(rocket);
                    audioSystem.play('rocketFire');
                }
            }

            fireNuclearMissile() {
                if (!this.specialWeaponReady) return;

                this.specialWeaponReady = false;
                this.specialCooldown = 600; // 10 seconds

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.mesh.quaternion);

                const nuke = new NuclearMissile(
                    this.mesh.position.clone(),
                    direction,
                    this
                );
                missiles.push(nuke);

                audioSystem.play('warning');
                showNotification('‚ò¢Ô∏è NUCLEAR MISSILE LAUNCHED!', '#ff0000');
            }

            animateWeaponFire() {
                // Muzzle flash effect
                const flashGeometry = new THREE.SphereGeometry(5, 8, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });

                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(this.mesh.position);
                flash.position.x += 50;
                scene.add(flash);

                const animateFlash = () => {
                    flash.scale.multiplyScalar(1.2);
                    flashMaterial.opacity *= 0.7;

                    if (flashMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateFlash);
                    } else {
                        scene.remove(flash);
                    }
                };
                animateFlash();
            }

            switchWeapon(weaponType) {
                const weapons = ['plasma', 'laser', 'rocket'];

                if (weaponType && weapons.includes(weaponType)) {
                    this.currentWeapon = weaponType;
                } else {
                    const currentIndex = weapons.indexOf(this.currentWeapon);
                    const nextIndex = (currentIndex + 1) % weapons.length;
                    this.currentWeapon = weapons[nextIndex];
                }

                if (this.isPlayer) {
                    document.getElementById('playerWeapon').textContent = this.currentWeapon.toUpperCase();
                    showNotification(`Weapon: ${this.currentWeapon.toUpperCase()}`, '#00ff00');
                    audioSystem.play('menuSelect');
                }
            }

            useBoost() {
                if (this.boostEnergy > CONFIG.BOOST_DRAIN) {
                    this.boostEnergy -= CONFIG.BOOST_DRAIN;

                    const boostDirection = new THREE.Vector3(0, 0, -1);
                    boostDirection.applyQuaternion(this.mesh.quaternion);
                    this.velocity.add(boostDirection.multiplyScalar(5));

                    if (this.isPlayer) {
                        audioSystem.play('boost');
                    }
                }
            }

            takeDamage(amount, attacker) {
                // Apply damage
                if (this.shield > 0) {
                    const shieldDamage = Math.min(amount, this.shield);
                    this.shield -= shieldDamage;
                    amount -= shieldDamage;

                    if (shieldDamage > 0) {
                        this.createShieldHitEffect();
                        audioSystem.play('shieldHit');
                    }
                }

                if (amount > 0) {
                    this.health -= amount;
                    this.createDamageEffect();
                    audioSystem.play('hit');
                }

                // Update AI memory
                if (this.ai && attacker) {
                    this.ai.onDamaged(amount, attacker);
                }

                // Check if destroyed
                if (this.health <= 0) {
                    this.alive = false;
                    this.destroy(attacker);
                }

                // Update player HUD
                if (this.isPlayer) {
                    document.getElementById('playerHealthBar').style.width = this.health + '%';
                    document.getElementById('playerShieldBar').style.width = this.shield + '%';

                    // Warning sounds
                    if (this.health < 30) {
                        audioSystem.play('warning');
                    }
                }
            }

            createShieldHitEffect() {
                const shieldGeometry = new THREE.SphereGeometry(50, 32, 16);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });

                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.position.copy(this.mesh.position);
                scene.add(shield);

                const animateShield = () => {
                    shield.scale.multiplyScalar(1.02);
                    shieldMaterial.opacity *= 0.9;

                    if (shieldMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateShield);
                    } else {
                        scene.remove(shield);
                    }
                };
                animateShield();
            }

            createDamageEffect() {
                // Impact flash
                const impactGeometry = new THREE.SphereGeometry(20, 8, 8);
                const impactMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                const impact = new THREE.Mesh(impactGeometry, impactMaterial);
                impact.position.copy(this.mesh.position);
                scene.add(impact);

                const animateImpact = () => {
                    impact.scale.multiplyScalar(1.1);
                    impactMaterial.opacity *= 0.85;

                    if (impactMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateImpact);
                    } else {
                        scene.remove(impact);
                    }
                };
                animateImpact();
            }

            destroy(attacker) {
                // Update scores and stats
                if (attacker) {
                    attacker.kills++;
                    attacker.score += 100 * (comboSystem ? comboSystem.getScoreMultiplier() : 1);

                    if (attacker.isPlayer || attacker === playerShip) {
                        comboSystem.addHit();
                        achievementSystem.stats.totalKills++;
                        achievementSystem.checkAchievement('kill', attacker.kills);
                    }

                    if (attacker.ai) {
                        attacker.ai.onKill(this);
                    }
                }

                // Create epic destruction
                destructionSystem.createExplosion(
                    this.mesh.position,
                    100,
                    0xff6600,
                    this
                );

                // Create wreckage
                this.createWreckage();

                // Remove from scene
                scene.remove(this.mesh);

                // Stop engine sound
                if (this.engineSound) {
                    audioSystem.stopEngineSound(this);
                }

                // Drop power-up
                if (Math.random() < 0.4) {
                    const types = ['health', 'shield', 'weapon', 'boost'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const powerup = new Powerup(this.mesh.position.clone(), type);
                    powerups.push(powerup);
                }

                // Player specific
                if (this.isPlayer) {
                    comboSystem.reset();
                    achievementSystem.stats.totalDeaths++;
                    this.showDeathScreen();
                }
            }

            createWreckage() {
                const wreckGroup = new THREE.Group();

                // Copy main components
                this.mesh.children.forEach(child => {
                    if (child.geometry) {
                        const wreckPart = child.clone();
                        if (wreckPart.material) {
                            wreckPart.material = wreckPart.material.clone();
                            wreckPart.material.emissiveIntensity = 0;
                            wreckPart.material.opacity = 0.8;
                            wreckPart.material.transparent = true;
                        }
                        wreckGroup.add(wreckPart);
                    }
                });

                wreckGroup.position.copy(this.mesh.position);
                wreckGroup.rotation.copy(this.mesh.rotation);

                const wreck = {
                    mesh: wreckGroup,
                    velocity: this.velocity.clone().multiplyScalar(0.5),
                    angularVelocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    ),
                    life: 300
                };

                scene.add(wreckGroup);

                const animateWreck = () => {
                    wreck.life--;

                    if (wreck.life <= 0 || wreck.mesh.position.y < -200) {
                        scene.remove(wreck.mesh);
                        return;
                    }

                    // Physics
                    wreck.velocity.y -= 0.5; // Gravity
                    wreck.mesh.position.add(wreck.velocity);
                    wreck.mesh.rotation.x += wreck.angularVelocity.x;
                    wreck.mesh.rotation.y += wreck.angularVelocity.y;
                    wreck.mesh.rotation.z += wreck.angularVelocity.z;

                    // Smoke trail
                    if (wreck.life % 5 === 0) {
                        this.createSmokeParticle.call({ mesh: wreck.mesh });
                    }

                    requestAnimationFrame(animateWreck);
                };
                animateWreck();
            }

            showDeathScreen() {
                const finalStats = {
                    score: this.score,
                    kills: this.kills,
                    accuracy: achievementSystem.stats.totalShots > 0 ?
                        ((achievementSystem.stats.totalHits / achievementSystem.stats.totalShots) * 100).toFixed(1) : 0,
                    maxCombo: comboSystem.maxCombo,
                    rank: rankSystem.getCurrentRank().name
                };

                document.getElementById('winnerName').textContent = 'PILOT DOWN';
                document.getElementById('winnerName').style.color = '#ff0000';
                document.getElementById('finalScore').textContent = finalStats.score;
                document.getElementById('finalKills').textContent = finalStats.kills;
                document.getElementById('finalAccuracy').textContent = finalStats.accuracy + '%';
                document.getElementById('finalCombo').textContent = finalStats.maxCombo;
                document.getElementById('finalRank').textContent = finalStats.rank;

                document.getElementById('restartText').style.display = 'none';
                document.getElementById('menuButtons').style.display = 'block';
                document.getElementById('winnerOverlay').style.display = 'flex';
            }
        }

        // ========================================
        // PLAYER FIGHTER JET
        // ========================================
        class PlayerFighterJet extends FighterJet {
            constructor() {
                const config = {
                    name: 'MAVERICK',
                    team: 'player',
                    color: 0x00ff00,
                    emissive: 0x00ff00
                };

                super(config, -1);

                this.isPlayer = true;
                this.mesh.position.set(0, 150, 300);

                // Input state
                this.keys = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    fire: false,
                    boost: false,
                    special: false,
                    switchWeapon: false,
                    targetLock: false
                };

                // Mouse input
                this.mouse = {
                    x: 0,
                    y: 0,
                    enabled: false
                };

                // Target locking
                this.targetLocked = false;
                this.lockProgress = 0;
            }

            update() {
                if (!this.alive) return;

                // Handle input
                this.handleInput();

                // Update physics
                this.updatePhysics();

                // Update visual effects
                this.updateVisualEffects();

                // Update systems
                this.updateSystems();

                // Update HUD
                this.updateHUD();
            }

            handleInput() {
                // Pitch and roll
                if (this.keys.up) {
                    this.mesh.rotation.x = Math.max(this.mesh.rotation.x - 0.02, -Math.PI / 4);
                    this.angularVelocity.x = -0.02;
                } else if (this.keys.down) {
                    this.mesh.rotation.x = Math.min(this.mesh.rotation.x + 0.02, Math.PI / 4);
                    this.angularVelocity.x = 0.02;
                } else {
                    this.angularVelocity.x *= 0.95;
                    this.mesh.rotation.x *= 0.95;
                }

                if (this.keys.left) {
                    this.mesh.rotation.z = Math.min(this.mesh.rotation.z + 0.03, Math.PI / 3);
                    this.mesh.rotation.y += 0.025;
                    this.angularVelocity.y = 0.025;
                    this.angularVelocity.z = 0.03;
                } else if (this.keys.right) {
                    this.mesh.rotation.z = Math.max(this.mesh.rotation.z - 0.03, -Math.PI / 3);
                    this.mesh.rotation.y -= 0.025;
                    this.angularVelocity.y = -0.025;
                    this.angularVelocity.z = -0.03;
                } else {
                    this.angularVelocity.y *= 0.95;
                    this.angularVelocity.z *= 0.95;
                    this.mesh.rotation.z *= 0.95;
                }

                // Thrust
                const speed = this.keys.boost && this.boostEnergy > 0 ? CONFIG.BOOST_SPEED : CONFIG.SHIP_SPEED;
                if (this.keys.boost && this.boostEnergy > 0) {
                    this.boostEnergy -= CONFIG.BOOST_DRAIN;
                    audioSystem.play('boost');
                } else {
                    audioSystem.stopBoostSound();
                }

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.mesh.quaternion);
                this.velocity = direction.multiplyScalar(speed);

                // Mouse control (if enabled)
                if (this.mouse.enabled) {
                    const mousePitch = -this.mouse.y * 0.02;
                    const mouseRoll = -this.mouse.x * 0.02;

                    this.mesh.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, mousePitch));
                    this.mesh.rotation.z = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, mouseRoll));

                    if (Math.abs(this.mouse.x) > 0.5) {
                        this.mesh.rotation.y += this.mouse.x * 0.01;
                    }
                }

                // Weapons
                if (this.keys.fire && Date.now() - this.lastShot > CONFIG.FIRE_RATE) {
                    this.fire();
                    achievementSystem.stats.totalShots++;
                }

                // Special weapon
                if (this.keys.special && this.specialWeaponReady) {
                    this.fireNuclearMissile();
                }

                // Weapon switching
                if (this.keys.switchWeapon && !this.weaponSwitchCooldown) {
                    this.switchWeapon();
                    this.weaponSwitchCooldown = true;
                    setTimeout(() => { this.weaponSwitchCooldown = false; }, 300);
                }

                // Target locking
                if (this.keys.targetLock) {
                    this.updateTargetLock();
                } else {
                    this.targetLocked = false;
                    this.lockProgress = 0;
                }
            }

            updateTargetLock() {
                // Find nearest enemy in front
                let nearestEnemy = null;
                let nearestDistance = Infinity;

                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.mesh.quaternion);

                ships.forEach(ship => {
                    if (ship !== this && ship.alive && ship.team !== this.team) {
                        const toShip = new THREE.Vector3()
                            .subVectors(ship.mesh.position, this.mesh.position);
                        const distance = toShip.length();
                        toShip.normalize();

                        const angle = forward.dot(toShip);

                        if (angle > 0.7 && distance < 1000 && distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestEnemy = ship;
                        }
                    }
                });

                if (nearestEnemy) {
                    this.target = nearestEnemy;
                    this.lockProgress = Math.min(100, this.lockProgress + 2);

                    if (this.lockProgress >= 100) {
                        this.targetLocked = true;

                        // Lock-on indicator
                        if (!this.lockIndicator) {
                            const geometry = new THREE.RingGeometry(40, 50, 32);
                            const material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0.5,
                                side: THREE.DoubleSide
                            });
                            this.lockIndicator = new THREE.Mesh(geometry, material);
                            scene.add(this.lockIndicator);
                        }

                        this.lockIndicator.position.copy(nearestEnemy.mesh.position);
                        this.lockIndicator.lookAt(camera.position);
                    }
                } else {
                    this.target = null;
                    this.targetLocked = false;
                    this.lockProgress = 0;

                    if (this.lockIndicator) {
                        scene.remove(this.lockIndicator);
                        this.lockIndicator = null;
                    }
                }
            }

            updateHUD() {
                // Health and shields
                document.getElementById('playerHealthBar').style.width = this.health + '%';
                document.getElementById('playerShieldBar').style.width = this.shield + '%';
                document.getElementById('playerBoostBar').style.width = this.boostEnergy + '%';

                // Score
                document.getElementById('playerScore').textContent = this.score;

                // Weapon
                document.getElementById('playerWeapon').textContent = this.currentWeapon.toUpperCase();

                // Special weapon
                if (this.specialWeaponReady) {
                    document.getElementById('specialReady').textContent = 'READY';
                    document.getElementById('specialReady').classList.add('special-ready');
                } else {
                    const seconds = Math.ceil(this.specialCooldown / 60);
                    document.getElementById('specialReady').textContent = `${seconds}s`;
                    document.getElementById('specialReady').classList.remove('special-ready');
                }
            }
        }

        // ========================================
        // PROJECTILE CLASSES
        // ========================================
        class PlasmaProjectile {
            constructor(position, direction, owner) {
                this.owner = owner;
                this.damage = 20;
                this.speed = CONFIG.LASER_SPEED;
                this.velocity = direction.multiplyScalar(this.speed);

                // Create plasma bolt
                const geometry = new THREE.SphereGeometry(3, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);

                // Add glow
                const glowGeometry = new THREE.SphereGeometry(6, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.mesh.add(glow);

                scene.add(this.mesh);
            }

            update() {
                this.mesh.position.add(this.velocity);

                // Spin effect
                this.mesh.rotation.x += 0.2;
                this.mesh.rotation.y += 0.3;

                // Check boundaries
                if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                    this.destroy();
                    return false;
                }

                // Check collisions
                for (let ship of ships) {
                    if (ship !== this.owner && ship.alive) {
                        const distance = this.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < 40) {
                            ship.takeDamage(this.damage, this.owner);
                            this.createImpactEffect();
                            this.destroy();

                            if (this.owner && this.owner.isPlayer) {
                                achievementSystem.stats.totalHits++;
                            }

                            return false;
                        }
                    }
                }

                return true;
            }

            createImpactEffect() {
                effectsManager.createImpact(this.mesh.position, 0x00ff00);
            }

            destroy() {
                scene.remove(this.mesh);
            }
        }

        class LaserBeam {
            constructor(position, direction, owner) {
                this.owner = owner;
                this.damage = 10;
                this.speed = CONFIG.LASER_SPEED * 1.6;

                    this.velocity = direction.multiplyScalar(this.speed);

                // Create laser beam
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 60, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);

                // Orient beam
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                this.mesh.quaternion.copy(quaternion);

                scene.add(this.mesh);
            }

            update() {
                this.mesh.position.add(this.velocity);

                if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                    this.destroy();
                    return false;
                }

                for (let ship of ships) {
                    if (ship !== this.owner && ship.alive) {
                        const distance = this.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < 40) {
                            ship.takeDamage(this.damage, this.owner);
                            this.createImpactEffect();

                            this.destroy();

                            if (this.owner && this.owner.isPlayer) {
                                achievementSystem.stats.totalHits++;
                            }

                            return false;
                        }
                    }
                }

                return true;
            }

            createImpactEffect() {
                effectsManager.createImpact(this.mesh.position, 0x00ffff);
            }

            destroy() {
                scene.remove(this.mesh);
            }
        }

        class RocketProjectile {
            constructor(position, direction, owner) {
                this.owner = owner;
                this.damage = 50;
                this.speed = CONFIG.LASER_SPEED * 0.6;
                this.velocity = direction.multiplyScalar(this.speed);
                this.target = null;
                this.tracking = true;

                const group = new THREE.Group();

                // Rocket body
                const bodyGeometry = new THREE.CylinderGeometry(2, 3, 25, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff6600,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.5,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Warhead
                const warheadGeometry = new THREE.ConeGeometry(3, 8, 8);
                const warheadMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffaa00,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.7
                });
                const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
                warhead.position.x = 16.5;
                warhead.rotation.z = -Math.PI / 2;
                group.add(warhead);

                // Fins
                const finGeometry = new THREE.BoxGeometry(8, 0.5, 3);
                const finMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });

                for (let i = 0; i < 4; i++) {
                    const fin = new THREE.Mesh(finGeometry, finMaterial);
                    fin.position.x = -10;
                    const angle = (i / 4) * Math.PI * 2;
                    fin.position.y = Math.sin(angle) * 3;
                    fin.position.z = Math.cos(angle) * 3;
                    fin.rotation.z = angle;
                    group.add(fin);
                }

                this.mesh = group;
                this.mesh.position.copy(position);

                // Initial orientation
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
                this.mesh.quaternion.copy(quaternion);

                scene.add(this.mesh);

                // Find initial target
                this.findTarget();
            }

            findTarget() {
                if (!this.tracking) return;

                let nearestDist = Infinity;
                let nearestShip = null;

                ships.forEach(ship => {
                    if (ship !== this.owner && ship.alive && ship.team !== this.owner.team) {
                        const dist = this.mesh.position.distanceTo(ship.mesh.position);
                        if (dist < nearestDist && dist < 500) {
                            nearestDist = dist;
                            nearestShip = ship;
                        }
                    }
                });

                this.target = nearestShip;
            }

            update() {
                // Smoke trail
                if (Math.random() < 0.5) {
                    this.createSmokeTrail();
                }

                // Tracking
                if (this.tracking && this.target && this.target.alive) {
                    const toTarget = new THREE.Vector3();
                    toTarget.subVectors(this.target.mesh.position, this.mesh.position);
                    toTarget.normalize();

                    const turnSpeed = 0.04;
                    this.velocity.lerp(toTarget.multiplyScalar(this.speed), turnSpeed);
                }

                this.mesh.position.add(this.velocity);

                // Update orientation
                const lookAtPos = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(lookAtPos);
                this.mesh.rotateZ(Math.PI / 2);

                // Check boundaries
                if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                    this.destroy();
                    return false;
                }

                // Check collisions
                for (let ship of ships) {
                    if (ship !== this.owner && ship.alive) {
                        const distance = this.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < 40) {
                            this.explode();
                            return false;
                        }
                    }
                }

                // Ground impact
                if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                    this.explode();
                    return false;
                }

                return true;
            }

            createSmokeTrail() {
                const smokeGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 4, 4);
                const smokeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.7
                });

                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(this.mesh.position);
                smoke.position.x -= 10;
                scene.add(smoke);

                const animateSmoke = () => {
                    smoke.scale.multiplyScalar(1.05);
                    smokeMaterial.opacity *= 0.95;
                    if (smokeMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateSmoke);
                    } else {
                        scene.remove(smoke);
                    }
                };
                animateSmoke();
            }

            explode() {
                // Area damage
                const blastRadius = 100;
                ships.forEach(ship => {
                    if (ship !== this.owner && ship.alive) {
                        const distance = this.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < blastRadius) {
                            const damage = Math.max(0, (1 - distance / blastRadius) * this.damage);
                            ship.takeDamage(damage, this.owner);
                        }
                    }
                });

                destructionSystem.createExplosion(this.mesh.position, 50, 0xff6600, this.owner);
                this.destroy();
            }

            destroy() {
                scene.remove(this.mesh);
            }
        }

        // ========================================
        // NUCLEAR MISSILE CLASS
        // ========================================
        class NuclearMissile {
            constructor(position, direction, owner) {
                this.owner = owner;
                this.velocity = direction.normalize().multiplyScalar(CONFIG.LASER_SPEED * 0.5);
                this.target = null;
                this.lifetime = 0;
                this.maxLifetime = 400;

                const group = new THREE.Group();

                // Missile body
                const bodyGeometry = new THREE.CylinderGeometry(4, 6, 80, 12);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.3,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Nuclear warhead
                const warheadGeometry = new THREE.ConeGeometry(6, 20, 12);
                const warheadMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    metalness: 0.9
                });
                const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
                warhead.position.x = 50;
                warhead.rotation.z = -Math.PI / 2;
                group.add(warhead);

                // Radiation symbol
                const symbolGeometry = new THREE.RingGeometry(8, 10, 3);
                const symbolMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    side: THREE.DoubleSide
                });
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.x = 0;
                group.add(symbol);

                // Warning stripes
                for (let i = 0; i < 3; i++) {
                    const stripeGeometry = new THREE.BoxGeometry(12, 3, 85);
                    const stripeMaterial = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0xffff00 : 0x000000
                    });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.x = -20 + i * 15;
                    stripe.rotation.z = Math.PI / 4;
                    group.add(stripe);
                }

                // Engine
                const engineGeometry = new THREE.CylinderGeometry(5, 7, 15, 8);
                const engineMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.7
                });
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.position.x = -47.5;
                engine.rotation.z = Math.PI / 2;
                group.add(engine);

                this.mesh = group;
                this.mesh.position.copy(position);

                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
                this.mesh.quaternion.copy(quaternion);

                // Warning light
                this.warningLight = new THREE.PointLight(0xff0000, 5, 200);
                this.warningLight.position.copy(position);
                scene.add(this.warningLight);

                // Warning beacon
                const beaconGeometry = new THREE.SphereGeometry(5, 8, 8);
                const beaconMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                this.beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
                group.add(this.beacon);

                scene.add(this.mesh);

                this.findTarget();

                // Warning notification
                if (this.owner !== playerShip) {
                    audioSystem.play('warning');
                    showNotification('‚ö†Ô∏è NUCLEAR MISSILE DETECTED!', '#ff0000');
                }
            }

            findTarget() {
                let nearestDist = Infinity;
                let nearestShip = null;

                ships.forEach(ship => {
                    if (ship !== this.owner && ship.alive && ship.team !== this.owner.team) {
                        const dist = this.mesh.position.distanceTo(ship.mesh.position);

                        // Prioritize player
                        const priority = ship.isPlayer ? 0.5 : 1;
                        const adjustedDist = dist * priority;

                        if (adjustedDist < nearestDist) {
                            nearestDist = adjustedDist;
                            nearestShip = ship;
                        }
                    }
                });

                this.target = nearestShip;
            }

            update() {
                this.lifetime++;

                if (this.lifetime > this.maxLifetime) {
                    this.explode();
                    return false;
                }

                // Update target
                if (!this.target || !this.target.alive) {
                    this.findTarget();
                }

                // Advanced homing
                if (this.target) {
                    const toTarget = new THREE.Vector3();
                    toTarget.subVectors(this.target.mesh.position, this.mesh.position);

                    // Predict target position
                    const distance = toTarget.length();
                    const timeToTarget = distance / this.velocity.length();
                    const predictedPos = this.target.mesh.position.clone();
                    predictedPos.add(this.target.velocity.clone().multiplyScalar(timeToTarget * 30));

                    toTarget.subVectors(predictedPos, this.mesh.position);
                    toTarget.normalize();

                    const turnSpeed = 0.03;
                    this.velocity.lerp(toTarget.multiplyScalar(this.velocity.length()), turnSpeed);
                }

                // Accelerate over time
                if (this.lifetime > 60) {
                    this.velocity.multiplyScalar(1.01);
                }

                this.mesh.position.add(this.velocity);

                // Update orientation
                const lookAtPos = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(lookAtPos);
                this.mesh.rotateZ(Math.PI / 2);

                // Update warning light
                this.warningLight.position.copy(this.mesh.position);
                this.warningLight.intensity = 5 + Math.sin(Date.now() * 0.01) * 3;

                // Beacon pulsing
                const pulse = Math.sin(Date.now() * 0.01);
                this.beacon.scale.set(1 + pulse * 0.5, 1 + pulse * 0.5, 1 + pulse * 0.5);
                this.beacon.material.opacity = 0.5 + pulse * 0.3;

                // Engine trail
                if (this.lifetime % 2 === 0) {
                    this.createEngineTrail();
                }

                // Check for impact
                if (this.target) {
                    const distance = this.mesh.position.distanceTo(this.target.mesh.position);
                    if (distance < 60) {
                        this.explode();
                        return false;
                    }
                }

                // Ground impact
                if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                    this.explode();
                    return false;
                }

                return true;
            }

            createEngineTrail() {
                const trailGeometry = new THREE.SphereGeometry(4, 6, 6);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(this.mesh.position);
                trail.position.x -= 40;
                scene.add(trail);

                const animateTrail = () => {
                    trail.scale.multiplyScalar(1.08);
                    trailMaterial.opacity *= 0.93;

                    if (trailMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateTrail);
                    } else {
                        scene.remove(trail);
                    }
                };
                animateTrail();
            }

            explode() {
                const blastCenter = this.mesh.position.clone();

                // Nuclear flash
                effectsManager.createNuclearBlast(blastCenter);

                // Massive damage
                const blastRadius = 800;
                let casualties = 0;

                ships.forEach(ship => {
                    if (ship.alive) {
                        const distance = blastCenter.distanceTo(ship.mesh.position);
                        if (distance < blastRadius) {
                            const damageFactor = 1 - (distance / blastRadius);
                            const damage = Math.max(0, damageFactor * 400);
                            ship.takeDamage(damage, this.owner);

                            if (!ship.alive) casualties++;

                            // Blast force
                            if (ship.alive) {
                                const blastDirection = new THREE.Vector3()
                                    .subVectors(ship.mesh.position, blastCenter)
                                    .normalize();
                                const force = damageFactor * 60;
                                ship.velocity.add(blastDirection.multiplyScalar(force));
                            }
                        }
                    }
                });

                // Achievement check
                if (casualties >= 3 && this.owner && this.owner.isPlayer) {
                    achievementSystem.unlock('nuclearWarfare');
                }

                // Score bonus
                if (this.owner) {
                    this.owner.score += casualties * 200;
                }

                this.destroy();
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.warningLight);
            }
        }

        // ========================================
        // POWER-UP CLASS
        // ========================================
        class Powerup {
            constructor(position, type) {
                this.type = type;
                this.position = position.clone();
                this.collected = false;
                this.lifetime = 600;
                this.value = 0;

                const group = new THREE.Group();

                // Main container
                const geometry = new THREE.OctahedronGeometry(18, 0);
                const material = new THREE.MeshPhongMaterial({
                    color: this.getColor(),
                    emissive: this.getColor(),
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const container = new THREE.Mesh(geometry, material);
                group.add(container);

                // Inner core
                const coreGeometry = new THREE.OctahedronGeometry(10, 0);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                // Outer glow
                const glowGeometry = new THREE.SphereGeometry(30, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: this.getColor(),
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                group.add(glow);

                // Rotating rings
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.TorusGeometry(25 + i * 5, 2, 8, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: this.getColor(),
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = (i * Math.PI) / 3;
                    group.add(ring);

                    // Store for animation
                    ring.userData = { index: i };
                }

                this.mesh = group;
                this.mesh.position.copy(position);
                scene.add(this.mesh);

                // Point light
                this.light = new THREE.PointLight(this.getColor(), 2, 150);
                this.light.position.copy(position);
                scene.add(this.light);

                // Symbol
                this.createSymbol(container);

                // Particle field
                this.createParticleField();
            }

            getColor() {
                switch (this.type) {
                    case 'health': return 0x00ff00;
                    case 'shield': return 0x00ffff;
                    case 'weapon': return 0xff00ff;
                    case 'boost': return 0xffaa00;
                    default: return 0xffffff;
                }
            }

            createSymbol(container) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, 128, 128);

                // Symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 72px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let symbol = '';
                switch (this.type) {
                    case 'health': symbol = '+'; break;
                    case 'shield': symbol = '‚óä'; break;
                    case 'weapon': symbol = '‚òÖ'; break;
                    case 'boost': symbol = '‚ö°'; break;
                }

                ctx.fillText(symbol, 64, 64);

                const texture = new THREE.CanvasTexture(canvas);
                const symbolMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });

                const symbolGeometry = new THREE.PlaneGeometry(15, 15);
                const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbolMesh.position.z = 20;
                container.add(symbolMesh);
            }

            createParticleField() {
                this.particles = [];

                for (let i = 0; i < 20; i++) {
                    const particleGeometry = new THREE.SphereGeometry(1, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: this.getColor(),
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending
                    });

                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                    // Random position around powerup
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 30 + Math.random() * 20;
                    particle.position.x = Math.cos(angle) * radius;
                    particle.position.z = Math.sin(angle) * radius;
                    particle.position.y = (Math.random() - 0.5) * 40;

                    particle.userData = {
                        angle: angle,
                        radius: radius,
                        speed: 0.5 + Math.random() * 0.5,
                        yOffset: particle.position.y
                    };

                    this.mesh.add(particle);
                    this.particles.push(particle);
                }
            }

            update() {
                this.lifetime--;

                // Main rotation
                this.mesh.rotation.y += 0.02;

                // Individual ring rotations
                this.mesh.children.forEach(child => {
                    if (child.userData.index !== undefined) {
                        const speed = 0.03 * (1 + child.userData.index * 0.5);
                        child.rotation.z += speed;
                        child.rotation.y += speed * 0.5;
                    }
                });

                // Core pulsing
                const core = this.mesh.children[1];
                if (core) {
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.3;
                    core.scale.set(pulse, pulse, pulse);
                }

                // Floating motion
                this.mesh.position.y += Math.sin(Date.now() * 0.003) * 0.5;

                // Update light
                this.light.position.copy(this.mesh.position);
                this.light.intensity = 2 + Math.sin(Date.now() * 0.01) * 0.5;

                // Update particles
                this.particles.forEach(particle => {
                    particle.userData.angle += particle.userData.speed * 0.02;
                    particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                    particle.position.z = Math.sin(particle.userData.angle) * particle.userData.radius;
                    particle.position.y = particle.userData.yOffset + Math.sin(Date.now() * 0.001 + particle.userData.angle) * 5;
                });

                // Check collection
                ships.forEach(ship => {
                    if (ship.alive && !this.collected) {
                        const distance = ship.mesh.position.distanceTo(this.mesh.position);
                        if (distance < 60) {
                            this.collect(ship);
                        }
                    }
                });

                // Fade out when expiring
                if (this.lifetime < 60) {
                    const opacity = this.lifetime / 60;
                    this.mesh.children[0].material.opacity = opacity * 0.8;
                    this.mesh.children[2].material.opacity = opacity * 0.2;
                    this.light.intensity *= 0.95;
                }

                return this.lifetime > 0 && !this.collected;
            }

            collect(ship) {
                this.collected = true;

                let message = '';
                let value = 0;

                switch (this.type) {
                    case 'health':
                        const healthBoost = 30;
                        const oldHealth = ship.health;
                        ship.health = Math.min(CONFIG.SHIP_HP, ship.health + healthBoost);
                        value = ship.health - oldHealth;
                        message = `+${value} HEALTH`;
                        break;

                    case 'shield':
                        const oldShield = ship.shield;
                        ship.shield = CONFIG.SHIELD_HP;
                        value = ship.shield - oldShield;
                        message = 'SHIELD RECHARGED';
                        break;

                    case 'weapon':
                        if (ship.isPlayer) {
                            ship.switchWeapon();
                            message = 'WEAPON UPGRADED';
                        } else {
                            ship.score += 50;
                            message = '+50 POINTS';
                        }
                        value = 50;
                        break;

                    case 'boost':
                        const oldBoost = ship.boostEnergy;
                        ship.boostEnergy = CONFIG.BOOST_MAX;
                        value = ship.boostEnergy - oldBoost;
                        message = 'BOOST RECHARGED';
                        break;
                }

                // Visual effect
                this.createCollectEffect();

                // Notification
                if (ship.isPlayer || ship === playerShip) {
                    showNotification(`‚ú® ${message}`, this.getColor());
                    achievementSystem.stats.powerupsCollected++;
                    achievementSystem.checkAchievement('powerup');
                }

                // Score
                ship.score += 25;

                audioSystem.play('powerup');
                this.destroy();
            }

            createCollectEffect() {
                effectsManager.createPowerupCollect(this.mesh.position, this.getColor());
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.light);
            }
        }

        // ========================================
        // EFFECTS MANAGER
        // ========================================
        class EffectsManager {
            constructor() {
                this.effects = [];
            }

            createImpact(position, color) {
                const impactGeometry = new THREE.SphereGeometry(20, 8, 8);
                const impactMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });

                const impact = new THREE.Mesh(impactGeometry, impactMaterial);
                impact.position.copy(position);
                scene.add(impact);

                // Sparks
                for (let i = 0; i < 10; i++) {
                    const sparkGeometry = new THREE.BoxGeometry(2, 2, 8);
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    spark.position.copy(position);

                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 30
                    );

                    scene.add(spark);

                    const animateSpark = () => {
                        spark.position.add(velocity.clone().multiplyScalar(0.1));
                        velocity.y -= 0.5;
                        spark.rotation.x += 0.2;
                        spark.rotation.y += 0.2;
                        sparkMaterial.opacity *= 0.9;
                        spark.scale.multiplyScalar(0.95);

                        if (sparkMaterial.opacity > 0.01) {
                            requestAnimationFrame(animateSpark);
                        } else {
                            scene.remove(spark);
                        }
                    };
                    animateSpark();
                }

                const animateImpact = () => {
                    impact.scale.multiplyScalar(1.2);
                    impactMaterial.opacity *= 0.8;

                    if (impactMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateImpact);
                    } else {
                        scene.remove(impact);
                    }
                };
                animateImpact();
            }

            createPowerupCollect(position, color) {
                // Energy wave
                const waveGeometry = new THREE.SphereGeometry(1, 16, 16);
                const waveMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                const wave = new THREE.Mesh(waveGeometry, waveMaterial);
                wave.position.copy(position);
                scene.add(wave);

                // Particles
                for (let i = 0; i < 30; i++) {
                    const particleGeometry = new THREE.SphereGeometry(2, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1,
                        blending: THREE.AdditiveBlending
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(position);

                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40
                    );

                    scene.add(particle);

                    const animateParticle = () => {
                        particle.position.add(velocity.clone().multiplyScalar(0.1));
                        velocity.multiplyScalar(0.92);
                        particleMaterial.opacity *= 0.94;
                        particle.scale.multiplyScalar(0.96);

                        if (particleMaterial.opacity > 0.01) {
                            requestAnimationFrame(animateParticle);
                        } else {
                            scene.remove(particle);
                        }
                    };
                    animateParticle();
                }

                const animateWave = () => {
                    wave.scale.multiplyScalar(1.3);
                    waveMaterial.opacity *= 0.85;

                    if (waveMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateWave);
                    } else {
                        scene.remove(wave);
                    }
                };
                animateWave();
            }

            createNuclearBlast(position) {
                // Blinding flash
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'white';
                flash.style.opacity = '0.8';
                flash.style.pointerEvents = 'none';
                flash.style.zIndex = '999';
                document.body.appendChild(flash);

                setTimeout(() => {
                    flash.style.transition = 'opacity 0.5s';
                    flash.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(flash), 500);
                }, 100);

                // Mushroom cloud
                const mushroomGroup = new THREE.Group();

                // Stem
                const stemGeometry = new THREE.CylinderGeometry(60, 120, 400, 16);
                const stemMaterial = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.3
                });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = 200;
                mushroomGroup.add(stem);

                // Cap
                const capGeometry = new THREE.SphereGeometry(200, 16, 12);
                const capMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.4
                });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = 400;
                cap.scale.y = 0.5;
                mushroomGroup.add(cap);

                mushroomGroup.position.copy(position);
                scene.add(mushroomGroup);

                // Multiple shockwaves
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const shockwaveGeometry = new THREE.RingGeometry(1, 50 + i * 30, 64);
                        const shockwaveMaterial = new THREE.MeshBasicMaterial({
                            color: i === 0 ? 0xffffff : 0xffaa00,
                            transparent: true,
                            opacity: 0.8 - i * 0.1,
                            side: THREE.DoubleSide,
                            blending: THREE.AdditiveBlending
                        });
                        const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                        shockwave.position.copy(position);
                        shockwave.position.y += i * 50;
                        shockwave.rotation.x = -Math.PI / 2;
                        scene.add(shockwave);

                        const animateShockwave = () => {
                            shockwave.scale.multiplyScalar(1.15);
                            shockwaveMaterial.opacity *= 0.94;

                            if (shockwaveMaterial.opacity > 0.01) {
                                requestAnimationFrame(animateShockwave);
                            } else {
                                scene.remove(shockwave);
                            }
                        };
                        animateShockwave();
                    }, i * 100);
                }

                // Fireball
                const fireballGeometry = new THREE.SphereGeometry(180, 32, 32);
                const fireballMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
                fireball.position.copy(position);
                scene.add(fireball);

                // Radioactive particles
                for (let i = 0; i < 200; i++) {
                    const particleGeometry = new THREE.SphereGeometry(5 + Math.random() * 20, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0x00ff00 : 0xffff00,
                        transparent: true,
                        opacity: 1,
                        blending: THREE.AdditiveBlending
                    });

                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(position);
                    particle.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 200,
                        Math.random() * 100,
                        (Math.random() - 0.5) * 200
                    ));

                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 60,
                        Math.random() * 40 + 30,
                        (Math.random() - 0.5) * 60
                    );

                    scene.add(particle);

                    const animateParticle = () => {
                        particle.position.add(velocity.clone().multiplyScalar(0.1));
                        velocity.y -= 0.8;
                        particleMaterial.opacity *= 0.98;
                        particle.scale.multiplyScalar(0.98);

                        if (particleMaterial.opacity > 0.01 && particle.position.y > -100) {
                            requestAnimationFrame(animateParticle);
                        } else {
                            scene.remove(particle);
                        }
                    };
                    animateParticle();
                }

                // Animate nuclear explosion
                let frame = 0;
                const animateNuclear = () => {
                    frame++;

                    // Fireball expansion
                    fireball.scale.multiplyScalar(1.08);
                    fireballMaterial.opacity *= 0.96;

                    // Mushroom cloud rise
                    if (frame > 30) {
                        mushroomGroup.position.y += 3;
                        stem.scale.y *= 1.01;
                        cap.scale.x *= 1.005;
                        cap.scale.z *= 1.005;
                    }

                    if (frame < 300) {
                        requestAnimationFrame(animateNuclear);
                    } else {
                        scene.remove(fireball);

                        // Fade out mushroom cloud
                        const fadeMushroom = () => {
                            stemMaterial.opacity *= 0.98;
                            capMaterial.opacity *= 0.98;

                            if (stemMaterial.opacity > 0.01) {
                                requestAnimationFrame(fadeMushroom);
                            } else {
                                scene.remove(mushroomGroup);
                            }
                        };
                        setTimeout(fadeMushroom, 2000);
                    }
                };
                animateNuclear();

                // Multiple explosion sounds
                audioSystem.play('explosion');
                setTimeout(() => audioSystem.play('explosion'), 300);
                setTimeout(() => audioSystem.play('explosion'), 700);

                // Screen shake
                destructionSystem.screenShake(20);
            }
        }

        // ========================================
        // GAME INITIALIZATION
        // ========================================
        function init() {
            // Show loading screen
            showLoadingTip();

            // Initialize systems
            audioSystem = new AudioSystem();
            comboSystem = new ComboSystem();
            achievementSystem = new AchievementSystem();
            rankSystem = new RankSystem();
            destructionSystem = new DestructionSystem();
            weatherSystem = new WeatherSystem();
            effectsManager = new EffectsManager();

            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xB0E0E6, 100, 2000);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                5000
            );
            camera.position.set(0, 300, 600);
            camera.lookAt(0, 100, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // Create environment
            createEnvironment();

            // Create lighting
            createLighting();

            // Setup controls
            setupEventListeners();

            // Hide loading and show menu
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            }, 3000);

            // Start animation loop
            animate();
        }

        function showLoadingTip() {
            let tipIndex = 0;
            const tipElement = document.getElementById('loadingTip');

            const changeTip = () => {
                tipElement.style.opacity = '0';
                setTimeout(() => {
                    tipElement.textContent = loadingTips[tipIndex];
                    tipElement.style.opacity = '1';
                    tipIndex = (tipIndex + 1) % loadingTips.length;
                }, 500);
            };

            setInterval(changeTip, 2000);
        }

        // ========================================
        // ENVIRONMENT CREATION
        // ========================================
        function createEnvironment() {
            // Ocean with realistic waves
            const oceanGeometry = new THREE.PlaneGeometry(2000, 2000, 256, 256);
            const oceanMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100,
                specular: 0x111111,
                side: THREE.DoubleSide
            });

            // Create wave vertices
            const vertices = oceanGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                vertices[i + 2] = Math.sin(x * 0.01) * 5 + Math.cos(y * 0.01) * 5;
            }
            oceanGeometry.attributes.position.needsUpdate = true;
            oceanGeometry.computeVertexNormals();

            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.z = -1000;
            ocean.receiveShadow = true;
            ocean.name = 'ocean';
            scene.add(ocean);

            // Mainland
            const landGeometry = new THREE.PlaneGeometry(3000, 2000, 50, 50);
            const landMaterial = new THREE.MeshPhongMaterial({
                color: 0x3a5f3a,
                roughness: 0.8,
                metalness: 0.2
            });

            // Add terrain variation
            const landVertices = landGeometry.attributes.position.array;
            for (let i = 0; i < landVertices.length; i += 3) {
                const x = landVertices[i];
                const y = landVertices[i + 1];
                const distance = Math.sqrt(x * x + y * y);
                landVertices[i + 2] = Math.sin(distance * 0.003) * 20 + Math.random() * 5;
            }
            landGeometry.attributes.position.needsUpdate = true;
            landGeometry.computeVertexNormals();

            const land = new THREE.Mesh(landGeometry, landMaterial);
            land.rotation.x = -Math.PI / 2;
            land.position.z = 1000;
            land.receiveShadow = true;
            scene.add(land);

            // Sky dome
            const skyGeometry = new THREE.SphereGeometry(3000, 64, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },
                    bottomColor: { value: new THREE.Color(0xB0E0E6) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
                fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(h, exponent), 0.0)), 1.0);
                }
            `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Create city
            createCity();

            // Create nature
            createNature();

            // Create clouds
            createClouds();
        }

        function createCity() {
            const cityGroup = new THREE.Group();
            const buildingMaterials = [];

            // Create building materials
            for (let i = 0; i < 5; i++) {
                buildingMaterials.push(new THREE.MeshPhongMaterial({
                    color: new THREE.Color(
                        0.3 + Math.random() * 0.2,
                        0.3 + Math.random() * 0.2,
                        0.3 + Math.random() * 0.2
                    ),
                    emissive: 0x222222,
                    emissiveIntensity: 0.2,
                    metalness: 0.7,
                    roughness: 0.3
                }));
            }

            // Create buildings
            for (let i = 0; i < 80; i++) {
                const width = 30 + Math.random() * 70;
                const height = 60 + Math.random() * 240;
                const depth = 30 + Math.random() * 70;

                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];
                const building = new THREE.Mesh(buildingGeometry, material);

                building.position.x = (Math.random() - 0.5) * 1500;
                building.position.y = height / 2;
                building.position.z = 200 + Math.random() * 800;
                building.castShadow = true;
                building.receiveShadow = true;

                cityGroup.add(building);

                // Windows
                const windowRows = Math.floor(height / 15);
                const windowCols = Math.floor(width / 10);

                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowCols; col++) {
                        if (Math.random() > 0.3) {
                            const windowGeometry = new THREE.PlaneGeometry(6, 8);
                            const windowMaterial = new THREE.MeshBasicMaterial({
                                color: Math.random() > 0.8 ? 0xffffaa : 0x444444,
                                emissive: Math.random() > 0.8 ? 0xffffaa : 0x000000,
                                emissiveIntensity: 0.5
                            });
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);

                            window.position.copy(building.position);
                            window.position.y = row * 15 - height / 2 + 20;
                            window.position.x += (col - windowCols / 2) * 10;
                            window.position.z -= depth / 2 + 0.1;

                            cityGroup.add(window);
                        }
                    }
                }

                // Rooftop details
                if (Math.random() > 0.5) {
                    const antennaGeometry = new THREE.CylinderGeometry(1, 1, 30, 4);
                    const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.copy(building.position);
                    antenna.position.y += height / 2 + 15;
                    cityGroup.add(antenna);

                    // Blinking light
                    const lightGeometry = new THREE.SphereGeometry(2, 4, 4);
                    const lightMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        emissive: 0xff0000
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.copy(antenna.position);
                    light.position.y += 15;
                    cityGroup.add(light);

                    // Store for animation
                    light.userData = { blink: true, offset: Math.random() * Math.PI * 2 };
                }
            }

            // Roads
            const roadMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                roughness: 0.8
            });

            // Main roads
            for (let i = 0; i < 5; i++) {
                const roadGeometry = new THREE.PlaneGeometry(50, 2000);
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.x = -600 + i * 300;
                road.position.y = 0.1;
                road.position.z = 600;
                cityGroup.add(road);
            }

            // Cross roads
            for (let i = 0; i < 3; i++) {
                const roadGeometry = new THREE.PlaneGeometry(1500, 50);
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.z = 200 + i * 400;
                road.position.y = 0.1;
                cityGroup.add(road);
            }

            scene.add(cityGroup);
        }

        function createNature() {
            // Trees
            const treeGroup = new THREE.Group();

            for (let i = 0; i < 200; i++) {
                const tree = new THREE.Group();

                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(3, 5, 25, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8b4513,
                    roughness: 0.8
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                tree.add(trunk);

                // Leaves
                const leavesGeometry = new THREE.SphereGeometry(20, 8, 6);
                const leavesMaterial = new THREE.MeshPhongMaterial({
                    color: 0x228b22,
                    roughness: 0.6
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 20;
                tree.add(leaves);

                // Additional leaf layers
                for (let j = 0; j < 2; j++) {
                    const extraLeaves = new THREE.Mesh(
                        new THREE.SphereGeometry(15 - j * 5, 6, 5),
                        leavesMaterial
                    );
                    extraLeaves.position.y = 30 + j * 10;
                    tree.add(extraLeaves);
                }

                tree.position.x = (Math.random() - 0.5) * 2000;
                tree.position.y = 12.5;
                tree.position.z = 800 + Math.random() * 600;
                tree.scale.set(
                    0.8 + Math.random() * 0.4,
                    0.8 + Math.random() * 0.4,
                    0.8 + Math.random() * 0.4
                );

                treeGroup.add(tree);
            }

            scene.add(treeGroup);

            // Mountains in background
            const mountainGroup = new THREE.Group();

            for (let i = 0; i < 5; i++) {
                const mountainGeometry = new THREE.ConeGeometry(
                    300 + Math.random() * 200,
                    400 + Math.random() * 300,
                    8
                );
                const mountainMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    flatShading: true
                });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);

                mountain.position.x = -1500 + i * 750;
                mountain.position.y = 200;
                mountain.position.z = 2000;
                mountain.rotation.y = Math.random() * Math.PI;

                mountainGroup.add(mountain);

                // Snow cap
                const snowGeometry = new THREE.ConeGeometry(
                    150 + Math.random() * 100,
                    100,
                    8
                );
                const snowMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.1
                });
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                snow.position.copy(mountain.position);
                snow.position.y += 250;

                mountainGroup.add(snow);
            }

            scene.add(mountainGroup);
        }

        function createClouds() {
            const cloudGroup = new THREE.Group();
            cloudGroup.name = 'clouds';

            for (let i = 0; i < 40; i++) {
                const cloud = new THREE.Group();

                const numPuffs = 4 + Math.floor(Math.random() * 4);
                for (let j = 0; j < numPuffs; j++) {
                    const puffGeometry = new THREE.SphereGeometry(
                        30 + Math.random() * 50,
                        8,
                        6
                    );
                    const puffMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const puff = new THREE.Mesh(puffGeometry, puffMaterial);

                    puff.position.x = (Math.random() - 0.5) * 80;
                    puff.position.y = (Math.random() - 0.5) * 30;
                    puff.position.z = (Math.random() - 0.5) * 80;

                    cloud.add(puff);
                }

                cloud.position.set(
                    (Math.random() - 0.5) * 3000,
                    300 + Math.random() * 300,
                    (Math.random() - 0.5) * 3000
                );

                cloud.userData = {
                    speed: 0.1 + Math.random() * 0.2,
                    originalX: cloud.position.x
                };

                cloudGroup.add(cloud);
            }

            scene.add(cloudGroup);
        }

        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
            ambientLight.name = 'ambientLight';
            scene.add(ambientLight);

            // Sun light
            const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
            sunLight.position.set(500, 800, 300);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -1000;
            sunLight.shadow.camera.right = 1000;
            sunLight.shadow.camera.top = 1000;
            sunLight.shadow.camera.bottom = -1000;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 2000;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.bias = -0.0005;
            sunLight.name = 'sunLight';
            scene.add(sunLight);

            // Hemisphere light for better ambient
            const hemiLight = new THREE.HemisphereLight(0xB0E0E6, 0x3a5f3a, 0.4);
            scene.add(hemiLight);

            // Fog light
            const fogLight = new THREE.PointLight(0xffffff, 0.5, 2000);
            fogLight.position.set(0, 500, 0);
            scene.add(fogLight);
        }

        // ========================================
        // GAME MANAGEMENT
        // ========================================
        function startBattle() {
            // Reset game state
            timer = CONFIG.BATTLE_TIME;
            ships = [];
            lasers = [];
            missiles = [];
            powerups = [];
            gameState = 'battle';
            playerShip = null;

            // Reset systems
            if (comboSystem) comboSystem.reset();
            if (weatherSystem) weatherSystem.changeWeather('clear');
            weatherTimer = 0;

            // Create ships based on game mode
            if (gameMode === 'player') {
                // Player vs AI
                playerShip = new PlayerFighterJet();
                ships.push(playerShip);

                // Create AI opponents
                for (let i = 0; i < 3; i++) {
                    const config = {
                        name: `BANDIT-${i + 1}`,
                        team: 'enemy',
                        color: 0xff0000 + Math.random() * 0x0000ff,
                        emissive: 0xff0000
                    };
                    const enemyShip = new FighterJet(config, i);
                    ships.push(enemyShip);
                }
            } else if (gameMode === 'mixed') {
                // Team battle
                playerShip = new PlayerFighterJet();
                playerShip.team = 'blue';
                ships.push(playerShip);

                // AI ally
                const allyConfig = {
                    name: 'WINGMAN',
                    team: 'blue',
                    color: 0x0088ff,
                    emissive: 0x0088ff
                };
                const ally = new FighterJet(allyConfig, 0);
                ships.push(ally);

                // Enemy team
                for (let i = 0; i < 2; i++) {
                    const config = {
                        name: `HOSTILE-${i + 1}`,
                        team: 'red',
                        color: 0xff0000 + Math.random() * 0x660000,
                        emissive: 0xff0000
                    };
                    const enemy = new FighterJet(config, i + 2);
                    ships.push(enemy);
                }
            } else{

                const teams = ['red', 'blue'];
                const teamColors = {
                    red: { color: 0xff0000, emissive: 0xff0000 },
                    blue: { color: 0x0000ff, emissive: 0x0000ff }
                };

                for (let i = 0; i < CONFIG.SHIPS; i++) {
                    const team = teams[i % 2];
                    const config = {
                        name: `${team.toUpperCase()}-${Math.floor(i / 2) + 1}`,
                        team: team,
                        color: teamColors[team].color + Math.random() * 0x333333,
                        emissive: teamColors[team].emissive
                    };
                    const ship = new FighterJet(config, i);
                    ships.push(ship);
                }
            }

            // Start game loop
            gameLoop();
        }

        function gameLoop() {
            if (gameState !== 'battle') return;

            timer--;
            updateHUD();

            // Weather changes
            weatherTimer++;
            if (weatherTimer >= CONFIG.WEATHER_CHANGE_TIME / 1000) {
                weatherTimer = 0;
                const weathers = weatherSystem.types;
                const newWeather = weathers[Math.floor(Math.random() * weathers.length)];
                weatherSystem.changeWeather(newWeather);
            }

            // Check win conditions
            const alive = ships.filter(s => s.alive);
            const aliveTeams = new Set(alive.map(s => s.team));

            if (gameMode === 'player' || gameMode === 'mixed') {
                if (playerShip && !playerShip.alive) {
                    gameState = 'ended';
                    endBattle();
                    return;
                }
            }

            if (gameMode === 'mixed' && aliveTeams.size === 1) {
                endBattle();
                return;
            } else if (alive.length <= 1 || timer <= 0) {
                endBattle();
                return;
            }

            // Spawn power-ups
            if (Math.random() < 0.01 && powerups.length < 5) {
                const types = ['health', 'shield', 'weapon', 'boost'];
                const type = types[Math.floor(Math.random() * types.length)];
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5,
                    100 + Math.random() * 150,
                    (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5
                );
                const powerup = new Powerup(position, type);
                powerups.push(powerup);
            }

            setTimeout(gameLoop, 1000);
        }

        function endBattle() {
            gameState = 'ended';

            const alive = ships.filter(s => s.alive);
            let winner = null;

            if (gameMode === 'mixed') {
                const aliveTeams = new Set(alive.map(s => s.team));
                if (aliveTeams.has('blue')) {
                    winner = playerShip && playerShip.alive ? playerShip : alive.find(s => s.team === 'blue');
                    document.getElementById('winnerName').textContent = 'VICTORY!';
                    document.getElementById('winnerName').style.color = '#00ff00';
                } else {
                    document.getElementById('winnerName').textContent = 'DEFEAT';
                    document.getElementById('winnerName').style.color = '#ff0000';
                }
            } else if (alive.length > 0) {
                winner = alive.reduce((best, ship) => ship.score > best.score ? ship : best);
                if (winner === playerShip) {
                    document.getElementById('winnerName').textContent = 'VICTORY!';
                    document.getElementById('winnerName').style.color = '#00ff00';
                } else {
                    document.getElementById('winnerName').textContent = winner.name + ' WINS';
                    document.getElementById('winnerName').style.color = '#' + winner.config.color.toString(16).padStart(6, '0');
                }
            } else {
                document.getElementById('winnerName').textContent = 'DRAW';
                document.getElementById('winnerName').style.color = '#ffff00';
            }

            // Update stats
            if (playerShip) {
                // Update achievement system
                const accuracy = achievementSystem.stats.totalShots > 0 ?
                    (achievementSystem.stats.totalHits / achievementSystem.stats.totalShots) : 0;
                achievementSystem.checkAchievement('accuracy', accuracy);

                if (playerShip.alive) {
                    achievementSystem.stats.battlesWon++;

                    if (playerShip.health === CONFIG.SHIP_HP) {
                        achievementSystem.unlock('survivor');
                    }

                    if (playerShip.health + playerShip.shield === CONFIG.SHIP_HP + CONFIG.SHIELD_HP) {
                        achievementSystem.unlock('untouchable');
                    }

                    if (timer > CONFIG.BATTLE_TIME - 120) {
                        achievementSystem.unlock('speedDemon');
                    }

                    if (playerShip.health < 10) {
                        achievementSystem.unlock('closeCall');
                    }
                } else {
                    achievementSystem.stats.battlesLost++;
                }

                // Update rank
                rankSystem.addScore(playerShip.score);

                // Save progress
                achievementSystem.stats.playtime += CONFIG.BATTLE_TIME - timer;
                achievementSystem.saveProgress();
            }

            // Display final stats
            const finalStats = {
                score: winner ? winner.score : 0,
                kills: winner ? winner.kills : 0,
                accuracy: playerShip && achievementSystem.stats.totalShots > 0 ?
                    ((achievementSystem.stats.totalHits / achievementSystem.stats.totalShots) * 100).toFixed(1) : '0',
                maxCombo: comboSystem.maxCombo,
                rank: rankSystem.getCurrentRank().name
            };

            document.getElementById('finalScore').textContent = finalStats.score;
            document.getElementById('finalKills').textContent = finalStats.kills;
            document.getElementById('finalAccuracy').textContent = finalStats.accuracy + '%';
            document.getElementById('finalCombo').textContent = finalStats.maxCombo;
            document.getElementById('finalRank').textContent = finalStats.rank;

            document.getElementById('restartText').style.display = gameMode === 'ai' ? 'block' : 'none';
            document.getElementById('menuButtons').style.display = gameMode === 'ai' ? 'none' : 'block';
            document.getElementById('winnerOverlay').style.display = 'flex';

            // Auto-restart for AI mode
            if (gameMode === 'ai') {
                let countdown = 5;
                const countInterval = setInterval(() => {
                    countdown--;
                    document.getElementById('countdown').textContent = countdown;
                    if (countdown <= 0) {
                        clearInterval(countInterval);
                        document.getElementById('winnerOverlay').style.display = 'none';
                        cleanupBattle();
                        startBattle();
                    }
                }, 1000);
            }
        }

        function cleanupBattle() {
            // Remove ships
            ships.forEach(ship => {
                if (ship.mesh) scene.remove(ship.mesh);
                if (ship.engineSound) audioSystem.stopEngineSound(ship);
                if (ship.lockIndicator) scene.remove(ship.lockIndicator);
            });

            // Remove projectiles
            lasers.forEach(laser => {
                if (laser.mesh) scene.remove(laser.mesh);
            });

            // Remove missiles
            missiles.forEach(missile => {
                if (missile.destroy) missile.destroy();
            });

            // Remove powerups
            powerups.forEach(powerup => {
                if (powerup.destroy) powerup.destroy();
            });

            // Clean up destruction system
            if (destructionSystem) {
                destructionSystem.cleanup();
            }

            // Reset arrays
            ships = [];
            lasers = [];
            missiles = [];
            powerups = [];
        }

        function updateHUD() {
            // Timer
            const minutes = Math.floor(timer / 60);
            const seconds = timer % 60;
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Alive count
            const alive = ships ? ships.filter(s => s && s.alive) : [];
            const aliveElement = document.getElementById('aliveCount');
            if (aliveElement) {
                aliveElement.textContent = `Ships Alive: ${alive.length}`;
            }

            // Update radar
            if (playerShip && playerShip.alive && gameMode !== 'ai') {
                updateRadar();
            }

            // Update player HUD if needed
            if (playerShip && playerShip.alive) {
                // Boost bar update
                const boostBar = document.getElementById('playerBoostBar');
                if (boostBar) {
                    boostBar.style.width = playerShip.boostEnergy + '%';
                }
            }
        }

        function updateRadar() {
            const radarElement = document.getElementById('radar');
            if (!radarElement) return;

            // Clear previous blips
            const oldBlips = radarElement.querySelectorAll('.radar-blip');
            oldBlips.forEach(blip => blip.remove());

            ships.forEach(ship => {
                if (ship !== playerShip && ship.alive) {
                    const relativePos = new THREE.Vector3().subVectors(ship.mesh.position, playerShip.mesh.position);
                    const distance = relativePos.length();

                    if (distance < 1000) {
                        // Convert to radar coordinates
                        const angle = Math.atan2(relativePos.z, relativePos.x) - playerShip.mesh.rotation.y;
                        const radarDistance = Math.min(distance / 1000, 1) * 90;

                        const blip = document.createElement('div');
                        blip.className = 'radar-blip';
                        blip.style.position = 'absolute';
                        blip.style.width = '6px';
                        blip.style.height = '6px';
                        blip.style.borderRadius = '50%';
                        blip.style.backgroundColor = ship.team === playerShip.team ? '#00ff00' : '#ff0000';
                        blip.style.boxShadow = `0 0 10px ${ship.team === playerShip.team ? '#00ff00' : '#ff0000'}`;
                        blip.style.left = (125 + Math.cos(angle) * radarDistance) + 'px';
                        blip.style.top = (125 + Math.sin(angle) * radarDistance) + 'px';
                        blip.style.transform = 'translate(-50%, -50%)';

                        radarElement.appendChild(blip);
                    }
                }
            });

            // Add powerup blips
            powerups.forEach(powerup => {
                const relativePos = new THREE.Vector3().subVectors(powerup.mesh.position, playerShip.mesh.position);
                const distance = relativePos.length();

                if (distance < 1000) {
                    const angle = Math.atan2(relativePos.z, relativePos.x) - playerShip.mesh.rotation.y;
                    const radarDistance = Math.min(distance / 1000, 1) * 90;

                    const blip = document.createElement('div');
                    blip.className = 'radar-blip';
                    blip.style.position = 'absolute';
                    blip.style.width = '8px';
                    blip.style.height = '8px';
                    blip.style.borderRadius = '50%';
                    blip.style.backgroundColor = powerup.getColor();
                    blip.style.boxShadow = `0 0 15px ${powerup.getColor()}`;
                    blip.style.left = (125 + Math.cos(angle) * radarDistance) + 'px';
                    blip.style.top = (125 + Math.sin(angle) * radarDistance) + 'px';
                    blip.style.transform = 'translate(-50%, -50%)';
                    blip.style.animation = 'pulse 1s infinite';

                    radarElement.appendChild(blip);
                }
            });
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================
        function setupEventListeners() {
            // Menu buttons
            document.getElementById('btnPlayerMode').addEventListener('click', () => {
                gameMode = 'player';
                startPlayerMode();
            });

            document.getElementById('btnMixedMode').addEventListener('click', () => {
                gameMode = 'mixed';
                startMixedMode();
            });

            document.getElementById('btnAIMode').addEventListener('click', () => {
                gameMode = 'ai';
                startAIMode();
            });

            document.getElementById('btnSettings').addEventListener('click', () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'block';
            });

            document.getElementById('btnCredits').addEventListener('click', () => {
                showCredits();
            });

            document.getElementById('btnRestart').addEventListener('click', restartBattle);
            document.getElementById('btnMenu').addEventListener('click', returnToMenu);

            // Settings
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                audioSystem.setMasterVolume(volume);
            });

            document.getElementById('graphicsQuality').addEventListener('change', (e) => {
                updateGraphicsQuality(e.target.value);
            });

            document.getElementById('showFPS').addEventListener('change', (e) => {
                document.getElementById('perfStats').style.display = e.target.checked ? 'block' : 'none';
            });

            document.getElementById('particleEffects').addEventListener('change', (e) => {
                CONFIG.PARTICLE_COUNT = e.target.checked ? 200 : 50;
                CONFIG.DEBRIS_COUNT = e.target.checked ? 50 : 20;
            });

            // Player controls
            setupPlayerControls();

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Mobile controls
            setupMobileControls();

            // Debug keys
            setupDebugKeys();
        }

        function startPlayerMode() {
            console.log('Starting Player Mode');
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('playerHUD').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('radar').style.display = 'block';
            document.getElementById('rankDisplay').style.display = 'block';

            // Small delay to ensure everything is ready
            setTimeout(() => {
                startBattle();
            }, 100);
        }

        function startMixedMode() {
            console.log('Starting Mixed Mode');
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('playerHUD').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('radar').style.display = 'block';
            document.getElementById('rankDisplay').style.display = 'block';

            // Small delay to ensure everything is ready
            setTimeout(() => {
                startBattle();
            }, 100);
        }

        function startAIMode() {
            console.log('Starting AI Mode');
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            // Small delay to ensure everything is ready
            setTimeout(() => {
                startBattle();
            }, 100);
        }

        function restartBattle() {
            document.getElementById('winnerOverlay').style.display = 'none';
            cleanupBattle();
            startBattle();
        }

        function returnToMenu() {
            gameState = 'menu';
            cleanupBattle();
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('playerHUD').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('radar').style.display = 'none';
            document.getElementById('rankDisplay').style.display = 'none';
            document.getElementById('winnerOverlay').style.display = 'none';
        }

        function closeSettings() {
            document.getElementById('settingsMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        }

        function showCredits() {
            showNotification('Sky Warriors - Created by Claude AI', '#ffd700');
            showNotification('Thanks for playing!', '#00ff00');
        }

        function updateGraphicsQuality(quality) {
            switch (quality) {
                case 'low':
                    renderer.shadowMap.enabled = false;
                    CONFIG.PARTICLE_COUNT = 50;
                    CONFIG.DEBRIS_COUNT = 20;
                    break;

                case 'medium':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFShadowMap;
                    CONFIG.PARTICLE_COUNT = 100;
                    CONFIG.DEBRIS_COUNT = 35;
                    break;

                case 'high':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    CONFIG.PARTICLE_COUNT = 150;
                    CONFIG.DEBRIS_COUNT = 50;
                    break;

                case 'ultra':
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    CONFIG.PARTICLE_COUNT = 200;
                    CONFIG.DEBRIS_COUNT = 50;
                    renderer.antialias = true;
                    break;
            }
        }

        function setupPlayerControls() {
            document.addEventListener('keydown', (e) => {
                if (!playerShip || !playerShip.alive || gameState !== 'battle') return;

                switch (e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        playerShip.keys.up = true;
                        e.preventDefault();
                        break;
                    case 's':
                    case 'arrowdown':
                        playerShip.keys.down = true;
                        e.preventDefault();
                        break;
                    case 'a':
                    case 'arrowleft':
                        playerShip.keys.left = true;
                        e.preventDefault();
                        break;
                    case 'd':
                    case 'arrowright':
                        playerShip.keys.right = true;
                        e.preventDefault();
                        break;
                    case ' ':
                        playerShip.keys.fire = true;
                        e.preventDefault();
                        break;
                    case 'shift':
                        playerShip.keys.boost = true;
                        e.preventDefault();
                        break;
                    case 'e':
                        playerShip.keys.special = true;
                        e.preventDefault();
                        break;
                    case 'q':
                        if (!playerShip.weaponSwitchCooldown) {
                            playerShip.keys.switchWeapon = true;
                            e.preventDefault();
                        }
                        break;
                    case 'tab':
                        playerShip.keys.targetLock = true;
                        e.preventDefault();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (!playerShip || !playerShip.alive) return;

                switch (e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        playerShip.keys.up = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        playerShip.keys.down = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        playerShip.keys.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        playerShip.keys.right = false;
                        break;
                    case ' ':
                        playerShip.keys.fire = false;
                        break;
                    case 'shift':
                        playerShip.keys.boost = false;
                        audioSystem.stopBoostSound();
                        break;
                    case 'e':
                        playerShip.keys.special = false;
                        break;
                    case 'q':
                        playerShip.keys.switchWeapon = false;
                        break;
                    case 'tab':
                        playerShip.keys.targetLock = false;
                        break;
                }
            });

            // Mouse controls
            let mouseDown = false;
            document.addEventListener('mousedown', (e) => {
                if (!playerShip || !playerShip.alive || gameState !== 'battle') return;
                if (e.button === 0) {
                    mouseDown = true;
                    playerShip.keys.fire = true;
                } else if (e.button === 2) {
                    playerShip.keys.targetLock = true;
                    e.preventDefault();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (!playerShip || !playerShip.alive) return;
                if (e.button === 0) {
                    mouseDown = false;
                    playerShip.keys.fire = false;
                } else if (e.button === 2) {
                    playerShip.keys.targetLock = false;
                }
            });

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!playerShip || !playerShip.alive || !playerShip.mouse.enabled) return;

                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                playerShip.mouse.x = (e.clientX - centerX) / centerX;
                playerShip.mouse.y = (e.clientY - centerY) / centerY;
            });

            // Wheel for weapon switching
            document.addEventListener('wheel', (e) => {
                if (!playerShip || !playerShip.alive || gameState !== 'battle') return;

                if (e.deltaY > 0) {
                    playerShip.switchWeapon();
                } else {
                    // Switch to previous weapon
                    const weapons = ['plasma', 'laser', 'rocket'];
                    const currentIndex = weapons.indexOf(playerShip.currentWeapon);
                    const prevIndex = (currentIndex - 1 + weapons.length) % weapons.length;
                    playerShip.currentWeapon = weapons[prevIndex];
                    playerShip.switchWeapon(playerShip.currentWeapon);
                }

                e.preventDefault();
            });
        }

        function setupMobileControls() {
            if ('ontouchstart' in window) {
                document.getElementById('mobileControls').style.display = 'block';

                const joystick = document.getElementById('joystick');
                const joystickContainer = joystick.parentElement;
                let joystickActive = false;

                joystickContainer.addEventListener('touchstart', (e) => {
                    joystickActive = true;
                    handleJoystickTouch(e.touches[0]);
                    e.preventDefault();
                });

                joystickContainer.addEventListener('touchmove', (e) => {
                    if (joystickActive) {
                        handleJoystickTouch(e.touches[0]);
                        e.preventDefault();
                    }
                });

                joystickContainer.addEventListener('touchend', () => {
                    joystickActive = false;
                    joystick.style.transform = 'translate(-50%, -50%)';
                    if (playerShip) {
                        playerShip.keys.up = false;
                        playerShip.keys.down = false;
                        playerShip.keys.left = false;
                        playerShip.keys.right = false;
                    }
                });

                function handleJoystickTouch(touch) {
                    const rect = joystickContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    let deltaX = touch.clientX - centerX;
                    let deltaY = touch.clientY - centerY;

                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 30;

                    if (distance > maxDistance) {
                        deltaX = (deltaX / distance) * maxDistance;
                        deltaY = (deltaY / distance) * maxDistance;
                    }

                    joystick.style.transform = `translate(${deltaX - 30}px, ${deltaY - 30}px)`;

                    if (playerShip) {
                        playerShip.keys.up = deltaY < -20;
                        playerShip.keys.down = deltaY > 20;
                        playerShip.keys.left = deltaX < -20;
                        playerShip.keys.right = deltaX > 20;
                    }
                }

                // Mobile buttons
                document.getElementById('mobileFireBtn').addEventListener('touchstart', () => {
                    if (playerShip) playerShip.keys.fire = true;
                });

                document.getElementById('mobileFireBtn').addEventListener('touchend', () => {
                    if (playerShip) playerShip.keys.fire = false;
                });

                document.getElementById('mobileBoostBtn').addEventListener('touchstart', () => {
                    if (playerShip) playerShip.keys.boost = true;
                });

                document.getElementById('mobileBoostBtn').addEventListener('touchend', () => {
                    if (playerShip) {
                        playerShip.keys.boost = false;
                        audioSystem.stopBoostSound();
                    }
                });

                document.getElementById('mobileSpecialBtn').addEventListener('touchstart', () => {
                    if (playerShip) playerShip.keys.special = true;
                });

                document.getElementById('mobileSpecialBtn').addEventListener('touchend', () => {
                    if (playerShip) playerShip.keys.special = false;
                });
            }
        }

        function setupDebugKeys() {
            let debugMode = false;

            document.addEventListener('keydown', (e) => {
                // Toggle debug mode with F1
                if (e.key === 'F1') {
                    debugMode = !debugMode;
                    document.getElementById('perfStats').style.display = debugMode ? 'block' : 'none';
                    showNotification(`Debug Mode: ${debugMode ? 'ON' : 'OFF'}`, '#ffff00');
                    e.preventDefault();
                }

                if (debugMode) {
                    switch (e.key) {
                        case 'F2': // God mode
                            if (playerShip) {
                                playerShip.health = 9999;
                                playerShip.shield = 9999;
                                showNotification('God Mode Activated', '#ff00ff');
                            }
                            break;

                        case 'F3': // Instant special
                            if (playerShip) {
                                playerShip.specialWeaponReady = true;
                                playerShip.specialCooldown = 0;
                                showNotification('Special Weapon Ready', '#ff00ff');
                            }
                            break;

                        case 'F4': // Max boost
                            if (playerShip) {
                                playerShip.boostEnergy = CONFIG.BOOST_MAX;
                                showNotification('Boost Recharged', '#ff00ff');
                            }
                            break;

                        case 'F5': // Spawn power-up
                            if (playerShip) {
                                const types = ['health', 'shield', 'weapon', 'boost'];
                                const type = types[Math.floor(Math.random() * types.length)];
                                const powerup = new Powerup(playerShip.mesh.position.clone(), type);
                                powerups.push(powerup);
                                showNotification(`Spawned ${type} power-up`, '#ff00ff');
                            }
                            break;

                        case 'F6': // Kill all enemies
                            ships.forEach(ship => {
                                if (ship !== playerShip && ship.alive) {
                                    ship.takeDamage(9999, playerShip);
                                }
                            });
                            showNotification('Enemies Eliminated', '#ff00ff');
                            break;

                        case 'F7': // Skip to end
                            timer = 10;
                            showNotification('Battle Ending Soon', '#ff00ff');
                            break;

                        case 'F8': // Unlock all achievements
                            for (let key in achievementSystem.achievements) {
                                achievementSystem.unlock(key);
                            }
                            showNotification('All Achievements Unlocked', '#ff00ff');
                            break;
                    }
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            requestAnimationFrame(animate);

            // Update performance stats
            updatePerformanceStats();

            // Update time-based animations
            const time = Date.now() * 0.001;

            // Camera management
            updateCamera(time);

            // Update game objects only if battle is active
            if (gameState === 'battle' && ships && ships.length > 0) {
                // Update ships
                ships.forEach(ship => {
                    if (ship && ship.update) {
                        ship.update();
                    }
                });

                // Update projectiles
                if (lasers && lasers.length > 0) {
                    lasers = lasers.filter(laser => laser && laser.update && laser.update());
                }

                if (missiles && missiles.length > 0) {
                    missiles = missiles.filter(missile => missile && missile.update && missile.update());
                }

                if (powerups && powerups.length > 0) {
                    powerups = powerups.filter(powerup => powerup && powerup.update && powerup.update());
                }

                // Update systems
                if (destructionSystem) destructionSystem.update();
                if (weatherSystem) weatherSystem.update();
                if (comboSystem) comboSystem.update();

                // Update engine sounds
                ships.forEach(ship => {
                    if (ship && ship.alive && audioSystem) {
                        if (ship.engineSound) {
                            audioSystem.updateEngineSound(ship);
                        } else {
                            audioSystem.playEngineSound(ship);
                        }
                    }
                });
            }

            // Update environment animations
            updateEnvironment(time);

            // Render scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function updatePerformanceStats() {
            const now = performance.now();
            stats.frames++;

            if (now > stats.lastTime + 1000) {
                stats.fps = Math.round((stats.frames * 1000) / (now - stats.lastTime));
                stats.frames = 0;
                stats.lastTime = now;

                // Update display
                if (document.getElementById('perfStats').style.display === 'block') {
                    document.getElementById('fps').textContent = stats.fps;
                    document.getElementById('drawCalls').textContent = renderer.info.render.calls;
                    document.getElementById('triangles').textContent = renderer.info.render.triangles;
                }
            }
        }

        function updateCamera(time) {
            if (gameMode === 'player' && playerShip && playerShip.alive) {
                // Follow player camera
                const offset = new THREE.Vector3(0, 40, 100);
                offset.applyQuaternion(playerShip.mesh.quaternion);

                const desiredPosition = playerShip.mesh.position.clone().add(offset);
                camera.position.lerp(desiredPosition, 0.1);

                const lookAt = new THREE.Vector3(0, 0, -150);
                lookAt.applyQuaternion(playerShip.mesh.quaternion);
                lookAt.add(playerShip.mesh.position);

                const currentLookAt = new THREE.Vector3();
                camera.getWorldDirection(currentLookAt);
                currentLookAt.multiplyScalar(150).add(camera.position);

                currentLookAt.lerp(lookAt, 0.1);
                camera.lookAt(currentLookAt);
            } else {
                // Cinematic camera
                const radius = 600 + Math.sin(time * 0.3) * 200;
                camera.position.x = Math.cos(time * 0.2) * radius;
                camera.position.z = Math.sin(time * 0.2) * radius;
                camera.position.y = 300 + Math.sin(time * 0.5) * 100;

                // Look at battle center
                const battleCenter = new THREE.Vector3();
                let activeShips = 0;
                ships.forEach(ship => {
                    if (ship.alive) {
                        battleCenter.add(ship.mesh.position);
                        activeShips++;
                    }
                });

                if (activeShips > 0) {
                    battleCenter.divideScalar(activeShips);
                    battleCenter.y += 50;
                    camera.lookAt(battleCenter);
                } else {
                    camera.lookAt(0, 100, 0);
                }
            }
        }

        function updateEnvironment(time) {
            // Animate ocean waves
            const ocean = scene.children.find(child => child.name === 'ocean');
            if (ocean && ocean.geometry) {
                const vertices = ocean.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const y = vertices[i + 1];
                    vertices[i + 2] = Math.sin(x * 0.01 + time) * 5 +
                        Math.cos(y * 0.01 + time * 0.8) * 5 +
                        Math.sin(time * 2 + x * 0.005) * 2;
                }
                ocean.geometry.attributes.position.needsUpdate = true;
            }

            // Animate clouds
            const clouds = scene.getObjectByName('clouds');
            if (clouds) {
                clouds.children.forEach(cloud => {
                    cloud.position.x += cloud.userData.speed;

                    // Wrap around
                    if (cloud.position.x > 1500) {
                        cloud.position.x = -1500;
                    } else if (cloud.position.x < -1500) {
                        cloud.position.x = 1500;
                    }

                    // Gentle bobbing
                    cloud.position.y += Math.sin(time + cloud.position.x * 0.001) * 0.1;
                });
            }

            // Animate city lights
            scene.traverse(child => {
                if (child.userData.blink) {
                    child.visible = Math.sin(time * 5 + child.userData.offset) > 0;
                }
            });
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        function showNotification(text, color = '#ffffff') {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = text;
            notif.style.color = color;
            notif.style.textShadow = `0 0 10px ${color}`;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.style.opacity = '0';
                setTimeout(() => notif.remove(), 500);
            }, 3000);
        }

        window.closeSettings = closeSettings;

        // ========================================
        // START GAME
        // ========================================
        init();
    });
</script>