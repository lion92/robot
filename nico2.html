<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Battle Arena - Spectateur</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
            font-family: monospace;
            color: #fff;
        }
        canvas {

            position: absolute;
            top: 0;
            left: 0;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            min-width: 200px;
        }
        #teams {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        .team-blue { color: #4facfe; }
        .team-red { color: #ff6b6b; }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 8px 16px;
            border: none;
            background: #4facfe;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #00f2fe; }
        #winner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            display: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="stats">
    <h3>‚öîÔ∏è BATAILLE EN COURS</h3>
    <div>Dur√©e: <span id="time">0</span>s</div>
    <div>Tirs: <span id="shots">0</span></div>
    <div>√âliminations: <span id="kills">0</span></div>
</div>
<div id="teams">
    <div class="team-blue">üîµ √âquipe Bleue: <span id="blue-count">0</span></div>
    <div class="team-red">üî¥ √âquipe Rouge: <span id="red-count">0</span></div>
</div>
<div id="controls">
    <button onclick="startBattle(5)">5v5</button>
    <button onclick="startBattle(10)">10v10</button>
    <button onclick="startBattle(20)">20v20 CHAOS</button>
    <button onclick="toggleCamera()">üì∑ Changer Vue</button>
    <button onclick="toggleSpeed()">‚è© Vitesse x<span id="speed">1</span></button>
</div>
<div id="winner"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer;
    let drones = [], bullets = [], particles = [];
    let stats = { time: 0, shots: 0, kills: 0 };
    let gameSpeed = 1;
    let cameraMode = 0;
    let battleStart = 0;

    // Init Three.js
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0a0a, 200, 1500);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 1, 2000);
    camera.position.set(0, 300, 500);

    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('c'),
        antialias: true,
        alpha: true
    });
    renderer.setSize(innerWidth, innerHeight);

    // Lighting
    scene.add(new THREE.AmbientLight(0x404040, 0.3));
    const moon = new THREE.DirectionalLight(0x4a90e2, 0.5);
    moon.position.set(200, 400, 200);
    moon.castShadow = true;
    scene.add(moon);

    // City glow
    const cityGlow = new THREE.HemisphereLight(0xff9500, 0x1a1a1a, 0.4);
    scene.add(cityGlow);

    // Central Park ground
    const parkGround = new THREE.Mesh(
        new THREE.PlaneGeometry(1200, 1200, 30, 30),
        new THREE.MeshPhongMaterial({
            color: 0x2d5016,
            roughness: 0.8,
            metalness: 0.2
        })
    );
    parkGround.rotation.x = -Math.PI/2;
    parkGround.receiveShadow = true;
    scene.add(parkGround);

    // Park paths (walking paths)
    const pathMaterial = new THREE.MeshPhongMaterial({
        color: 0x8b7355,
        roughness: 0.9
    });

    // Main cross paths
    const pathH = new THREE.Mesh(
        new THREE.PlaneGeometry(1200, 20),
        pathMaterial
    );
    pathH.rotation.x = -Math.PI/2;
    pathH.position.y = 0.1;
    scene.add(pathH);

    const pathV = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 1200),
        pathMaterial
    );
    pathV.rotation.x = -Math.PI/2;
    pathV.position.y = 0.1;
    scene.add(pathV);

    // Diagonal paths
    for(let i = 0; i < 2; i++) {
        const diagPath = new THREE.Mesh(
            new THREE.PlaneGeometry(15, 800),
            pathMaterial
        );
        diagPath.rotation.x = -Math.PI/2;
        diagPath.rotation.z = (i === 0 ? Math.PI/4 : -Math.PI/4);
        diagPath.position.y = 0.1;
        scene.add(diagPath);
    }

    // Create trees
    function createTrees() {
        const treePositions = [];

        // Grid of trees avoiding paths and center
        for(let x = -500; x <= 500; x += 60) {
            for(let z = -500; z <= 500; z += 60) {
                // Skip paths and center area
                if(Math.abs(x) < 20 || Math.abs(z) < 20) continue;
                if(Math.abs(x) < 100 && Math.abs(z) < 100) continue;

                // Random offset for natural look
                const posX = x + (Math.random() - 0.5) * 20;
                const posZ = z + (Math.random() - 0.5) * 20;

                // Different tree types
                const treeType = Math.random();

                if(treeType < 0.6) {
                    // Regular trees
                    const treeGroup = new THREE.Group();

                    // Trunk
                    const trunkGeometry = new THREE.CylinderGeometry(3, 4, 20);
                    const trunkMaterial = new THREE.MeshPhongMaterial({
                        color: 0x4a3c28
                    });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 10;
                    treeGroup.add(trunk);

                    // Foliage (multiple spheres for fuller look)
                    const foliageColor = [0x2d5016, 0x3a5f0b, 0x4d7c0f][Math.floor(Math.random() * 3)];
                    for(let j = 0; j < 3; j++) {
                        const foliageGeometry = new THREE.SphereGeometry(12 - j*2, 6, 5);
                        const foliageMaterial = new THREE.MeshPhongMaterial({
                            color: foliageColor,
                            flatShading: true
                        });
                        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                        foliage.position.y = 25 + j*5;
                        foliage.position.x = (Math.random() - 0.5) * 5;
                        foliage.position.z = (Math.random() - 0.5) * 5;
                        treeGroup.add(foliage);
                    }

                    treeGroup.position.set(posX, 0, posZ);
                    treeGroup.scale.y = 0.8 + Math.random() * 0.4;
                    scene.add(treeGroup);

                } else if(treeType < 0.85) {
                    // Pine trees
                    const pineGroup = new THREE.Group();

                    const trunkGeometry = new THREE.CylinderGeometry(2, 3, 25);
                    const trunkMaterial = new THREE.MeshPhongMaterial({
                        color: 0x5d4e37
                    });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 12.5;
                    pineGroup.add(trunk);

                    // Cone-shaped foliage
                    for(let j = 0; j < 3; j++) {
                        const coneGeometry = new THREE.ConeGeometry(10 - j*2, 15 - j*3, 6);
                        const coneMaterial = new THREE.MeshPhongMaterial({
                            color: 0x0f5132,
                            flatShading: true
                        });
                        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                        cone.position.y = 20 + j*8;
                        pineGroup.add(cone);
                    }

                    pineGroup.position.set(posX, 0, posZ);
                    scene.add(pineGroup);

                } else {
                    // Bushes
                    const bushGroup = new THREE.Group();
                    for(let j = 0; j < 3; j++) {
                        const bushGeometry = new THREE.SphereGeometry(5 + Math.random()*3, 5, 4);
                        const bushMaterial = new THREE.MeshPhongMaterial({
                            color: 0x3a5f0b,
                            flatShading: true
                        });
                        const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                        bush.position.set(
                            (Math.random() - 0.5) * 10,
                            5,
                            (Math.random() - 0.5) * 10
                        );
                        bushGroup.add(bush);
                    }
                    bushGroup.position.set(posX, 0, posZ);
                    scene.add(bushGroup);
                }
            }
        }
    }

    // Lake/Pond in center
    const lakeGeometry = new THREE.CircleGeometry(80, 16);
    const lakeMaterial = new THREE.MeshPhongMaterial({
        color: 0x006994,
        transparent: true,
        opacity: 0.8,
        shininess: 100
    });
    const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
    lake.rotation.x = -Math.PI/2;
    lake.position.y = 0.05;
    scene.add(lake);

    // Fountain in center of lake
    const fountainGroup = new THREE.Group();

    // Fountain base
    const fountainBase = new THREE.Mesh(
        new THREE.CylinderGeometry(15, 18, 5),
        new THREE.MeshPhongMaterial({ color: 0x808080 })
    );
    fountainBase.position.y = 2.5;
    fountainGroup.add(fountainBase);

    // Fountain pillar
    const fountainPillar = new THREE.Mesh(
        new THREE.CylinderGeometry(3, 3, 20),
        new THREE.MeshPhongMaterial({ color: 0x909090 })
    );
    fountainPillar.position.y = 10;
    fountainGroup.add(fountainPillar);

    // Water spray effect (particles)
    for(let i = 0; i < 20; i++) {
        const droplet = new THREE.Mesh(
            new THREE.SphereGeometry(0.5),
            new THREE.MeshBasicMaterial({
                color: 0x87ceeb,
                transparent: true,
                opacity: 0.6
            })
        );
        droplet.position.set(
            (Math.random() - 0.5) * 10,
            20 + Math.random() * 10,
            (Math.random() - 0.5) * 10
        );
        fountainGroup.add(droplet);
    }

    scene.add(fountainGroup);

    // Park benches
    function createBenches() {
        const benchPositions = [
            {x: -100, z: 50}, {x: 100, z: 50},
            {x: -100, z: -50}, {x: 100, z: -50},
            {x: 50, z: 100}, {x: -50, z: 100},
            {x: 50, z: -100}, {x: -50, z: -100}
        ];

        benchPositions.forEach(pos => {
            const benchGroup = new THREE.Group();

            // Seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(20, 1, 8),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            seat.position.y = 5;
            benchGroup.add(seat);

            // Back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 1),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            back.position.set(0, 9, -3.5);
            benchGroup.add(back);

            // Legs
            for(let i = -8; i <= 8; i += 16) {
                const leg = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 5, 1),
                    new THREE.MeshPhongMaterial({ color: 0x696969 })
                );
                leg.position.set(i, 2.5, 0);
                benchGroup.add(leg);
            }

            benchGroup.position.set(pos.x, 0, pos.z);
            benchGroup.rotation.y = Math.atan2(pos.z, pos.x);
            scene.add(benchGroup);
        });
    }

    // Street lamps in park
    function createParkLamps() {
        const lampPositions = [
            {x: -150, z: -150}, {x: 150, z: -150},
            {x: -150, z: 150}, {x: 150, z: 150},
            {x: 0, z: -200}, {x: 0, z: 200},
            {x: -200, z: 0}, {x: 200, z: 0}
        ];

        lampPositions.forEach(pos => {
            const lampGroup = new THREE.Group();

            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1.5, 30),
                new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
            );
            pole.position.y = 15;
            lampGroup.add(pole);

            // Lamp head
            const lampHead = new THREE.Mesh(
                new THREE.SphereGeometry(4, 6, 4),
                new THREE.MeshPhongMaterial({
                    color: 0xfffacd,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                })
            );
            lampHead.position.y = 30;
            lampGroup.add(lampHead);

            // Light source
            const lampLight = new THREE.PointLight(0xffd700, 0.5, 80);
            lampLight.position.y = 30;
            lampGroup.add(lampLight);

            lampGroup.position.set(pos.x, 0, pos.z);
            scene.add(lampGroup);
        });
    }

    createTrees();
    createBenches();
    createParkLamps();

    // Boeing 747 class
    class Boeing747 {
        constructor() {
            const group = new THREE.Group();

            // Fuselage
            const fuselageGeometry = new THREE.CylinderGeometry(8, 8, 80, 12);
            const fuselageMaterial = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                metalness: 0.8,
                roughness: 0.2
            });
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            fuselage.rotation.z = Math.PI / 2;
            group.add(fuselage);

            // Nose cone
            const noseGeometry = new THREE.ConeGeometry(8, 15, 12);
            const nose = new THREE.Mesh(noseGeometry, fuselageMaterial);
            nose.rotation.z = -Math.PI / 2;
            nose.position.x = 47.5;
            group.add(nose);

            // Tail
            const tailGeometry = new THREE.ConeGeometry(8, 10, 12);
            const tail = new THREE.Mesh(tailGeometry, fuselageMaterial);
            tail.rotation.z = Math.PI / 2;
            tail.position.x = -45;
            tail.scale.y = 0.8;
            group.add(tail);

            // Wings
            const wingGeometry = new THREE.BoxGeometry(60, 1, 15);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: 0xa0a0a0,
                metalness: 0.7
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.y = -2;
            wings.scale.z = 1;
            wings.scale.x = 1.5;
            group.add(wings);

            // Tail fin
            const finGeometry = new THREE.BoxGeometry(2, 20, 10);
            const fin = new THREE.Mesh(finGeometry, wingMaterial);
            fin.position.set(-35, 10, 0);
            group.add(fin);

            // Horizontal stabilizers
            const stabilizerGeometry = new THREE.BoxGeometry(25, 1, 8);
            const stabilizer = new THREE.Mesh(stabilizerGeometry, wingMaterial);
            stabilizer.position.set(-35, 10, 0);
            group.add(stabilizer);

            // Engines (4 engines for 747)
            const enginePositions = [
                { x: 10, y: -5, z: 20 },
                { x: 10, y: -5, z: -20 },
                { x: -5, y: -5, z: 35 },
                { x: -5, y: -5, z: -35 }
            ];

            enginePositions.forEach(pos => {
                const engineGeometry = new THREE.CylinderGeometry(3, 3, 10, 8);
                const engineMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    metalness: 0.9
                });
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.rotation.z = Math.PI / 2;
                engine.position.set(pos.x, pos.y, pos.z);
                group.add(engine);
            });

            // Windows
            for(let i = -30; i <= 30; i += 4) {
                const windowGeometry = new THREE.BoxGeometry(1.5, 2, 1);
                const windowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    emissive: 0x87ceeb,
                    emissiveIntensity: 0.3
                });
                const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                window1.position.set(i, 2, 8.5);
                group.add(window1);

                const window2 = window1.clone();
                window2.position.z = -8.5;
                group.add(window2);
            }

            // Navigation lights
            const redLight = new THREE.PointLight(0xff0000, 1, 50);
            redLight.position.set(-5, -5, -45);
            group.add(redLight);

            const greenLight = new THREE.PointLight(0x00ff00, 1, 50);
            greenLight.position.set(-5, -5, 45);
            group.add(greenLight);

            const strobeLight = new THREE.PointLight(0xffffff, 2, 100);
            strobeLight.position.set(0, 15, 0);
            group.add(strobeLight);
            this.strobeLight = strobeLight;

            // Position high in the sky
            this.mesh = group;
            this.mesh.position.set(-800, 400, -600);
            this.velocity = new THREE.Vector3(2, 0, 1.5);
            this.mesh.rotation.y = Math.atan2(1.5, 2);

            scene.add(this.mesh);
        }

        update() {
            // Fly across the sky
            this.mesh.position.add(this.velocity);

            // Loop around when out of bounds
            if(this.mesh.position.x > 1000) {
                this.mesh.position.x = -1000;
                this.mesh.position.z = -600 + Math.random() * 1200;
                this.mesh.position.y = 350 + Math.random() * 150;
            }

            // Gentle banking and altitude changes
            this.mesh.rotation.z = Math.sin(Date.now() * 0.0005) * 0.1;
            this.mesh.position.y += Math.sin(Date.now() * 0.0003) * 0.2;

            // Strobe light blinking
            this.strobeLight.intensity = Math.sin(Date.now() * 0.01) > 0 ? 2 : 0;
        }
    }

    // Create the Boeing
    let boeing = null;

    // Create buildings
    const buildings = [];
    function createBuildings() {
        const buildingColors = [0x2c3e50, 0x34495e, 0x2c3853, 0x273c55, 0x1e2936];

        // Grid of buildings with streets
        for(let x = -500; x <= 500; x += 150) {
            for(let z = -500; z <= 500; z += 150) {
                // Skip center area for better combat visibility
                if(Math.abs(x) < 150 && Math.abs(z) < 150) continue;

                // Random building dimensions
                const width = 40 + Math.random() * 40;
                const depth = 40 + Math.random() * 40;
                const height = 80 + Math.random() * 200;

                // Building base
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    new THREE.MeshPhongMaterial({
                        color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                        emissive: 0x000000,
                        emissiveIntensity: 0.1
                    })
                );

                building.position.set(
                    x + (Math.random() - 0.5) * 30,
                    height/2,
                    z + (Math.random() - 0.5) * 30
                );

                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                buildings.push(building);

                // Windows (emissive lights)
                const windowRows = Math.floor(height / 15);
                const windowCols = Math.floor(width / 10);

                for(let row = 0; row < windowRows; row++) {
                    for(let col = 0; col < windowCols; col++) {
                        if(Math.random() > 0.7) { // 70% windows lit
                            const window = new THREE.Mesh(
                                new THREE.BoxGeometry(6, 8, 1),
                                new THREE.MeshBasicMaterial({
                                    color: 0xffeb3b,
                                    emissive: 0xffeb3b
                                })
                            );
                            window.position.set(
                                building.position.x + (col - windowCols/2) * 10,
                                row * 15 + 10,
                                building.position.z + depth/2 + 0.5
                            );
                            scene.add(window);

                            // Add window on opposite side too
                            const window2 = window.clone();
                            window2.position.z = building.position.z - depth/2 - 0.5;
                            scene.add(window2);
                        }
                    }
                }

                // Rooftop details
                const rooftop = new THREE.Mesh(
                    new THREE.BoxGeometry(width * 0.8, 5, depth * 0.8),
                    new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
                );
                rooftop.position.set(
                    building.position.x,
                    height + 2.5,
                    building.position.z
                );
                scene.add(rooftop);

                // Antenna
                if(Math.random() > 0.5) {
                    const antenna = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1, 30),
                        new THREE.MeshPhongMaterial({ color: 0xff0000 })
                    );
                    antenna.position.set(
                        building.position.x + (Math.random() - 0.5) * width/2,
                        height + 15,
                        building.position.z + (Math.random() - 0.5) * depth/2
                    );
                    scene.add(antenna);

                    // Blinking light on antenna
                    const light = new THREE.PointLight(0xff0000, 0.5, 30);
                    light.position.copy(antenna.position);
                    light.position.y += 15;
                    scene.add(light);
                }
            }
        }

        // Street lights
        for(let i = -400; i <= 400; i += 200) {
            for(let j = -400; j <= 400; j += 200) {
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 40),
                    new THREE.MeshPhongMaterial({ color: 0x444444 })
                );
                pole.position.set(i, 20, j);
                scene.add(pole);

                const streetLight = new THREE.PointLight(0xffa500, 0.8, 100);
                streetLight.position.set(i, 40, j);
                scene.add(streetLight);
            }
        }
    }

    createBuildings();

    // Arena boundaries (invisible walls)
    for(let i = 0; i < 4; i++) {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(i < 2 ? 1200 : 10, 500, i < 2 ? 10 : 1200),
            new THREE.MeshPhongMaterial({
                visible: false
            })
        );
        wall.position.set(
            i === 1 ? 600 : i === 3 ? -600 : 0,
            250,
            i === 0 ? 600 : i === 2 ? -600 : 0
        );
        scene.add(wall);
    }

    // Drone AI Class
    class DroneAI {
        constructor(team, position) {
            const group = new THREE.Group();

            // Body
            const body = new THREE.Mesh(
                new THREE.OctahedronGeometry(10, 0),
                new THREE.MeshPhongMaterial({
                    color: team === 'blue' ? 0x4facfe : 0xff6b6b,
                    emissive: team === 'blue' ? 0x0066cc : 0xcc0000,
                    emissiveIntensity: 0.5
                })
            );
            group.add(body);

            // Rotors
            for(let i = 0; i < 4; i++) {
                const angle = (i/4) * Math.PI * 2;
                const rotor = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 1, 3),
                    new THREE.MeshBasicMaterial({
                        color: 0x1a1a1a,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                rotor.position.x = Math.cos(angle) * 12;
                rotor.position.z = Math.sin(angle) * 12;
                rotor.position.y = 5;
                group.add(rotor);
            }

            // Light
            const light = new THREE.PointLight(
                team === 'blue' ? 0x4facfe : 0xff6b6b,
                0.5,
                50
            );
            group.add(light);

            this.mesh = group;
            this.mesh.position.copy(position);

            this.team = team;
            this.health = 100;
            this.velocity = new THREE.Vector3();
            this.target = null;
            this.lastShot = 0;
            this.state = 'hunting';
            this.dodgeTimer = 0;
            this.accuracy = 0.7 + Math.random() * 0.3;
            this.aggressiveness = 0.5 + Math.random() * 0.5;
            this.reactionTime = 100 + Math.random() * 200;

            scene.add(this.mesh);
        }

        update() {
            // Rotor animation
            this.mesh.children.forEach((child, i) => {
                if(i > 0 && i < 5) child.rotation.y += 0.4 * gameSpeed;
            });

            // AI behavior
            this.findTarget();
            this.movement();
            this.combat();

            // Apply velocity
            this.mesh.position.add(this.velocity.clone().multiplyScalar(gameSpeed));

            // Boundaries
            const bound = 580;
            ['x', 'z'].forEach(axis => {
                if(Math.abs(this.mesh.position[axis]) > bound) {
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * bound;
                    this.velocity[axis] *= -0.5;
                }
            });

            // Height variation between buildings
            const minHeight = 50;
            const maxHeight = 250;
            const targetHeight = minHeight + Math.sin(Date.now() * 0.001 + this.mesh.id) * 30 +
                Math.random() * (maxHeight - minHeight - 60);
            this.mesh.position.y += (targetHeight - this.mesh.position.y) * 0.05;

            // Keep drones above buildings but below max height
            this.mesh.position.y = Math.max(minHeight, Math.min(maxHeight, this.mesh.position.y));
        }

        findTarget() {
            let minDist = Infinity;
            let newTarget = null;

            drones.forEach(d => {
                if(d.team !== this.team && d.health > 0) {
                    const dist = this.mesh.position.distanceTo(d.mesh.position);
                    if(dist < minDist) {
                        minDist = dist;
                        newTarget = d;
                    }
                }
            });

            this.target = newTarget;
            this.state = this.target ?
                (minDist < 200 ? 'combat' : 'pursuit') :
                'patrol';
        }

        movement() {
            const speed = 3;

            switch(this.state) {
                case 'combat':
                    if(this.target) {
                        // Strafe around target, using buildings as cover
                        const angle = Date.now() * 0.002;
                        const radius = 150;
                        const targetPos = new THREE.Vector3(
                            this.target.mesh.position.x + Math.cos(angle) * radius,
                            this.mesh.position.y,
                            this.target.mesh.position.z + Math.sin(angle) * radius
                        );

                        const dir = targetPos.clone().sub(this.mesh.position).normalize();
                        this.velocity.lerp(dir.multiplyScalar(speed), 0.1);

                        // Dodge incoming bullets and buildings
                        this.dodgeBullets();
                        this.avoidBuildings();
                    }
                    break;

                case 'pursuit':
                    if(this.target) {
                        const dir = this.target.mesh.position.clone()
                            .sub(this.mesh.position).normalize();
                        this.velocity.lerp(dir.multiplyScalar(speed * 1.5), 0.05);
                        this.avoidBuildings();
                    }
                    break;

                case 'patrol':
                    // Random movement between buildings
                    if(Math.random() < 0.02) {
                        this.velocity.x += (Math.random() - 0.5) * 2;
                        this.velocity.z += (Math.random() - 0.5) * 2;
                    }
                    this.velocity.multiplyScalar(0.95);
                    this.avoidBuildings();
                    break;
            }

            // Max speed
            if(this.velocity.length() > speed * 2) {
                this.velocity.normalize().multiplyScalar(speed * 2);
            }
        }

        avoidBuildings() {
            // Simple building avoidance
            buildings.forEach(building => {
                const dist = this.mesh.position.distanceTo(building.position);
                if(dist < 80) {
                    const avoidDir = this.mesh.position.clone()
                        .sub(building.position).normalize();
                    this.velocity.add(avoidDir.multiplyScalar(5));

                    // Go higher to avoid building
                    if(this.mesh.position.y < building.geometry.parameters.height + 20) {
                        this.velocity.y = 3;
                    }
                }
            });
        }

        dodgeBullets() {
            bullets.forEach(b => {
                if(b.team !== this.team) {
                    const dist = this.mesh.position.distanceTo(b.position);
                    if(dist < 100) {
                        const dodge = this.mesh.position.clone().sub(b.position).normalize();
                        this.velocity.add(dodge.multiplyScalar(5));
                    }
                }
            });
        }

        combat() {
            if(!this.target || this.target.health <= 0) return;

            const dist = this.mesh.position.distanceTo(this.target.mesh.position);
            const now = Date.now();

            if(dist < 300 && now - this.lastShot > this.reactionTime) {
                // Aim prediction
                const timeToHit = dist / 15;
                const predictedPos = this.target.mesh.position.clone()
                    .add(this.target.velocity.clone().multiplyScalar(timeToHit));

                // Shoot with accuracy
                if(Math.random() < this.accuracy * this.aggressiveness) {
                    this.shoot(predictedPos);
                    this.lastShot = now;
                }
            }
        }

        shoot(targetPos) {
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(2),
                new THREE.MeshBasicMaterial({
                    color: this.team === 'blue' ? 0x00f2fe : 0xff6b6b,
                    emissive: this.team === 'blue' ? 0x00f2fe : 0xff6b6b
                })
            );

            bullet.position.copy(this.mesh.position);
            bullet.velocity = targetPos.clone()
                .sub(this.mesh.position).normalize().multiplyScalar(15);
            bullet.team = this.team;
            bullet.owner = this;
            bullet.life = 100;

            scene.add(bullet);
            bullets.push(bullet);
            stats.shots++;
        }

        takeDamage(damage) {
            this.health -= damage;

            // Hit effect
            for(let i = 0; i < 5; i++) {
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshBasicMaterial({
                        color: this.team === 'blue' ? 0x4facfe : 0xff6b6b
                    })
                );
                p.position.copy(this.mesh.position);
                p.velocity = new THREE.Vector3(
                    (Math.random()-0.5)*5,
                    Math.random()*5,
                    (Math.random()-0.5)*5
                );
                p.life = 20;
                scene.add(p);
                particles.push(p);
            }

            if(this.health <= 0) {
                this.explode();
                return true;
            }
            return false;
        }

        explode() {
            // Big explosion
            for(let i = 0; i < 30; i++) {
                const p = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(3),
                    new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00
                    })
                );
                p.position.copy(this.mesh.position);
                p.velocity = new THREE.Vector3(
                    (Math.random()-0.5)*15,
                    Math.random()*15,
                    (Math.random()-0.5)*15
                );
                p.life = 40;
                scene.add(p);
                particles.push(p);
            }

            scene.remove(this.mesh);
            stats.kills++;
        }
    }

    // Start battle
    function startBattle(teamSize) {
        // Clear previous battle
        drones.forEach(d => scene.remove(d.mesh));
        bullets.forEach(b => scene.remove(b));
        particles.forEach(p => scene.remove(p));
        drones = [];
        bullets = [];
        particles = [];

        // Reset stats
        stats = { time: 0, shots: 0, kills: 0 };
        battleStart = Date.now();
        document.getElementById('winner').style.display = 'none';

        // Create Boeing if not exists
        if(!boeing) {
            boeing = new Boeing747();
        }

        // Create teams with urban spawn points
        for(let i = 0; i < teamSize; i++) {
            // Blue team (west side)
            drones.push(new DroneAI('blue', new THREE.Vector3(
                -400 + Math.random()*100,
                100 + Math.random()*100,
                (Math.random()-0.5)*400
            )));

            // Red team (east side)
            drones.push(new DroneAI('red', new THREE.Vector3(
                400 - Math.random()*100,
                100 + Math.random()*100,
                (Math.random()-0.5)*400
            )));
        }
    }

    // Toggle camera views
    function toggleCamera() {
        cameraMode = (cameraMode + 1) % 3;
    }

    // Toggle speed
    function toggleSpeed() {
        gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 4 : 1;
        document.getElementById('speed').textContent = gameSpeed;
    }

    // Main loop
    function animate() {
        requestAnimationFrame(animate);

        // Update Boeing
        if(boeing) {
            boeing.update();
        }

        // Update drones
        drones = drones.filter(d => {
            if(d.health > 0) {
                d.update();
                return true;
            }
            return false;
        });

        // Update bullets
        bullets = bullets.filter(b => {
            b.position.add(b.velocity.clone().multiplyScalar(gameSpeed));
            b.life -= gameSpeed;

            // Check hits
            drones.forEach((d, i) => {
                if(d.team !== b.team && b.position.distanceTo(d.mesh.position) < 15) {
                    if(d.takeDamage(25)) {
                        drones.splice(i, 1);
                    }
                    scene.remove(b);
                    b.life = 0;
                }
            });

            if(b.life <= 0) {
                scene.remove(b);
                return false;
            }
            return true;
        });

        // Update particles
        particles = particles.filter(p => {
            p.position.add(p.velocity.clone().multiplyScalar(gameSpeed));
            p.velocity.y -= 0.3 * gameSpeed;
            p.life -= gameSpeed;
            p.material.opacity = p.life / 40;
            p.rotation.x += 0.1;
            p.rotation.y += 0.1;

            if(p.life <= 0) {
                scene.remove(p);
                return false;
            }
            return true;
        });

        // Camera movement
        const time = Date.now() * 0.0005;
        switch(cameraMode) {
            case 0: // Orbital view
                camera.position.x = Math.cos(time) * 600;
                camera.position.z = Math.sin(time) * 600;
                camera.position.y = 300;
                camera.lookAt(0, 0, 0);
                break;
            case 1: // Top view
                camera.position.set(0, 800, 0);
                camera.lookAt(0, 0, 0);
                break;
            case 2: // Dynamic follow
                if(drones.length > 0) {
                    const drone = drones[Math.floor(Math.random() * drones.length)];
                    camera.position.lerp(
                        drone.mesh.position.clone().add(new THREE.Vector3(100, 100, 100)),
                        0.02
                    );
                    camera.lookAt(drone.mesh.position);
                }
                break;
        }

        // Update UI
        if(battleStart) {
            stats.time = Math.floor((Date.now() - battleStart) / 1000);
        }

        const blueCount = drones.filter(d => d.team === 'blue').length;
        const redCount = drones.filter(d => d.team === 'red').length;

        document.getElementById('time').textContent = stats.time;
        document.getElementById('shots').textContent = stats.shots;
        document.getElementById('kills').textContent = stats.kills;
        document.getElementById('blue-count').textContent = blueCount;
        document.getElementById('red-count').textContent = redCount;

        // Check winner
        if(drones.length > 0 && (blueCount === 0 || redCount === 0)) {
            const winner = document.getElementById('winner');
            winner.textContent = blueCount > 0 ? 'üîµ VICTOIRE BLEUE!' : 'üî¥ VICTOIRE ROUGE!';
            winner.style.color = blueCount > 0 ? '#4facfe' : '#ff6b6b';
            winner.style.display = 'block';
        }

        renderer.render(scene, camera);
    }

    // Start with 5v5
    startBattle(5);
    animate();

    // Window resize
    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
</script>
</body>
</html>