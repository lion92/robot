<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille d'Amour 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .hud, .leaderboard {
            position: fixed;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .hud { top: 20px; left: 20px; }
        .hud h4 { color: #fff; margin-bottom: 15px; font-weight: 600; font-size: 16px; }
        .hud div { font-size: 14px; margin: 8px 0; font-weight: 300; opacity: 0.9; }

        .leaderboard { top: 20px; right: 20px; min-width: 220px; }
        .leaderboard h4 { color: #fff; margin-bottom: 15px; font-weight: 600; font-size: 16px; }
        .leaderboard div { font-size: 12px; margin: 6px 0; font-weight: 300; opacity: 0.9; }

        .timer {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 64px; font-weight: 700; text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            z-index: 200; display: none;
        }

        .controls {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 150;
        }

        .btn {
            padding: 15px 30px; background: linear-gradient(45deg, #667eea, #764ba2);
            border: none; color: white; font-family: inherit; font-weight: 600;
            border-radius: 50px; cursor: pointer; transition: all 0.3s ease;
            font-size: 14px; box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-3px); box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
            background: linear-gradient(45deg, #764ba2, #667eea);
        }

        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .birth-effect {
            position: fixed;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            z-index: 250;
            animation: birthPop 2s ease-out forwards;
        }

        @keyframes birthPop {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 0; }
        }
    </style>
</head>
<body>
<div id="gameContainer"></div>

<div class="hud">
    <h4>üå≥ BATAILLE AU PARC</h4>
    <div>Bataille #<span id="battleNumber">1</span></div>
    <div>Participants: <span id="aliveRobots">12</span></div>
    <div>Zone: <span id="zoneSize">100</span>%</div>
    <div>Total C≈ìurs: <span id="totalKills">0</span></div>
    <div>Naissances: <span id="totalBirths">0</span></div>
    <div>Record: <span id="recordKills">0</span></div>
</div>

<div class="timer" id="timer">3:00</div>

<div class="leaderboard">
    <h4>üíñ CLASSEMENT</h4>
    <div id="leaderboardContent"></div>
</div>

<div class="controls">
    <button class="btn" id="startBtn">üå∏ D√âMARRER BATAILLE</button>
    <button class="btn" id="resetBtn">üîÑ RESET</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Configuration
    const CONFIG = {
        ROBOTS: 12, BATTLE_TIME: 180, OBSTACLES: 6, ROBOT_HP: 100, LOVE: 15,
        ROBOT_SPEED: 0.2, LOVE_COOLDOWN: 800, ARENA_SIZE: 40, DETECTION_RANGE: 30,
        ZONE_SHRINK_RATE: 0.03, AUTO_RESTART: true, RESTART_DELAY: 5000,
        REPRODUCTION_THRESHOLD: 10, MAX_ROBOTS: 30
    };

    const COLORS = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43', '#10ac84', '#ee5a24'];
    const NAMES = ['Amour', 'Tendresse', 'C√¢lin', 'Bisou', 'Sourire', 'Joie', 'Bonheur', 'Rire', 'Espoir', 'R√™ve', 'Magie', 'Charme'];
    const CHILD_SUFFIXES = [' Jr', ' II', ' Mini', ' B√©b√©', ' Petit', ' Doux', ' Mignon', ' Adorable'];

    // Variables globales
    let gameState = 'idle', battleTimer = CONFIG.BATTLE_TIME, battleNumber = 1;
    let currentArenaSize = CONFIG.ARENA_SIZE, robots = [], projectiles = [], obstacles = [];
    let stats = { totalShots: 0, totalKills: 0, totalBirths: 0, startTime: 0 };
    let overallStats = { totalBattles: 0, recordKills: 0, recordHolder: null };
    let scene, camera, renderer, robotMeshes = [], obstacleMeshes = [], projectileMeshes = [];
    let nextRobotId = 0;

    // Initialisation Three.js
    function initThreeJS() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 50, 150); // Bleu ciel pour le parc

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 35, 45);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87ceeb); // Ciel bleu clair
        document.getElementById('gameContainer').appendChild(renderer.domElement);

        // √âclairage naturel du parc
        scene.add(new THREE.AmbientLight(0x404040, 0.8)); // Lumi√®re ambiante plus douce

        // Soleil principal
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);

        // Lumi√®re douce suppl√©mentaire
        const fillLight = new THREE.DirectionalLight(0xfff8dc, 0.4);
        fillLight.position.set(-30, 40, -30);
        scene.add(fillLight);

        // Sol - Herbe du parc
        const floor = new THREE.Mesh(
            new THREE.CircleGeometry(CONFIG.ARENA_SIZE, 32),
            new THREE.MeshLambertMaterial({ color: 0x4a7c59, transparent: true, opacity: 0.9 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Chemin central en pierre
        const path = new THREE.Mesh(
            new THREE.RingGeometry(8, 12, 32),
            new THREE.MeshLambertMaterial({ color: 0x8d8d8d, transparent: true, opacity: 0.8 })
        );
        path.rotation.x = -Math.PI / 2;
        path.position.y = 0.01;
        scene.add(path);

        // Petits chemins
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const smallPath = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.1, 15),
                new THREE.MeshLambertMaterial({ color: 0x8d8d8d })
            );
            smallPath.position.set(Math.cos(angle) * 15, 0.05, Math.sin(angle) * 15);
            smallPath.rotation.y = angle;
            scene.add(smallPath);
        }

        setupControls();
        window.addEventListener('resize', onWindowResize);
    }

    function setupControls() {
        let mouseDown = false, angle = 0, height = 35;

        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);
        document.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                angle += e.movementX * 0.01;
                height = Math.max(20, Math.min(60, height - e.movementY * 0.3));
                updateCamera();
            }
        });
        document.addEventListener('wheel', (e) => {
            height = Math.max(15, Math.min(80, height + e.deltaY * 0.05));
            updateCamera();
        });

        function updateCamera() {
            const distance = 50;
            camera.position.set(Math.sin(angle) * distance, height, Math.cos(angle) * distance);
            camera.lookAt(0, 0, 0);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Initialisation du jeu
    function initGame() {
        robots = []; projectiles = []; obstacles = [];
        currentArenaSize = CONFIG.ARENA_SIZE;
        stats = { totalShots: 0, totalKills: 0, totalBirths: 0, startTime: Date.now() };
        nextRobotId = 0;
        clearMeshes();
        createRobots();
        createObstacles();
        updateArenaVisuals();
        updateUI();
    }

    function clearMeshes() {
        [...robotMeshes, ...obstacleMeshes, ...projectileMeshes].forEach(mesh => scene.remove(mesh));
        robotMeshes = []; obstacleMeshes = []; projectileMeshes = [];
    }

    function createRobots() {
        for (let i = 0; i < CONFIG.ROBOTS; i++) {
            createRobot(i);
        }
    }

    function createRobot(index, parent = null) {
        const angle = Math.random() * Math.PI * 2;
        const radius = CONFIG.ARENA_SIZE * 0.6 + Math.random() * CONFIG.ARENA_SIZE * 0.2;

        const robot = {
            id: nextRobotId++,
            name: parent ? parent.name + CHILD_SUFFIXES[Math.floor(Math.random() * CHILD_SUFFIXES.length)] : NAMES[index % NAMES.length],
            color: parent ? parent.color : COLORS[index % COLORS.length],
            x: parent ? parent.x + (Math.random() - 0.5) * 4 : Math.cos(angle) * radius,
            y: 1.5,
            z: parent ? parent.z + (Math.random() - 0.5) * 4 : Math.sin(angle) * radius,
            vx: 0, vz: 0, health: CONFIG.ROBOT_HP, maxHealth: CONFIG.ROBOT_HP,
            hearts: 0, loves: 0, accuracy: 0, alive: true, size: parent ? 1.3 : 1.5,
            lastLove: 0, target: null, friends: [], happiness: 60,
            kindness: parent ? Math.min(90, parent.kindness + (Math.random() - 0.5) * 20) : 50 + Math.random() * 40,
            charm: parent ? Math.min(80, parent.charm + (Math.random() - 0.5) * 15) : 40 + Math.random() * 35,
            weapon: { type: parent ? parent.weapon.type : ['romantic', 'friendship', 'caring'][Math.floor(Math.random() * 3)] },
            parent: parent ? parent.id : null,
            generation: parent ? parent.generation + 1 : 0,
            hasReproduced: false
        };

        robots.push(robot);
        createRobotMesh(robot);

        if (parent) {
            showBirthEffect(robot);
            stats.totalBirths++;
        }

        return robot;
    }

    function showBirthEffect(robot) {
        const effect = document.createElement('div');
        effect.className = 'birth-effect';
        effect.textContent = 'üë∂üíï';
        effect.style.color = robot.color;

        // Position relative √† l'√©cran
        const vector = new THREE.Vector3(robot.x, robot.y + 2, robot.z);
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

        effect.style.left = x + 'px';
        effect.style.top = y + 'px';

        document.body.appendChild(effect);
        setTimeout(() => document.body.removeChild(effect), 2000);
    }

    function createRobotMesh(robot) {
        const group = new THREE.Group();
        const color = new THREE.Color(robot.color);

        // Taille bas√©e sur la g√©n√©ration
        const scale = robot.generation > 0 ? 0.8 : 1.0;

        // Corps
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.8 * scale, 16, 16),
            new THREE.MeshLambertMaterial({ color: color })
        );
        body.position.y = 1.5;
        body.castShadow = true;
        group.add(body);

        // T√™te
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.5 * scale, 16, 16),
            new THREE.MeshLambertMaterial({ color: color.clone().multiplyScalar(1.2) })
        );
        head.position.y = 2.5 * scale;
        head.castShadow = true;
        group.add(head);

        // Yeux (plus brillants pour les enfants)
        const eyeIntensity = robot.generation > 0 ? 1.2 : 0.8;
        [-0.15, 0.15].forEach(x => {
            const eye = new THREE.Mesh(
                new THREE.SphereGeometry(0.08 * scale, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: 0x4ecdc4,
                    emissive: 0x4ecdc4,
                    emissiveIntensity: eyeIntensity
                })
            );
            eye.position.set(x * scale, 2.6 * scale, 0.4 * scale);
            group.add(eye);
        });

        // Bras
        [-0.6, 0.6].forEach(x => {
            const arm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15 * scale, 0.15 * scale, 1 * scale, 8),
                new THREE.MeshLambertMaterial({ color: color })
            );
            arm.position.set(x * scale, 1.8 * scale, 0);
            arm.castShadow = true;
            group.add(arm);
        });

        // Jambes
        [-0.3, 0.3].forEach(x => {
            const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12 * scale, 0.12 * scale, 1.2 * scale, 8),
                new THREE.MeshLambertMaterial({ color: color })
            );
            leg.position.set(x * scale, 0.6 * scale, 0);
            leg.castShadow = true;
            group.add(leg);
        });

        group.position.set(robot.x, 0, robot.z);
        robotMeshes.push(group);
        scene.add(group);
    }

    function createObstacles() {
        // Fontaine centrale
        createFountain(0, 0);

        // Arbres autour du parc
        const treePositions = [
            {x: 25, z: 10}, {x: -25, z: 10}, {x: 10, z: 25}, {x: -10, z: 25},
            {x: 25, z: -10}, {x: -25, z: -10}, {x: 10, z: -25}, {x: -10, z: -25},
            {x: 20, z: 20}, {x: -20, z: 20}, {x: 20, z: -20}, {x: -20, z: -20}
        ];

        treePositions.forEach(pos => createTree(pos.x, pos.z));

        // Bancs dans le parc
        const benchPositions = [
            {x: 15, z: 0, rotation: 0}, {x: -15, z: 0, rotation: Math.PI},
            {x: 0, z: 15, rotation: -Math.PI/2}, {x: 0, z: -15, rotation: Math.PI/2},
            {x: 18, z: 18, rotation: -Math.PI/4}, {x: -18, z: -18, rotation: Math.PI/4}
        ];

        benchPositions.forEach(pos => createBench(pos.x, pos.z, pos.rotation));

        // Buissons d√©coratifs
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = 30 + Math.random() * 5;
            createBush(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }

        // Fleurs
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 20;
            createFlowers(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
    }

    function createFountain(x, z) {
        const fountain = new THREE.Group();

        // Base de la fontaine
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(3, 4, 1, 16),
            new THREE.MeshLambertMaterial({ color: 0x9da0a4 })
        );
        base.position.y = 0.5;
        base.castShadow = true;
        fountain.add(base);

        // Bassin d'eau
        const water = new THREE.Mesh(
            new THREE.CylinderGeometry(2.8, 2.8, 0.3, 16),
            new THREE.MeshLambertMaterial({ color: 0x4ecdc4, transparent: true, opacity: 0.7 })
        );
        water.position.y = 0.85;
        fountain.add(water);

        // Colonne centrale
        const column = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.4, 2, 8),
            new THREE.MeshLambertMaterial({ color: 0x9da0a4 })
        );
        column.position.y = 2;
        column.castShadow = true;
        fountain.add(column);

        fountain.position.set(x, 0, z);
        scene.add(fountain);

        obstacles.push({ x, y: 1.5, z, width: 6, height: 3, depth: 6 });
    }

    function createTree(x, z) {
        const tree = new THREE.Group();

        // Tronc
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 1.2, 6, 8),
            new THREE.MeshLambertMaterial({ color: 0x8b4513 })
        );
        trunk.position.y = 3;
        trunk.castShadow = true;
        tree.add(trunk);

        // Feuillage - 3 niveaux pour un look plus naturel
        const foliageColors = [0x228b22, 0x32cd32, 0x90ee90];
        for (let i = 0; i < 3; i++) {
            const foliage = new THREE.Mesh(
                new THREE.SphereGeometry(3 - i * 0.5, 8, 6),
                new THREE.MeshLambertMaterial({ color: foliageColors[i] })
            );
            foliage.position.y = 6 + i * 1.5;
            foliage.position.x = (Math.random() - 0.5) * 0.5;
            foliage.position.z = (Math.random() - 0.5) * 0.5;
            foliage.castShadow = true;
            tree.add(foliage);
        }

        tree.position.set(x, 0, z);
        scene.add(tree);

        obstacles.push({ x, y: 4, z, width: 6, height: 8, depth: 6 });
    }

    function createBench(x, z, rotation = 0) {
        const bench = new THREE.Group();

        // Si√®ge
        const seat = new THREE.Mesh(
            new THREE.BoxGeometry(3, 0.3, 1),
            new THREE.MeshLambertMaterial({ color: 0x8b4513 })
        );
        seat.position.y = 1;
        seat.castShadow = true;
        bench.add(seat);

        // Dossier
        const backrest = new THREE.Mesh(
            new THREE.BoxGeometry(3, 2, 0.2),
            new THREE.MeshLambertMaterial({ color: 0x8b4513 })
        );
        backrest.position.y = 2;
        backrest.position.z = -0.4;
        backrest.castShadow = true;
        bench.add(backrest);

        // Pieds
        for (let i = 0; i < 4; i++) {
            const leg = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 1, 0.2),
                new THREE.MeshLambertMaterial({ color: 0x654321 })
            );
            leg.position.x = (i % 2) * 2.6 - 1.3;
            leg.position.z = i < 2 ? 0.4 : -0.4;
            leg.position.y = 0.5;
            leg.castShadow = true;
            bench.add(leg);
        }

        bench.position.set(x, 0, z);
        bench.rotation.y = rotation;
        scene.add(bench);

        obstacles.push({ x, y: 1, z, width: 3.5, height: 2.5, depth: 1.5 });
    }

    function createBush(x, z) {
        const bush = new THREE.Mesh(
            new THREE.SphereGeometry(1 + Math.random() * 0.5, 8, 6),
            new THREE.MeshLambertMaterial({ color: 0x006400 })
        );
        bush.position.set(x, 1, z);
        bush.scale.y = 0.6;
        bush.castShadow = true;
        scene.add(bush);

        obstacles.push({ x, y: 0.6, z, width: 2.5, height: 1.2, depth: 2.5 });
    }

    function createFlowers(x, z) {
        const flowers = new THREE.Group();
        const flowerColors = [0xff69b4, 0xff1493, 0xffb6c1, 0xffc0cb, 0xff6347];

        for (let i = 0; i < 5; i++) {
            const flower = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 4),
                new THREE.MeshBasicMaterial({
                    color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                    emissive: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                    emissiveIntensity: 0.3
                })
            );
            flower.position.set(
                (Math.random() - 0.5) * 2,
                0.1 + Math.random() * 0.2,
                (Math.random() - 0.5) * 2
            );
            flowers.add(flower);

            // Tige
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x228b22 })
            );
            stem.position.set(flower.position.x, 0.15, flower.position.z);
            flowers.add(stem);
        }

        flowers.position.set(x, 0, z);
        scene.add(flowers);
    }

    function updateArenaVisuals() {
        scene.children.forEach(child => {
            if (child.type === 'GridHelper' || child.type === 'PolarGridHelper') {
                scene.remove(child);
            }
        });

        // Grille du parc plus discr√®te
        const grid = new THREE.PolarGridHelper(currentArenaSize, 8, 4, 32, 0x90ee90, 0x90ee90);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // Zone de danger avec effet de brouillard
        if (currentArenaSize < CONFIG.ARENA_SIZE * 0.8) {
            const danger = new THREE.Mesh(
                new THREE.RingGeometry(currentArenaSize, CONFIG.ARENA_SIZE * 1.5, 32),
                new THREE.MeshBasicMaterial({ color: 0x8b0000, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
            );
            danger.rotation.x = -Math.PI / 2;
            danger.position.y = 0.1;
            scene.add(danger);

            // Effet de brouillard plus dense
            scene.fog.near = Math.max(20, currentArenaSize - 10);
            scene.fog.far = currentArenaSize + 20;
        }
    }

    // IA des robots
    function updateRobots() {
        if (gameState !== 'battle') return;

        // Mise √† jour de tous les robots existants
        for (let i = 0; i < robots.length; i++) {
            const robot = robots[i];
            if (!robot.alive) continue;

            updateRobotAI(robot);
            updateRobotMesh(robot, i);

            // V√©rification de la reproduction
            checkReproduction(robot);
        }
    }

    function checkReproduction(robot) {
        if (robot.hearts >= CONFIG.REPRODUCTION_THRESHOLD &&
            !robot.hasReproduced &&
            robots.length < CONFIG.MAX_ROBOTS) {

            robot.hasReproduced = true;
            robot.hearts = Math.max(0, robot.hearts - CONFIG.REPRODUCTION_THRESHOLD); // Co√ªt de reproduction

            // Cr√©er le nouveau robot
            const child = createRobot(robots.length, robot);

            console.log(`üéâ ${robot.name} a donn√© naissance √† ${child.name}!`);
        }
    }

    function updateRobotAI(robot) {
        const now = Date.now();

        // Recherche d'amis
        robot.friends = robots.filter(r =>
            r.alive && r.id !== robot.id && getDistance(robot, r) < CONFIG.DETECTION_RANGE
        ).sort((a, b) => getDistance(robot, a) - getDistance(robot, b));

        // S√©lection de cible (favorise les robots de la m√™me famille)
        if (!robot.target || !robot.target.alive || Math.random() < 0.1) {
            const familyMembers = robot.friends.filter(r => r.parent === robot.parent || r.id === robot.parent || robot.id === r.parent);
            robot.target = familyMembers.length > 0 && Math.random() < 0.7 ?
                familyMembers[0] : (robot.friends[0] || null);
        }

        // Mouvement vers la cible
        if (robot.target) {
            const distance = getDistance(robot, robot.target);
            const dx = robot.target.x - robot.x;
            const dz = robot.target.z - robot.z;

            if (distance > 0) {
                const speed = CONFIG.ROBOT_SPEED * (1 + robot.kindness / 200) * (robot.generation > 0 ? 1.1 : 1.0);
                robot.vx = (dx / distance) * speed;
                robot.vz = (dz / distance) * speed;
                robot.x += robot.vx;
                robot.z += robot.vz;

                // Envoi d'amour
                if (distance < 20 && canSendLove(robot, now)) {
                    sendLove(robot, robot.target, now);
                }
            }
        } else {
            // Patrouille
            robot.vx = (Math.random() - 0.5) * CONFIG.ROBOT_SPEED * 0.5;
            robot.vz = (Math.random() - 0.5) * CONFIG.ROBOT_SPEED * 0.5;
            robot.x += robot.vx;
            robot.z += robot.vz;
        }

        // Limites de l'ar√®ne
        const distance = Math.sqrt(robot.x * robot.x + robot.z * robot.z);
        if (distance > currentArenaSize - 3) {
            robot.x *= 0.9;
            robot.z *= 0.9;
        }
    }

    function getDistance(obj1, obj2) {
        return Math.sqrt((obj1.x - obj2.x) ** 2 + (obj1.z - obj2.z) ** 2);
    }

    function canSendLove(robot, now) {
        const cooldown = robot.generation > 0 ? CONFIG.LOVE_COOLDOWN * 0.8 : CONFIG.LOVE_COOLDOWN;
        return now - robot.lastLove > cooldown;
    }

    function sendLove(robot, target, now) {
        const direction = {
            x: target.x - robot.x,
            z: target.z - robot.z
        };
        const length = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
        direction.x /= length;
        direction.z /= length;

        createLoveProjectile(robot, direction);
        robot.loves++;
        robot.lastLove = now;
        stats.totalShots++;
    }

    function createLoveProjectile(robot, direction) {
        const loveAmount = robot.generation > 0 ? CONFIG.LOVE * 1.2 : CONFIG.LOVE;
        const heart = {
            x: robot.x, y: robot.y + 1, z: robot.z,
            vx: direction.x * 1.5, vz: direction.z * 1.5,
            owner: robot.id, love: loveAmount, life: 100
        };
        projectiles.push(heart);

        const mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xff69b4, emissive: 0xff69b4, emissiveIntensity: 0.6 })
        );
        mesh.position.set(robot.x, robot.y + 1, robot.z);
        projectileMeshes.push(mesh);
        scene.add(mesh);
    }

    function updateRobotMesh(robot, index) {
        const mesh = robotMeshes[index];
        if (!mesh) return;

        mesh.position.set(robot.x, 0, robot.z);

        if (robot.target) {
            const angle = Math.atan2(robot.target.z - robot.z, robot.target.x - robot.x);
            mesh.rotation.y = angle - Math.PI / 2;
        }

        // Animation de marche (plus rapide pour les enfants)
        const isMoving = Math.abs(robot.vx) > 0.01 || Math.abs(robot.vz) > 0.01;
        if (isMoving) {
            const cycleSpeed = robot.generation > 0 ? 0.015 : 0.01;
            const cycle = Date.now() * cycleSpeed;
            if (mesh.children[3]) mesh.children[3].rotation.x = Math.sin(cycle) * 0.3;
            if (mesh.children[4]) mesh.children[4].rotation.x = Math.sin(cycle + Math.PI) * 0.3;
            if (mesh.children[5]) mesh.children[5].rotation.x = Math.sin(cycle + Math.PI) * 0.2;
            if (mesh.children[6]) mesh.children[6].rotation.x = Math.sin(cycle) * 0.2;
        }
    }

    // Syst√®me de projectiles
    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const heart = projectiles[i];
            const mesh = projectileMeshes[i];
            if (!heart || !mesh) continue;

            heart.x += heart.vx;
            heart.z += heart.vz;
            heart.life--;

            mesh.position.set(heart.x, heart.y, heart.z);

            if (heart.life <= 0 || Math.abs(heart.x) > CONFIG.ARENA_SIZE * 2 || Math.abs(heart.z) > CONFIG.ARENA_SIZE * 2) {
                removeProjectile(i);
                continue;
            }

            // Collision avec robots
            for (const robot of robots) {
                if (!robot.alive || robot.id === heart.owner) continue;

                if (getDistance(robot, heart) < robot.size) {
                    robot.hearts += heart.love;
                    robot.happiness = Math.min(100, robot.happiness + 5);

                    const sender = robots.find(r => r.id === heart.owner);
                    if (sender) {
                        sender.hearts++;
                        stats.totalKills++;
                    }

                    removeProjectile(i);
                    break;
                }
            }
        }
    }

    function removeProjectile(index) {
        projectiles.splice(index, 1);
        scene.remove(projectileMeshes[index]);
        projectileMeshes.splice(index, 1);
    }

    // Gestion de la bataille
    function updateBattleZone() {
        const timeElapsed = Date.now() - stats.startTime;
        if (timeElapsed > 20000) {
            currentArenaSize = Math.max(12, currentArenaSize - CONFIG.ZONE_SHRINK_RATE);
            if (Math.floor(timeElapsed / 1000) % 3 === 0) updateArenaVisuals();
        }
    }

    function gameLoop() {
        if (gameState === 'battle') {
            updateRobots();
            updateProjectiles();
            updateBattleZone();
            updateTimer();
            checkWinConditions();
        }
        updateUI();
        renderer.render(scene, camera);
        requestAnimationFrame(gameLoop);
    }

    function updateTimer() {
        battleTimer--;
        if (battleTimer <= 0) endBattle();
        const minutes = Math.floor(battleTimer / 60);
        const seconds = battleTimer % 60;
        document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function checkWinConditions() {
        if (battleTimer <= 0) endBattle();
    }

    function endBattle() {
        gameState = 'ended';
        document.getElementById('timer').style.display = 'none';

        const winner = robots.reduce((best, robot) => robot.hearts > best.hearts ? robot : best, robots[0]);

        overallStats.totalBattles++;
        if (winner.hearts > overallStats.recordKills) {
            overallStats.recordKills = winner.hearts;
            overallStats.recordHolder = winner.name;
        }

        showResults(winner);
        if (CONFIG.AUTO_RESTART) setTimeout(() => startNewBattle(), CONFIG.RESTART_DELAY);
    }

    function showResults(winner) {
        const div = document.createElement('div');
        div.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(20px);
                border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px;
                padding: 30px; color: white; text-align: center; z-index: 300;
            `;

        const generationText = winner.generation > 0 ? ` (Gen ${winner.generation})` : '';
        const familySize = robots.filter(r => r.parent === winner.id || r.id === winner.parent ||
            (winner.parent && r.parent === winner.parent)).length;

        div.innerHTML = `
                <h2 style="color: ${winner.color}; margin-bottom: 20px;">üíï ${winner.name} GAGNE!${generationText}</h2>
                <p>üíñ C≈ìurs re√ßus: ${winner.hearts}</p>
                <p>üíå Messages envoy√©s: ${winner.loves}</p>
                <p>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Famille: ${familySize} membres</p>
                <p>üë∂ Naissances totales: ${stats.totalBirths}</p>
                <p>üèÜ Record: ${overallStats.recordKills}</p>
                <p style="margin-top: 20px; opacity: 0.8;">Prochaine bataille dans ${CONFIG.RESTART_DELAY/1000}s...</p>
            `;
        document.body.appendChild(div);
        setTimeout(() => document.body.removeChild(div), CONFIG.RESTART_DELAY - 500);
    }

    function startNewBattle() {
        battleNumber++;
        gameState = 'battle';
        battleTimer = CONFIG.BATTLE_TIME;
        document.getElementById('timer').style.display = 'block';
        document.getElementById('startBtn').textContent = `üå∏ BATAILLE #${battleNumber}`;
        document.getElementById('startBtn').disabled = true;
        initGame();

        robots.forEach(robot => {
            robot.hearts = 0;
            robot.loves = 0;
            robot.happiness = 60;
            robot.target = null;
            robot.hasReproduced = false;
        });
    }

    function updateUI() {
        const aliveCount = robots.filter(r => r.alive).length;
        const zonePercentage = Math.round((currentArenaSize / CONFIG.ARENA_SIZE) * 100);

        document.getElementById('battleNumber').textContent = battleNumber;
        document.getElementById('aliveRobots').textContent = aliveCount;
        document.getElementById('zoneSize').textContent = zonePercentage;
        document.getElementById('totalKills').textContent = stats.totalKills;
        document.getElementById('totalBirths').textContent = stats.totalBirths;
        document.getElementById('recordKills').textContent = overallStats.recordKills;

        updateLeaderboard();
    }

    function updateLeaderboard() {
        const leaderboard = document.getElementById('leaderboardContent');
        const sorted = [...robots].sort((a, b) => b.hearts - a.hearts);

        leaderboard.innerHTML = '';
        sorted.slice(0, 8).forEach((r, i) => {
            const happinessIcon = r.happiness > 80 ? 'üòä' : r.happiness > 60 ? 'üòê' : 'üòî';
            const generationIcon = r.generation > 0 ? 'üë∂' : 'üë§';
            const reproductionIcon = r.hearts >= CONFIG.REPRODUCTION_THRESHOLD && !r.hasReproduced ? 'ü§∞' : '';

            leaderboard.innerHTML +=
                `<div style="color:${r.color}; font-size: 11px; margin: 4px 0;">
                        ${i + 1}. ${generationIcon} ${r.name} ${happinessIcon} ${reproductionIcon}<br>
                        üíñ ${r.hearts} | üíå ${r.loves} ${r.generation > 0 ? `| G${r.generation}` : ''}
                    </div>`;
        });
    }

    // Contr√¥les
    document.getElementById('startBtn').addEventListener('click', () => {
        if (gameState === 'idle' || gameState === 'ended') startNewBattle();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        gameState = 'idle';
        battleNumber = 1;
        overallStats = { totalBattles: 0, recordKills: 0, recordHolder: null };
        document.getElementById('timer').style.display = 'none';
        document.getElementById('startBtn').textContent = 'üå∏ D√âMARRER BATAILLE';
        document.getElementById('startBtn').disabled = false;
        initGame();
    });

    // Initialisation
    initThreeJS();
    initGame();
    gameLoop();
</script>
</body>
</html>