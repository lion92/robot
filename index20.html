<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky & Sea Battle 3D - Ultimate Naval Air Combat</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            background: #000;
            cursor: crosshair;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Main Menu Enhanced */
        .main-menu {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.98) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            backdrop-filter: blur(30px);
        }

        .menu-content {
            text-align: center;
            animation: menuFadeIn 0.8s ease-out;
        }

        @keyframes menuFadeIn {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .game-title {
            font-size: clamp(48px, 8vw, 96px);
            font-weight: 900;
            background: linear-gradient(135deg, #00ffff, #ff00ff, #ffff00, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 80px rgba(0, 255, 255, 0.8);
            animation: titlePulse 3s ease-in-out infinite;
            letter-spacing: 3px;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .menu-subtitle {
            font-size: 28px;
            background: linear-gradient(90deg, #888, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 60px;
            animation: subtitleSlide 2s ease-in-out infinite;
        }

        @keyframes subtitleSlide {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 25px;
            margin-bottom: 50px;
        }

        .menu-btn {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid transparent;
            background-image: linear-gradient(145deg, #1a1a2e, #16213e),
            linear-gradient(90deg, #00ffff, #ff00ff);
            background-origin: border-box;
            background-clip: padding-box, border-box;
            color: #00ffff;
            padding: 25px 80px;
            font-size: 26px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            border-radius: 20px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(0,255,255,0.3) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .menu-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .menu-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 20px 40px rgba(0, 255, 255, 0.6),
            0 0 80px rgba(255, 0, 255, 0.3);
            color: #ffffff;
        }

        .btn-desc {
            display: block;
            font-size: 16px;
            color: #999;
            margin-top: 8px;
            font-weight: 400;
            letter-spacing: 1px;
        }

        /* Enhanced Controls Info */
        .controls-info {
            background: linear-gradient(145deg, rgba(0,0,0,0.9), rgba(10,10,20,0.9));
            border: 2px solid #444;
            border-radius: 20px;
            padding: 30px;
            text-align: left;
            max-width: 500px;
            margin: 0 auto;
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.2);
        }

        .controls-info h3 {
            color: #00ffff;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .control-item {
            color: #ccc;
            margin: 12px 0;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            background: rgba(0, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.3s;
        }

        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .control-key {
            color: #00ffff;
            font-weight: bold;
        }

        /* Enhanced HUD */
        .hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(0,20,40,0.9));
            border: 2px solid #00ffff;
            border-radius: 25px;
            padding: 20px 40px;
            backdrop-filter: blur(15px);
            z-index: 100;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6),
            inset 0 0 30px rgba(0, 255, 255, 0.1);
        }

        .hud-content {
            display: flex;
            gap: 50px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
            color: #fff;
            transition: transform 0.3s;
        }

        .stat-item:hover {
            transform: scale(1.1);
        }

        .stat-value {
            font-size: 42px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px currentColor;
        }

        .stat-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 5px;
        }

        /* Enhanced Player HUD */
        .player-hud {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(0,40,0,0.95));
            border: 2px solid #00ff00;
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            z-index: 100;
            min-width: 350px;
            box-shadow: 0 0 60px rgba(0, 255, 0, 0.5),
            inset 0 0 40px rgba(0, 255, 0, 0.1);
        }

        .player-stats {
            margin-bottom: 25px;
        }

        .health-bar, .shield-bar, .boost-bar {
            margin-bottom: 20px;
        }

        .bar-label {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
        }

        .bar-container {
            width: 300px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #444;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: barShine 2s infinite;
        }

        @keyframes barShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .health-fill {
            background: linear-gradient(90deg, #00ff00, #00cc00);
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .shield-fill {
            background: linear-gradient(90deg, #00ffff, #0099cc);
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .boost-fill {
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            box-shadow: inset 0 0 10px rgba(255, 102, 0, 0.5);
        }

        .weapon-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 25px;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .weapon-name {
            color: #00ff00;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }

        .ammo-count {
            font-size: 20px;
            color: #00ffff;
        }

        .special-weapon {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.1), rgba(255, 100, 0, 0.1));
            border: 2px solid #ff6600;
            border-radius: 15px;
        }

        .special-status {
            color: #ff6600;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .special-ready {
            color: #00ff00;
            animation: pulse 1s infinite;
            text-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .player-score {
            text-align: center;
            border-top: 2px solid #444;
            padding-top: 20px;
            margin-top: 20px;
        }

        .score-label {
            color: #aaa;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .score-value {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff00, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        /* Enhanced Winner Overlay */
        .winner-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.95) 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(20px);
        }

        .winner-content {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 3px solid #ffd700;
            border-radius: 40px;
            padding: 60px 80px;
            text-align: center;
            box-shadow:
                    0 0 150px rgba(255, 215, 0, 0.6),
                    inset 0 0 80px rgba(255, 215, 0, 0.2),
                    0 20px 60px rgba(0, 0, 0, 0.8);
            animation: winnerEntrance 0.8s ease-out;
        }

        @keyframes winnerEntrance {
            from {
                transform: scale(0.5) rotate(180deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .winner-title {
            font-size: 72px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.9);
            animation: victorySpin 3s ease-in-out infinite;
        }

        @keyframes victorySpin {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
        }

        #winnerName {
            font-size: 56px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #winnerStats {
            font-size: 24px;
            color: #00ffff;
            margin-bottom: 30px;
            line-height: 1.8;
        }

        .menu-btn-small {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            margin: 0 15px;
            font-size: 18px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-btn-small:hover {
            background: linear-gradient(145deg, #16213e, #1a1a2e);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.6);
            color: #ffffff;
        }

        /* Loading Screen Enhanced */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 400;
        }

        .loading-text {
            color: #00ffff;
            font-size: 32px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        .loading-bar {
            width: 400px;
            height: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            width: 0%;
            animation: loadingAnimation 2s ease-out forwards;
        }

        @keyframes loadingAnimation {
            to { width: 100%; }
        }

        /* Notifications Enhanced */
        .notification {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(0,40,60,0.95));
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px 40px;
            color: #00ffff;
            font-size: 20px;
            z-index: 500;
            animation: notifSlide 0.5s ease-out;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes notifSlide {
            from {
                transform: translateX(-50%) translateY(-30px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* AI Generation Display Enhanced */
        .ai-generation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(40,0,40,0.9));
            border: 2px solid #ff00ff;
            border-radius: 15px;
            padding: 15px 30px;
            color: #ff00ff;
            font-size: 18px;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #genNumber {
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }

        /* Radar System */
        .radar {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(0,255,0,0.1) 0%, rgba(0,0,0,0.8) 100%);
            border: 2px solid #00ff00;
            border-radius: 50%;
            z-index: 100;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        .radar-sweep {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00);
            transform-origin: left center;
            animation: radarSweep 3s linear infinite;
        }

        @keyframes radarSweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .radar-blip {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            animation: blipPulse 1s ease-out infinite;
        }

        @keyframes blipPulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* Combat Effects */
        .damage-indicator {
            position: fixed;
            pointer-events: none;
            animation: damageFlash 0.3s;
            z-index: 90;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255,0,0,0.3) 100%);
            inset: 0;
        }

        @keyframes damageFlash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Power-up Indicators */
        .powerup-notification {
            position: fixed;
            top: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(60,60,0,0.9));
            border: 2px solid #ffff00;
            border-radius: 20px;
            padding: 20px 50px;
            color: #ffff00;
            font-size: 24px;
            z-index: 500;
            animation: powerupBounce 0.6s ease-out;
            box-shadow: 0 0 50px rgba(255, 255, 0, 0.7);
        }

        @keyframes powerupBounce {
            0% { transform: translateX(-50%) translateY(-50px) scale(0.5); opacity: 0; }
            60% { transform: translateX(-50%) translateY(10px) scale(1.1); }
            100% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
        }

        /* Combo Counter */
        .combo-counter {
            position: fixed;
            top: 150px;
            right: 30px;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(60,0,0,0.9));
            border: 2px solid #ff0000;
            border-radius: 20px;
            padding: 20px 30px;
            z-index: 100;
            display: none;
        }

        .combo-text {
            color: #ff0000;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .combo-number {
            font-size: 48px;
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 30px rgba(255, 102, 0, 0.8);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-title {
                font-size: 48px;
            }

            .menu-btn {
                padding: 20px 50px;
                font-size: 20px;
            }

            .player-hud {
                bottom: 20px;
                left: 20px;
                min-width: 280px;
                padding: 20px;
            }

            .bar-container {
                width: 240px;
            }

            .radar {
                width: 150px;
                height: 150px;
            }
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- Loading Screen -->
<div class="loading" id="loading">
    <div class="loading-text">Initializing Advanced Combat Systems...</div>
    <div class="loading-bar">
        <div class="loading-progress"></div>
    </div>
</div>

<!-- Main Menu -->
<div class="main-menu" id="mainMenu" style="display: none;">
    <div class="menu-content">
        <h1 class="game-title">SKY & SEA BATTLE</h1>
        <div class="menu-subtitle">Ultimate Naval Air Combat</div>

        <div class="menu-buttons">
            <button class="menu-btn" id="btnPlayerMode">
                🎮 PLAYER MODE
                <span class="btn-desc">Pilot your own advanced fighter jet</span>
            </button>

            <button class="menu-btn" id="btnMixedMode">
                🎮+🤖 PLAYER VS AI
                <span class="btn-desc">Battle against elite AI squadrons</span>
            </button>

            <button class="menu-btn" id="btnAIMode">
                🤖 AI BATTLE ROYALE
                <span class="btn-desc">Watch AI battles with 5000 generations</span>
            </button>
        </div>

        <div class="controls-info">
            <h3>🎮 Player Controls</h3>
            <div class="control-item">
                <span class="control-key">↑↓</span>
                <span>Pitch Control</span>
            </div>
            <div class="control-item">
                <span class="control-key">←→</span>
                <span>Roll & Turn</span>
            </div>
            <div class="control-item">
                <span class="control-key">SPACE</span>
                <span>Fire Weapon</span>
            </div>
            <div class="control-item">
                <span class="control-key">SHIFT</span>
                <span>Afterburner Boost</span>
            </div>
            <div class="control-item">
                <span class="control-key">E</span>
                <span>Nuclear Missile ☢️</span>
            </div>
            <div class="control-item">
                <span class="control-key">Q</span>
                <span>Cycle Weapons</span>
            </div>
            <div class="control-item">
                <span class="control-key">R</span>
                <span>Repair Drone 🔧</span>
            </div>
            <div class="control-item">
                <span class="control-key">TAB</span>
                <span>Target Lock 🎯</span>
            </div>
        </div>
    </div>
</div>

<!-- Radar System -->
<div class="radar" id="radar" style="display: none;">
    <div class="radar-sweep"></div>
    <div id="radarBlips"></div>
</div>

<!-- Player HUD -->
<div class="player-hud" id="playerHUD" style="display: none;">
    <div class="player-stats">
        <div class="health-bar">
            <div class="bar-label">
                <span>HULL INTEGRITY</span>
                <span id="healthValue">100%</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill health-fill" id="playerHealthBar" style="width: 100%;"></div>
            </div>
        </div>
        <div class="shield-bar">
            <div class="bar-label">
                <span>SHIELD ENERGY</span>
                <span id="shieldValue">100%</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill shield-fill" id="playerShieldBar" style="width: 100%;"></div>
            </div>
        </div>
        <div class="boost-bar">
            <div class="bar-label">
                <span>AFTERBURNER</span>
                <span id="boostValue">100%</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill boost-fill" id="playerBoostBar" style="width: 100%;"></div>
            </div>
        </div>
        <div class="weapon-info">
            <div class="weapon-name" id="playerWeapon">PLASMA CANNON</div>
            <div class="ammo-count" id="playerAmmo">∞</div>
        </div>
        <div class="special-weapon">
            <div class="special-status" id="specialStatus">
                <span style="font-size: 24px;">☢️</span> NUCLEAR ARSENAL
                <div class="special-ready" id="specialReady">ARMED</div>
            </div>
        </div>
    </div>
    <div class="player-score">
        <div class="score-label">Combat Score</div>
        <div class="score-value" id="playerScore">0</div>
    </div>
</div>

<!-- HUD -->
<div class="hud" id="hud" style="display: none;">
    <div class="hud-content">
        <div class="stat-item">
            <div class="stat-value" id="aliveCount">0</div>
            <div class="stat-label">Survivors</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timer">0:00</div>
            <div class="stat-label">Battle Time</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="killCount">0</div>
            <div class="stat-label">Eliminations</div>
        </div>
    </div>
</div>

<!-- Combo Counter -->
<div class="combo-counter" id="comboCounter">
    <div class="combo-text">COMBO</div>
    <div class="combo-number" id="comboNumber">x2</div>
</div>

<!-- Winner Overlay -->
<div class="winner-overlay" id="winnerOverlay">
    <div class="winner-content">
        <div class="winner-title">🏆 VICTORY 🏆</div>
        <div id="winnerName"></div>
        <div id="winnerStats"></div>
        <div style="color: #888; margin-top: 30px;">
            <span id="restartText">New battle in <span id="countdown">5</span>...</span>
            <div id="menuButtons" style="display: none; margin-top: 30px;">
                <button class="menu-btn-small" id="btnRestart">Play Again</button>
                <button class="menu-btn-small" id="btnMenu">Main Menu</button>
            </div>
        </div>
    </div>
</div>

<!-- AI Generation Display -->
<div class="ai-generation" id="aiGeneration" style="display: none;">
    AI Generation: <span id="genNumber">5000</span>
</div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // ========================
    // ENHANCED GAME SYSTEM
    // ========================

    window.addEventListener('load', function() {
        // Enhanced Configuration
        const CONFIG = {
            SHIPS: 6,
            ARENA_SIZE: 600,
            SHIP_SPEED: 10,
            BOOST_SPEED: 18,
            BOOST_MAX: 100,
            LASER_SPEED: 30,
            SHIP_HP: 100,
            SHIELD_HP: 50,
            SHIELD_REGEN: 0.1,
            DAMAGE: 20,
            MIN_HEIGHT: 30,
            MAX_HEIGHT: 400,
            BATTLE_TIME: 600,
            BOOST_DRAIN: 2,
            BOOST_RECHARGE: 0.5,
            AI_DIFFICULTY: 'EXTREME',
            GRAVITY: 0.3,
            DRAG: 0.92,
            POWERUP_SPAWN_TIME: 10000,
            COMBO_TIMEOUT: 3000
        };

        // Global variables
        let scene, camera, renderer;
        let ships = [];
        let lasers = [];
        let missiles = [];
        let powerups = [];
        let particles = [];
        let gameState = 'menu';
        let gameMode = 'ai';
        let playerShip = null;
        let timer = CONFIG.BATTLE_TIME;
        let soundEnabled = true;
        let totalKills = 0;
        let comboKills = 0;
        let lastKillTime = 0;

        // Enhanced Audio System
        let audioContext;
        let sounds = {};
        let masterVolume = 0.5;

        // Weather System
        let weather = {
            fog: 0.002,
            rain: false,
            lightning: false,
            wind: new THREE.Vector3(0, 0, 0)
        };

        // Initialize Enhanced Audio
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create more sophisticated sounds
                sounds.shoot = createSound(200, 0.1, 'square', [
                    {freq: 200, time: 0},
                    {freq: 150, time: 0.05},
                    {freq: 100, time: 0.1}
                ]);

                sounds.explosion = createSound(50, 0.5, 'sawtooth', [
                    {freq: 100, time: 0},
                    {freq: 50, time: 0.2},
                    {freq: 20, time: 0.5}
                ]);

                sounds.hit = createSound(300, 0.15, 'triangle');
                sounds.powerup = createSound(400, 0.3, 'sine', [
                    {freq: 400, time: 0},
                    {freq: 600, time: 0.1},
                    {freq: 800, time: 0.2},
                    {freq: 600, time: 0.3}
                ]);

                sounds.boost = createSound(150, 0.4, 'sawtooth');
                sounds.missile = createSound(80, 0.6, 'sawtooth');
                sounds.shield = createSound(500, 0.2, 'sine');
                sounds.alarm = createSound(440, 0.3, 'square', [
                    {freq: 440, time: 0},
                    {freq: 0, time: 0.15},
                    {freq: 440, time: 0.15},
                    {freq: 0, time: 0.3}
                ]);

            } catch (e) {
                console.log('Enhanced audio not supported');
                soundEnabled = false;
            }
        }

        // Create enhanced sound with envelope
        function createSound(frequency, duration, type, envelope) {
            return () => {
                if (!soundEnabled || !audioContext) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = type;
                filter.type = 'lowpass';
                filter.frequency.value = frequency * 4;

                if (envelope) {
                    envelope.forEach(point => {
                        if (point.freq > 0) {
                            oscillator.frequency.setValueAtTime(point.freq, audioContext.currentTime + point.time);
                        }
                    });
                } else {
                    oscillator.frequency.value = frequency;
                }

                gainNode.gain.setValueAtTime(0.3 * masterVolume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            };
        }

        // Play sound with variations
        function playSound(soundName, pitch = 1) {
            if (sounds[soundName]) {
                const originalSound = sounds[soundName];
                if (pitch !== 1) {
                    // Create a pitched version
                    const pitchedSound = () => {
                        if (!soundEnabled || !audioContext) return;
                        // Implementation for pitched sound
                        originalSound();
                    };
                    pitchedSound();
                } else {
                    originalSound();
                }
            }
        }

        // Enhanced notification system
        function showNotification(text, type = 'normal') {
            const notif = document.createElement('div');
            notif.className = type === 'powerup' ? 'powerup-notification' : 'notification';
            notif.innerHTML = text;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => notif.remove(), 500);
            }, 2500);
        }

        // Show damage indicator
        function showDamageIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'damage-indicator';
            document.body.appendChild(indicator);
            setTimeout(() => indicator.remove(), 300);
        }

        // Update combo counter
        function updateCombo() {
            const now = Date.now();
            if (now - lastKillTime < CONFIG.COMBO_TIMEOUT) {
                comboKills++;
                document.getElementById('comboCounter').style.display = 'block';
                document.getElementById('comboNumber').textContent = `x${comboKills}`;

                if (comboKills >= 3) {
                    showNotification(`🔥 ${comboKills}x COMBO! +${comboKills * 50} POINTS`, 'powerup');
                    if (playerShip) {
                        playerShip.score += comboKills * 50;
                    }
                }
            } else {
                comboKills = 1;
            }
            lastKillTime = now;
        }

        // Hide combo counter
        function hideCombo() {
            setTimeout(() => {
                if (Date.now() - lastKillTime > CONFIG.COMBO_TIMEOUT) {
                    document.getElementById('comboCounter').style.display = 'none';
                    comboKills = 0;
                }
            }, CONFIG.COMBO_TIMEOUT);
        }

        // Update radar
        function updateRadar() {
            if (!playerShip || !playerShip.alive) return;

            const radarBlips = document.getElementById('radarBlips');
            radarBlips.innerHTML = '';

            ships.forEach(ship => {
                if (ship !== playerShip && ship.alive) {
                    const dx = ship.mesh.position.x - playerShip.mesh.position.x;
                    const dz = ship.mesh.position.z - playerShip.mesh.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < 500) {
                        const scale = 90 / 500; // Radar radius / max distance
                        const blipX = 100 + dx * scale;
                        const blipY = 100 + dz * scale;

                        const blip = document.createElement('div');
                        blip.className = 'radar-blip';
                        blip.style.left = blipX + 'px';
                        blip.style.top = blipY + 'px';
                        blip.style.background = ship.isHostile ? '#ff0000' : '#00ff00';
                        radarBlips.appendChild(blip);
                    }
                }
            });
        }

        // Enhanced AI Evolution System with 5000 generations
        class AIEvolutionSystem {
            constructor() {
                this.generation = 5000;
                this.trainingComplete = true;

                // Enhanced neural network weights after 5000 generations
                this.neuralWeights = {
                    // Advanced movement patterns
                    dodgePatterns: [
                        { pattern: 'quantum_phase', weight: 0.98, effectiveness: 0.96 },
                        { pattern: 'spiral_climb', weight: 0.95, effectiveness: 0.93 },
                        { pattern: 'cobra_maneuver', weight: 0.94, effectiveness: 0.92 },
                        { pattern: 'kulbit', weight: 0.93, effectiveness: 0.91 },
                        { pattern: 'pugachev_cobra', weight: 0.93, effectiveness: 0.90 },
                        { pattern: 'herbst_maneuver', weight: 0.92, effectiveness: 0.89 },
                        { pattern: 'barrel_roll_attack', weight: 0.91, effectiveness: 0.88 },
                        { pattern: 'chandelle', weight: 0.90, effectiveness: 0.87 },
                        { pattern: 'split_s', weight: 0.89, effectiveness: 0.86 },
                        { pattern: 'immelman_turn', weight: 0.88, effectiveness: 0.85 }
                    ],

                    // Enhanced combat tactics
                    combatTactics: {
                        optimalDistance: { min: 200, max: 300 },
                        leadCalculation: 1.42, // Perfected through evolution
                        burstFireDelay: 45,
                        burstSize: 4,
                        targetSwitchDelay: 2000,
                        evasionThreshold: 180,
                        missileLockTime: 1500,

                        // Advanced targeting
                        targetPriority: {
                            lowHealth: 3.0,
                            distance: 2.0,
                            threat: 2.5,
                            playerBonus: 4.0,
                            currentTarget: 1.8,
                            speed: 1.5,
                            weaponType: 1.3
                        },

                        // Weapon selection
                        weaponStrategy: {
                            plasma: { range: [150, 300], accuracy: 0.9 },
                            laser: { range: [100, 400], accuracy: 0.95 },
                            rockets: { range: [200, 500], accuracy: 0.8 },
                            nuclear: { range: [300, 1000], cooldown: 30000 }
                        }
                    },

                    // Enhanced awareness
                    awareness: {
                        threatDetectionRange: 500,
                        peripheralVision: Math.PI * 0.85,
                        reactionTime: 80, // ms
                        predictionAccuracy: 0.95,
                        spatialMemory: 50,
                        futureProjection: 2.0, // seconds

                        // Threat assessment
                        threatFactors: {
                            distance: 0.35,
                            speed: 0.25,
                            heading: 0.20,
                            altitude: 0.10,
                            weaponPower: 0.10
                        }
                    },

                    // Advanced behaviors
                    behaviors: {
                        aggressive: {
                            engagementRange: 400,
                            pursuitIntensity: 0.95,
                            retreatThreshold: 0.15,
                            riskTolerance: 0.8
                        },
                        defensive: {
                            engagementRange: 250,
                            pursuitIntensity: 0.4,
                            retreatThreshold: 0.5,
                            riskTolerance: 0.3
                        },
                        tactical: {
                            engagementRange: 320,
                            pursuitIntensity: 0.7,
                            retreatThreshold: 0.3,
                            riskTolerance: 0.5
                        },
                        stealth: {
                            engagementRange: 200,
                            pursuitIntensity: 0.3,
                            retreatThreshold: 0.6,
                            riskTolerance: 0.2
                        }
                    },

                    // Team coordination
                    teamwork: {
                        formationFlying: true,
                        targetSharing: true,
                        coordinatedAttacks: true,
                        supportThreshold: 0.4,
                        communicationRange: 800
                    }
                };

                // Enhanced combat knowledge
                this.combatKnowledge = {
                    successfulEngagements: 487392,
                    totalEngagements: 500000,
                    survivalRate: 0.975,
                    averageKillsPerMatch: 3.2,
                    perfectGames: 8476,

                    // Advanced counter-strategies
                    counterStrategies: new Map([
                        ['aggressive_pursuit', 'quantum_phase_escape'],
                        ['defensive_circle', 'vertical_spiral_attack'],
                        ['head_on_attack', 'cobra_dodge'],
                        ['tail_chase', 'kulbit_reversal'],
                        ['missile_lock', 'chaff_barrel_roll'],
                        ['group_attack', 'divide_conquer'],
                        ['altitude_advantage', 'terrain_masking']
                    ]),

                    // Learned combos
                    comboMoves: [
                        ['barrel_roll', 'split_s', 'missile'],
                        ['climb', 'stall', 'dive_attack'],
                        ['fake_retreat', 'ambush_turn', 'burst_fire'],
                        ['scissors', 'displacement_roll', 'snapshot']
                    ]
                };
            }

            getOptimalStrategy(situation) {
                const healthRatio = situation.health / 150;
                const enemyCount = situation.enemies;
                const threatLevel = situation.threatLevel;

                // Advanced strategy selection
                if (healthRatio < 0.2) return 'stealth';
                if (healthRatio < 0.4 && enemyCount > 2) return 'defensive';
                if (enemyCount === 1 && healthRatio > 0.8) return 'aggressive';
                if (threatLevel > 0.7) return 'tactical';

                // Dynamic strategy based on game time
                const gameProgress = (CONFIG.BATTLE_TIME - timer) / CONFIG.BATTLE_TIME;
                if (gameProgress > 0.8 && healthRatio > 0.6) return 'aggressive';

                return 'tactical';
            }

            predictFuture(ship, target, time) {
                // Advanced prediction using learned patterns
                const velocity = target.velocity.clone();
                const acceleration = target.acceleration || new THREE.Vector3();

                // Predict position
                const futurePos = target.mesh.position.clone();
                futurePos.add(velocity.clone().multiplyScalar(time));
                futurePos.add(acceleration.clone().multiplyScalar(0.5 * time * time));

                // Account for behavior patterns
                const behaviorMod = this.predictBehavior(target, time);
                futurePos.add(behaviorMod);

                return futurePos;
            }

            predictBehavior(target, time) {
                // Predict evasive maneuvers based on 5000 generations of learning
                const mod = new THREE.Vector3();

                if (target.ai && target.ai.state.currentManeuver) {
                    const maneuver = target.ai.state.currentManeuver;
                    const pattern = this.neuralWeights.dodgePatterns.find(p => p.pattern === maneuver);

                    if (pattern) {
                        // Apply learned pattern prediction
                        mod.x = Math.sin(time * pattern.weight) * 50;
                        mod.y = Math.cos(time * pattern.effectiveness) * 30;
                        mod.z = Math.sin(time * pattern.weight * 0.7) * 50;
                    }
                }

                return mod;
            }
        }

        // Elite AI with advanced capabilities
        class EliteAI {
            constructor(ship) {
                this.ship = ship;
                this.evolution = new AIEvolutionSystem();
                this.weights = this.evolution.neuralWeights;

                // Enhanced state management
                this.state = {
                    mode: 'searching',
                    currentManeuver: null,
                    maneuverProgress: 0,
                    lastDodgeTime: 0,
                    burstFireCount: 0,
                    targetLockTime: 0,
                    weaponHeat: 0,
                    currentWeapon: 'plasma',
                    teamRole: 'fighter' // fighter, support, hunter
                };

                // Enhanced memory
                this.memory = {
                    positions: [],
                    enemyData: new Map(),
                    threats: [],
                    lastHit: null,
                    damageHistory: [],
                    killList: [],
                    teamPositions: new Map()
                };

                // Performance tracking
                this.stats = {
                    shotsFired: 0,
                    shotsHit: 0,
                    damageDealt: 0,
                    damageTaken: 0,
                    kills: 0,
                    maneuversExecuted: 0,
                    missilesFired: 0,
                    powerupsCollected: 0,
                    assists: 0
                };

                // Dynamic behavior
                this.behaviorProfile = this.weights.behaviors.tactical;
                this.personality = this.generatePersonality();
            }

            generatePersonality() {
                // Each AI has unique traits
                return {
                    aggression: 0.5 + Math.random() * 0.5,
                    caution: 0.3 + Math.random() * 0.7,
                    teamwork: 0.4 + Math.random() * 0.6,
                    accuracy: 0.7 + Math.random() * 0.3,
                    reflexes: 0.8 + Math.random() * 0.2
                };
            }

            update() {
                this.updateMemory();
                this.analyzeSituation();
                this.selectStrategy();
                this.executeStrategy();
                this.updateTeamCoordination();
                this.checkPowerups();
            }

            updateMemory() {
                // Record position
                this.memory.positions.push({
                    pos: this.ship.mesh.position.clone(),
                    rot: this.ship.mesh.rotation.clone(),
                    vel: this.ship.velocity.clone(),
                    time: Date.now()
                });

                // Maintain memory limit
                if (this.memory.positions.length > this.weights.awareness.spatialMemory) {
                    this.memory.positions.shift();
                }

                // Update enemy tracking
                ships.forEach(enemy => {
                    if (enemy !== this.ship && enemy.alive) {
                        if (!this.memory.enemyData.has(enemy)) {
                            this.memory.enemyData.set(enemy, {
                                positions: [],
                                velocities: [],
                                lastSeen: Date.now(),
                                threatLevel: 0,
                                behavior: 'unknown',
                                predictedPath: [],
                                weaponType: 'unknown',
                                lastFired: 0,
                                accuracy: 0
                            });
                        }

                        const data = this.memory.enemyData.get(enemy);
                        data.positions.push(enemy.mesh.position.clone());
                        data.velocities.push(enemy.velocity.clone());
                        data.lastSeen = Date.now();

                        // Advanced behavior analysis
                        if (data.positions.length > 10) {
                            data.behavior = this.analyzeEnemyBehavior(data);
                            data.predictedPath = this.predictPath(data);
                            data.positions = data.positions.slice(-30);
                            data.velocities = data.velocities.slice(-30);
                        }

                        // Calculate dynamic threat level
                        data.threatLevel = this.calculateThreatLevel(enemy, data);
                    }
                });

                // Clean old enemy data
                this.memory.enemyData.forEach((data, enemy) => {
                    if (!enemy.alive || Date.now() - data.lastSeen > 5000) {
                        this.memory.enemyData.delete(enemy);
                    }
                });
            }

            analyzeEnemyBehavior(data) {
                // Advanced pattern recognition
                const positions = data.positions;
                const velocities = data.velocities;

                // Calculate movement patterns
                let aggressiveness = 0;
                let evasiveness = 0;
                let altitude_preference = 0;

                for (let i = 1; i < positions.length; i++) {
                    const speed = velocities[i].length();
                    const direction_change = velocities[i].angleTo(velocities[i-1]);
                    const altitude_change = positions[i].y - positions[i-1].y;

                    aggressiveness += speed > 15 ? 1 : 0;
                    evasiveness += direction_change > 0.5 ? 1 : 0;
                    altitude_preference += altitude_change;
                }

                // Normalize
                const samples = positions.length - 1;
                aggressiveness /= samples;
                evasiveness /= samples;
                altitude_preference /= samples;

                // Classify behavior
                if (aggressiveness > 0.7 && evasiveness < 0.3) return 'aggressive_hunter';
                if (aggressiveness < 0.3 && evasiveness > 0.7) return 'defensive_evader';
                if (altitude_preference > 5) return 'altitude_fighter';
                if (Math.abs(altitude_preference) < 1) return 'level_fighter';

                return 'balanced_fighter';
            }

            predictPath(data) {
                // Use AI evolution to predict enemy movement
                const path = [];
                const lastPos = data.positions[data.positions.length - 1];
                const lastVel = data.velocities[data.velocities.length - 1];

                for (let t = 0.5; t <= 3; t += 0.5) {
                    const predicted = this.evolution.predictFuture(this.ship, {
                        mesh: { position: lastPos },
                        velocity: lastVel,
                        ai: { state: { currentManeuver: null } }
                    }, t);
                    path.push(predicted);
                }

                return path;
            }

            calculateThreatLevel(enemy, data) {
                const factors = this.weights.awareness.threatFactors;
                let threat = 0;

                // Distance factor
                const distance = this.ship.mesh.position.distanceTo(enemy.mesh.position);
                threat += (1 / distance) * factors.distance * 100;

                // Speed factor
                const speed = enemy.velocity.length();
                threat += speed * factors.speed;

                // Heading factor (is enemy facing us?)
                const toUs = new THREE.Vector3().subVectors(
                    this.ship.mesh.position,
                    enemy.mesh.position
                ).normalize();
                const enemyForward = new THREE.Vector3(0, 0, -1);
                enemyForward.applyQuaternion(enemy.mesh.quaternion);
                const facingUs = enemyForward.dot(toUs);
                threat += Math.max(0, facingUs) * factors.heading * 50;

                // Altitude advantage
                const altitudeDiff = enemy.mesh.position.y - this.ship.mesh.position.y;
                threat += Math.max(0, altitudeDiff) * factors.altitude;

                // Weapon power
                if (enemy.isPlayer) {
                    threat += factors.weaponPower * 50;
                }

                // Health factor
                const healthRatio = enemy.health / CONFIG.SHIP_HP;
                threat *= healthRatio;

                return Math.min(100, threat);
            }

            analyzeSituation() {
                // Clear threats
                this.memory.threats = [];

                // Detect laser threats
                lasers.forEach(laser => {
                    if (laser.owner !== this.ship) {
                        const distance = this.ship.mesh.position.distanceTo(laser.mesh.position);

                        if (distance < this.weights.awareness.threatDetectionRange) {
                            const laserDir = laser.velocity.clone().normalize();
                            const toShip = new THREE.Vector3().subVectors(
                                this.ship.mesh.position,
                                laser.mesh.position
                            );

                            // Calculate intercept
                            const timeToImpact = this.calculateIntercept(
                                laser.mesh.position,
                                laser.velocity,
                                this.ship.mesh.position,
                                this.ship.velocity
                            );

                            if (timeToImpact > 0 && timeToImpact < 2) {
                                this.memory.threats.push({
                                    type: 'laser',
                                    position: laser.mesh.position.clone(),
                                    velocity: laser.velocity.clone(),
                                    distance: distance,
                                    timeToImpact: timeToImpact,
                                    damage: laser.damage || CONFIG.DAMAGE
                                });
                            }
                        }
                    }
                });

                // Detect missile threats
                missiles.forEach(missile => {
                    if (missile.owner !== this.ship) {
                        const distance = this.ship.mesh.position.distanceTo(missile.mesh.position);

                        if (distance < this.weights.awareness.threatDetectionRange) {
                            this.memory.threats.push({
                                type: 'missile',
                                position: missile.mesh.position.clone(),
                                velocity: missile.velocity.clone(),
                                distance: distance,
                                tracking: missile.target === this.ship,
                                damage: 200
                            });
                        }
                    }
                });

                // Detect ship threats
                this.memory.enemyData.forEach((data, enemy) => {
                    if (enemy.alive && data.threatLevel > 20) {
                        this.memory.threats.push({
                            type: 'ship',
                            enemy: enemy,
                            distance: this.ship.mesh.position.distanceTo(enemy.mesh.position),
                            threatLevel: data.threatLevel,
                            behavior: data.behavior
                        });
                    }
                });

                // Sort threats by priority
                this.memory.threats.sort((a, b) => {
                    if (a.type === 'missile' && b.type !== 'missile') return -1;
                    if (b.type === 'missile' && a.type !== 'missile') return 1;

                    const aThreat = a.damage ? a.damage / (a.timeToImpact || 1) : a.threatLevel;
                    const bThreat = b.damage ? b.damage / (b.timeToImpact || 1) : b.threatLevel;

                    return bThreat - aThreat;
                });

                // Calculate situation
                const healthRatio = (this.ship.health + this.ship.shield) / 150;
                const enemyCount = ships.filter(s => s !== this.ship && s.alive).length;
                const immediateThreats = this.memory.threats.filter(t =>
                    (t.type === 'laser' && t.timeToImpact < 0.5) ||
                    (t.type === 'missile' && t.distance < 200)
                ).length;

                this.situation = {
                    health: this.ship.health + this.ship.shield,
                    healthRatio: healthRatio,
                    enemies: enemyCount,
                    threats: this.memory.threats.length,
                    immediateThreats: immediateThreats,
                    hasTarget: this.ship.target && this.ship.target.alive,
                    threatLevel: this.memory.threats.reduce((sum, t) => sum + (t.threatLevel || 50), 0) / 100,
                    altitude: this.ship.mesh.position.y,
                    speed: this.ship.velocity.length()
                };
            }

            calculateIntercept(shooterPos, shooterVel, targetPos, targetVel) {
                // Advanced intercept calculation
                const relPos = new THREE.Vector3().subVectors(targetPos, shooterPos);
                const relVel = new THREE.Vector3().subVectors(targetVel, shooterVel);

                const a = relVel.lengthSq();
                const b = 2 * relPos.dot(relVel);
                const c = relPos.lengthSq();

                const discriminant = b * b - 4 * a * c;

                if (discriminant < 0 || a === 0) return -1;

                const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
                const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);

                if (t1 > 0) return t1;
                if (t2 > 0) return t2;

                return -1;
            }

            selectStrategy() {
                // Dynamic strategy selection based on evolved knowledge
                const strategy = this.evolution.getOptimalStrategy(this.situation);
                this.behaviorProfile = this.weights.behaviors[strategy];

                // Determine role in battle
                if (this.situation.enemies === 1) {
                    this.state.teamRole = 'hunter';
                } else if (this.situation.healthRatio < 0.5) {
                    this.state.teamRole = 'support';
                } else {
                    this.state.teamRole = 'fighter';
                }

                // Select action mode
                if (this.situation.immediateThreats > 0) {
                    this.state.mode = 'emergency_evade';
                } else if (this.memory.threats.some(t => t.type === 'missile' && t.tracking)) {
                    this.state.mode = 'missile_evade';
                } else if (this.ship.target && this.ship.target.alive) {
                    const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);

                    if (distance < this.behaviorProfile.engagementRange) {
                        this.state.mode = 'attacking';
                    } else {
                        this.state.mode = 'pursuing';
                    }
                } else {
                    this.state.mode = 'searching';
                    this.selectTarget();
                }

                // Weapon selection
                this.selectWeapon();
            }

            selectTarget() {
                let bestTarget = null;
                let bestScore = -Infinity;

                this.memory.enemyData.forEach((data, enemy) => {
                    if (enemy.alive) {
                        const distance = this.ship.mesh.position.distanceTo(enemy.mesh.position);
                        const healthRatio = enemy.health / CONFIG.SHIP_HP;

                        // Calculate priority score using evolved weights
                        let score = 0;

                        // Basic factors
                        score += (1 - healthRatio) * this.weights.combatTactics.targetPriority.lowHealth;
                        score += (1 / distance) * this.weights.combatTactics.targetPriority.distance * 1000;
                        score += data.threatLevel * this.weights.combatTactics.targetPriority.threat;

                        // Speed factor
                        const relativeSpeed = enemy.velocity.length() / CONFIG.SHIP_SPEED;
                        score += relativeSpeed * this.weights.combatTactics.targetPriority.speed;

                        // Player priority
                        if (enemy.isPlayer) {
                            score *= this.weights.combatTactics.targetPriority.playerBonus;
                        }

                        // Current target bonus
                        if (enemy === this.ship.target) {
                            score *= this.weights.combatTactics.targetPriority.currentTarget;
                        }

                        // Team coordination - avoid same targets
                        let teamTargeting = 0;
                        ships.forEach(ally => {
                            if (ally !== this.ship && ally.alive && ally.target === enemy) {
                                teamTargeting++;
                            }
                        });
                        score /= (1 + teamTargeting * 0.5);

                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = enemy;
                        }
                    }
                });

                if (bestTarget !== this.ship.target) {
                    this.ship.target = bestTarget;
                    this.state.targetLockTime = Date.now();
                }
            }

            selectWeapon() {
                if (!this.ship.target) return;

                const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);
                const targetSpeed = this.ship.target.velocity.length();
                const targetHealth = this.ship.target.health;

                // Select optimal weapon based on situation
                const weapons = this.weights.combatTactics.weaponStrategy;

                if (distance >= weapons.rockets.range[0] && distance <= weapons.rockets.range[1] &&
                    targetHealth > 50 && this.state.weaponHeat < 50) {
                    this.state.currentWeapon = 'rockets';
                } else if (distance >= weapons.laser.range[0] && distance <= weapons.laser.range[1] &&
                    targetSpeed > 12) {
                    this.state.currentWeapon = 'laser';
                } else {
                    this.state.currentWeapon = 'plasma';
                }
            }

            executeStrategy() {
                switch (this.state.mode) {
                    case 'emergency_evade':
                        this.executeEmergencyEvasion();
                        break;
                    case 'missile_evade':
                        this.executeMissileEvasion();
                        break;
                    case 'attacking':
                        this.executeAttack();
                        break;
                    case 'pursuing':
                        this.executePursuit();
                        break;
                    case 'searching':
                        this.executeSearch();
                        break;
                }

                // Always check for opportunities
                if (this.ship.target && this.ship.target.alive) {
                    this.attemptFire();
                }

                // Manage special weapons
                this.manageSpecialWeapons();
            }

            executeEmergencyEvasion() {
                const now = Date.now();

                // Select and execute advanced evasion pattern
                if (!this.state.currentManeuver || now - this.state.lastDodgeTime > 300) {
                    // Pick from top patterns based on threat type
                    const threat = this.memory.threats[0];
                    let pattern;

                    if (threat.type === 'missile') {
                        pattern = ['quantum_phase', 'barrel_roll_attack', 'cobra_maneuver'];
                    } else {
                        pattern = ['spiral_climb', 'kulbit', 'split_s'];
                    }

                    this.state.currentManeuver = pattern[Math.floor(Math.random() * pattern.length)];
                    this.state.maneuverProgress = 0;
                    this.state.lastDodgeTime = now;
                    this.stats.maneuversExecuted++;
                }

                this.executeManeuver(this.state.currentManeuver);

                // Deploy countermeasures
                if (Math.random() < 0.1) {
                    this.deployCountermeasures();
                }
            }

            executeMissileEvasion() {
                // Advanced missile evasion tactics
                const missileThreat = this.memory.threats.find(t => t.type === 'missile' && t.tracking);

                if (missileThreat) {
                    // Calculate optimal evasion vector
                    const missileDir = missileThreat.velocity.clone().normalize();
                    const perpVector = new THREE.Vector3();
                    perpVector.crossVectors(missileDir, new THREE.Vector3(0, 1, 0));
                    perpVector.normalize();

                    // Spiral evasion with altitude changes
                    const evasionAngle = Date.now() * 0.01;
                    this.ship.velocity.add(perpVector.multiplyScalar(Math.sin(evasionAngle) * 5));
                    this.ship.velocity.y += Math.cos(evasionAngle) * 3;

                    // Boost if available
                    if (this.ship.boostEnergy > 20) {
                        this.ship.boost = true;
                    }

                    // Execute defensive maneuver
                    if (!this.state.currentManeuver) {
                        this.state.currentManeuver = 'quantum_phase';
                        this.state.maneuverProgress = 0;
                    }
                    this.executeManeuver(this.state.currentManeuver);
                }
            }

            executeManeuver(maneuverName) {
                this.state.maneuverProgress += 0.025 * this.personality.reflexes;

                switch (maneuverName) {
                    case 'quantum_phase':
                        this.executeQuantumPhase();
                        break;
                    case 'cobra_maneuver':
                        this.executeCobraManeuver();
                        break;
                    case 'kulbit':
                        this.executeKulbit();
                        break;
                    case 'pugachev_cobra':
                        this.executePugachevCobra();
                        break;
                    case 'herbst_maneuver':
                        this.executeHerbstManeuver();
                        break;
                    case 'barrel_roll_attack':
                        this.executeBarrelRollAttack();
                        break;
                    case 'chandelle':
                        this.executeChandelle();
                        break;
                    case 'split_s':
                        this.executeSplitS();
                        break;
                    case 'immelman_turn':
                        this.executeImmelmanTurn();
                        break;
                    case 'spiral_climb':
                        this.executeSpiralClimb();
                        break;
                }

                if (this.state.maneuverProgress >= 1) {
                    this.state.currentManeuver = null;
                    this.state.maneuverProgress = 0;
                }
            }

            executeQuantumPhase() {
                // Ultra-advanced evasion pattern
                const phase = this.state.maneuverProgress;
                const frequency = 10 + Math.random() * 5;

                // Quantum-like position oscillation
                this.ship.velocity.x += Math.sin(phase * frequency) * 8;
                this.ship.velocity.y += Math.cos(phase * frequency * 0.7) * 6;
                this.ship.velocity.z += Math.sin(phase * frequency * 1.3) * 8;

                // Rapid roll changes
                this.ship.mesh.rotation.z = Math.sin(phase * frequency * 2) * Math.PI;
                this.ship.mesh.rotation.x = Math.cos(phase * frequency) * 0.5;

                // Afterburner pulses
                if (Math.sin(phase * frequency * 4) > 0.5 && this.ship.boostEnergy > 10) {
                    this.ship.boost = true;
                }
            }

            executeCobraManeuver() {
                const phase = this.state.maneuverProgress;

                if (phase < 0.3) {
                    // Rapid pitch up
                    this.ship.mesh.rotation.x -= 0.1;
                    this.ship.velocity.y += 5;
                    this.ship.velocity.multiplyScalar(0.9); // Decelerate
                } else if (phase < 0.7) {
                    // Hold position
                    this.ship.mesh.rotation.x = -Math.PI / 3;
                    this.ship.velocity.multiplyScalar(0.85);
                } else {
                    // Recovery
                    this.ship.mesh.rotation.x *= 0.9;
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(4));
                }
            }

            executeKulbit() {
                // Somersault maneuver
                const angle = this.state.maneuverProgress * Math.PI * 2;

                this.ship.mesh.rotation.x = -angle;
                this.ship.velocity.y = Math.sin(angle) * 15;

                if (this.state.maneuverProgress > 0.3 && this.state.maneuverProgress < 0.7) {
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(3));
                }
            }

            executePugachevCobra() {
                const phase = this.state.maneuverProgress;

                if (phase < 0.4) {
                    // Extreme pitch up
                    this.ship.mesh.rotation.x = -Math.PI / 2 * phase * 2.5;
                    this.ship.velocity.y += 8;
                    this.ship.velocity.x *= 0.8;
                    this.ship.velocity.z *= 0.8;
                } else {
                    // Quick recovery with turn
                    this.ship.mesh.rotation.x *= 0.85;
                    this.ship.mesh.rotation.y += 0.05;

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(5));
                }
            }

            executeHerbstManeuver() {
                // Post-stall maneuver with yaw
                const phase = this.state.maneuverProgress;

                if (phase < 0.5) {
                    // Stall phase
                    this.ship.velocity.multiplyScalar(0.85);
                    this.ship.mesh.rotation.x -= 0.05;
                } else {
                    // Yaw turn
                    this.ship.mesh.rotation.y += 0.15;
                    this.ship.mesh.rotation.z = Math.sin(phase * Math.PI) * 0.5;

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(4));
                }
            }

            executeBarrelRollAttack() {
                const rollAngle = this.state.maneuverProgress * Math.PI * 2;
                const direction = Math.sign(Math.sin(Date.now() * 0.001));

                this.ship.mesh.rotation.z = rollAngle * direction;
                this.ship.velocity.x += Math.sin(rollAngle) * 4 * direction;
                this.ship.velocity.y += Math.abs(Math.cos(rollAngle)) * 2;

                // Maintain forward momentum and fire
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.ship.mesh.quaternion);
                this.ship.velocity.add(forward.multiplyScalar(3));

                // Fire during optimal angle
                if (Math.abs(Math.sin(rollAngle)) < 0.3 && this.ship.target) {
                    this.attemptFire();
                }
            }

            executeChandelle() {
                const phase = this.state.maneuverProgress;

                if (phase < 0.5) {
                    // Climbing turn
                    this.ship.velocity.y += 6;
                    this.ship.mesh.rotation.z = phase * Math.PI / 3;
                    this.ship.mesh.rotation.y += 0.02;
                } else {
                    // Level out at higher altitude
                    this.ship.velocity.y *= 0.9;
                    this.ship.mesh.rotation.z *= 0.9;
                    this.ship.mesh.rotation.x *= 0.9;
                }
            }

            executeSplitS() {
                const phase = this.state.maneuverProgress;

                if (phase < 0.5) {
                    // Roll inverted
                    this.ship.mesh.rotation.z = Math.PI * phase * 2;
                    this.ship.velocity.y -= 2;
                } else {
                    // Pull through
                    this.ship.mesh.rotation.x = Math.PI * (phase - 0.5);
                    this.ship.velocity.y -= 10;

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.ship.mesh.quaternion);
                    this.ship.velocity.add(forward.multiplyScalar(4));
                }
            }

            executeImmelmanTurn() {
                const phase = this.state.maneuverProgress;

                if (phase < 0.6) {
                    // Half loop
                    const loopAngle = phase * Math.PI / 0.6;
                    this.ship.mesh.rotation.x = -loopAngle;
                    this.ship.velocity.y = Math.cos(loopAngle) * 12;
                } else {
                    // Roll to level
                    const rollPhase = (phase - 0.6) / 0.4;
                    this.ship.mesh.rotation.z = Math.PI * (1 - rollPhase);
                    this.ship.mesh.rotation.x *= 0.9;
                }
            }

            executeSpiralClimb() {
                const angle = this.state.maneuverProgress * Math.PI * 6;
                const radius = 30 + this.state.maneuverProgress * 80;

                this.ship.velocity.x += Math.cos(angle) * 3;
                this.ship.velocity.z += Math.sin(angle) * 3;
                this.ship.velocity.y += 4;

                this.ship.mesh.rotation.z = Math.sin(angle) * 0.6;
                this.ship.mesh.rotation.x = -0.3;
            }

            executeAttack() {
                if (!this.ship.target || !this.ship.target.alive) return;

                const toTarget = new THREE.Vector3().subVectors(
                    this.ship.target.mesh.position,
                    this.ship.mesh.position
                );
                const distance = toTarget.length();
                toTarget.normalize();

                // Dynamic attack patterns based on personality
                const attackPattern = this.selectAttackPattern(distance);

                switch (attackPattern) {
                    case 'boom_zoom':
                        this.executeBoomZoom(toTarget, distance);
                        break;
                    case 'turn_fight':
                        this.executeTurnFight(toTarget, distance);
                        break;
                    case 'energy_fight':
                        this.executeEnergyFight(toTarget, distance);
                        break;
                    default:
                        this.executeStandardAttack(toTarget, distance);
                }

                // Execute combat maneuvers randomly
                if (Math.random() < 0.02 * this.personality.aggression) {
                    const combatManeuvers = ['barrel_roll_attack', 'chandelle', 'kulbit'];
                    this.state.currentManeuver = combatManeuvers[Math.floor(Math.random() * combatManeuvers.length)];
                    this.state.maneuverProgress = 0;
                }

                if (this.state.currentManeuver) {
                    this.executeManeuver(this.state.currentManeuver);
                }
            }

            selectAttackPattern(distance) {
                const altitude = this.ship.mesh.position.y;
                const energyAdvantage = altitude > this.ship.target.mesh.position.y + 50;
                const speedAdvantage = this.ship.velocity.length() > this.ship.target.velocity.length();

                if (energyAdvantage && distance > 200) return 'boom_zoom';
                if (distance < 150 && this.personality.aggression > 0.7) return 'turn_fight';
                if (speedAdvantage) return 'energy_fight';

                return 'standard';
            }

            executeBoomZoom(toTarget, distance) {
                // Dive attack from altitude
                if (this.ship.mesh.position.y > this.ship.target.mesh.position.y + 30) {
                    // Dive phase
                    this.ship.velocity.add(toTarget.multiplyScalar(2));
                    this.ship.velocity.y -= 3;

                    // Fire during dive
                    if (distance < 300) {
                        this.attemptFire();
                    }
                } else {
                    // Zoom climb away
                    this.ship.velocity.y += 5;
                    this.ship.velocity.add(toTarget.multiplyScalar(-1));
                }
            }

            executeTurnFight(toTarget, distance) {
                // Close-range dogfighting
                const optimalDist = 120;

                if (distance > optimalDist) {
                    this.ship.velocity.add(toTarget.multiplyScalar(1.5));
                } else if (distance < optimalDist - 30) {
                    this.ship.velocity.add(toTarget.multiplyScalar(-0.8));
                }

                // Lead pursuit
                const targetData = this.memory.enemyData.get(this.ship.target);
                if (targetData && targetData.velocities.length > 0) {
                    const targetVel = targetData.velocities[targetData.velocities.length - 1];
                    const leadPoint = this.calculateLeadPoint(
                        this.ship.target.mesh.position,
                        targetVel,
                        distance
                    );

                    const toLeadPoint = new THREE.Vector3().subVectors(leadPoint, this.ship.mesh.position);
                    toLeadPoint.normalize();
                    this.ship.mesh.lookAt(leadPoint);
                }

                // Aggressive maneuvering
                const time = Date.now() * 0.003;
                const lateral = new THREE.Vector3();
                lateral.crossVectors(toTarget, new THREE.Vector3(0, 1, 0));
                lateral.normalize();

                this.ship.velocity.add(lateral.multiplyScalar(Math.sin(time) * 2));
                this.ship.velocity.y += Math.cos(time * 0.7) * 1.5;
            }

            executeEnergyFight(toTarget, distance) {
                // Maintain energy advantage
                const targetAlt = this.ship.target.mesh.position.y;
                const myAlt = this.ship.mesh.position.y;

                if (myAlt < targetAlt + 50) {
                    // Gain altitude
                    this.ship.velocity.y += 2;
                }

                // Maintain optimal distance
                const optimalDist = 250;
                if (distance > optimalDist) {
                    this.ship.velocity.add(toTarget.multiplyScalar(0.8));
                } else {
                    // Maintain distance and altitude
                    const tangent = new THREE.Vector3();
                    tangent.crossVectors(toTarget, new THREE.Vector3(0, 1, 0));
                    tangent.normalize();

                    this.ship.velocity.add(tangent.multiplyScalar(Math.sign(Math.sin(Date.now() * 0.001))));
                }
            }

            executeStandardAttack(toTarget, distance) {
                // Standard BVR combat
                const optimalDist = (this.weights.combatTactics.optimalDistance.min +
                    this.weights.combatTactics.optimalDistance.max) / 2;

                if (distance > optimalDist + 50) {
                    this.ship.velocity.add(toTarget.multiplyScalar(this.behaviorProfile.pursuitIntensity));
                } else if (distance < optimalDist - 50) {
                    this.ship.velocity.add(toTarget.multiplyScalar(-0.5));
                }

                // Advanced strafing
                const right = new THREE.Vector3();
                right.crossVectors(toTarget, new THREE.Vector3(0, 1, 0));
                right.normalize();

                const strafe = Math.sin(Date.now() * 0.002) * 0.8;
                this.ship.velocity.add(right.multiplyScalar(strafe));

                // Vertical variation
                const verticalOffset = Math.cos(Date.now() * 0.0015) * 0.5;
                this.ship.velocity.y += verticalOffset;
            }

            executePursuit() {
                if (!this.ship.target || !this.ship.target.alive) return;

                const targetData = this.memory.enemyData.get(this.ship.target);

                // Advanced prediction
                let predictedPos = this.evolution.predictFuture(
                    this.ship,
                    this.ship.target,
                    1.5 // Look 1.5 seconds ahead
                );

                // Account for terrain
                if (predictedPos.y < CONFIG.MIN_HEIGHT) {
                    predictedPos.y = CONFIG.MIN_HEIGHT + 20;
                }

                // Calculate intercept course
                const interceptTime = this.calculateInterceptTime(
                    this.ship.mesh.position,
                    this.ship.velocity,
                    predictedPos,
                    this.ship.target.velocity
                );

                if (interceptTime > 0 && interceptTime < 10) {
                    // Navigate to intercept point
                    const interceptPos = predictedPos.clone();
                    interceptPos.add(this.ship.target.velocity.clone().multiplyScalar(interceptTime));

                    const toIntercept = new THREE.Vector3().subVectors(interceptPos, this.ship.mesh.position);
                    toIntercept.normalize();

                    this.ship.velocity.add(toIntercept.multiplyScalar(this.behaviorProfile.pursuitIntensity));
                } else {
                    // Direct pursuit
                    const toPredicted = new THREE.Vector3().subVectors(predictedPos, this.ship.mesh.position);
                    toPredicted.normalize();

                    this.ship.velocity.add(toPredicted.multiplyScalar(this.behaviorProfile.pursuitIntensity));
                }

                // Boost if falling behind
                const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);
                if (distance > 400 && this.ship.boostEnergy > 30) {
                    this.ship.boost = true;
                }

                // Look at target
                this.ship.mesh.lookAt(this.ship.target.mesh.position);
            }

            calculateInterceptTime(myPos, myVel, targetPos, targetVel) {
                // Calculate time to intercept
                const toTarget = new THREE.Vector3().subVectors(targetPos, myPos);
                const relVel = new THREE.Vector3().subVectors(myVel, targetVel);

                if (relVel.length() < 0.1) return -1;

                return toTarget.length() / relVel.length();
            }

            executeSearch() {
                // Advanced search patterns
                const time = Date.now() * 0.0004;
                const searchPattern = this.state.teamRole === 'hunter' ? 'aggressive' : 'defensive';

                let targetPos;

                if (searchPattern === 'aggressive') {
                    // Expanding spiral search
                    const radius = 200 + Math.sin(time * 0.5) * 200;
                    targetPos = new THREE.Vector3(
                        Math.cos(time) * radius,
                        150 + Math.sin(time * 2) * 100,
                        Math.sin(time) * radius
                    );
                } else {
                    // Defensive patrol
                    const radius = 300;
                    targetPos = new THREE.Vector3(
                        Math.cos(time * 0.7) * radius,
                        200 + Math.sin(time * 1.5) * 50,
                        Math.sin(time * 0.7) * radius
                    );
                }

                const toTarget = new THREE.Vector3().subVectors(targetPos, this.ship.mesh.position);
                toTarget.normalize();

                this.ship.velocity.add(toTarget.multiplyScalar(0.6));

                // Scan for enemies
                if (Math.random() < 0.1) {
                    this.selectTarget();
                }

                // Check for powerups
                this.scanForPowerups();
            }

            attemptFire() {
                const now = Date.now();
                const weapon = this.weights.combatTactics.weaponStrategy[this.state.currentWeapon];

                // Check cooldown
                const cooldown = this.state.currentWeapon === 'rockets' ? 800 :
                    this.state.currentWeapon === 'laser' ? 100 : 200;

                if (now - this.ship.lastShot < cooldown) return;

                // Check weapon heat
                this.state.weaponHeat = Math.max(0, this.state.weaponHeat - 1);
                if (this.state.weaponHeat > 80) return;

                const distance = this.ship.mesh.position.distanceTo(this.ship.target.mesh.position);

                // Check range
                if (distance < weapon.range[0] || distance > weapon.range[1]) return;

                // Calculate lead with evolution-enhanced prediction
                const targetData = this.memory.enemyData.get(this.ship.target);
                const aimPoint = this.calculateAdvancedLead(targetData, distance);

                // Check aim accuracy
                const toAim = new THREE.Vector3().subVectors(aimPoint, this.ship.mesh.position);
                toAim.normalize();

                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.ship.mesh.quaternion);

                const aimAccuracy = forward.dot(toAim);
                const requiredAccuracy = weapon.accuracy * this.personality.accuracy;

                // Smooth aiming
                const aimSpeed = 0.05 * this.personality.reflexes;
                this.ship.mesh.quaternion.slerp(
                    new THREE.Quaternion().setFromUnitVectors(forward, toAim),
                    aimSpeed
                );

                if (aimAccuracy > requiredAccuracy) {
                    // Fire burst
                    const burstSize = this.state.currentWeapon === 'laser' ? 2 :
                        this.weights.combatTactics.burstSize;

                    for (let i = 0; i < burstSize; i++) {
                        setTimeout(() => {
                            if (this.ship.alive && this.ship.target && this.ship.target.alive) {
                                this.fireWeapon();
                                this.stats.shotsFired++;
                                this.state.weaponHeat += 10;
                            }
                        }, i * this.weights.combatTactics.burstFireDelay);
                    }
                }
            }

            calculateAdvancedLead(targetData, distance) {
                let aimPoint = this.ship.target.mesh.position.clone();

                if (!targetData || targetData.velocities.length < 3) {
                    return aimPoint;
                }

                // Calculate acceleration
                const vel1 = targetData.velocities[targetData.velocities.length - 2];
                const vel2 = targetData.velocities[targetData.velocities.length - 1];
                const acceleration = new THREE.Vector3().subVectors(vel2, vel1);

                // Time to target based on weapon
                const bulletSpeed = this.state.currentWeapon === 'laser' ? 40 :
                    this.state.currentWeapon === 'rockets' ? 15 : 25;
                const timeToTarget = distance / bulletSpeed;

                // Advanced prediction with acceleration
                const velocity = vel2.clone();
                const leadTime = timeToTarget * this.weights.combatTactics.leadCalculation;

                // Position prediction
                aimPoint.add(velocity.multiplyScalar(leadTime * 60));
                aimPoint.add(acceleration.multiplyScalar(0.5 * leadTime * leadTime * 60));

                // Behavior prediction
                if (targetData.behavior && targetData.behavior.includes('evader')) {
                    // Predict evasion
                    const evasionOffset = new THREE.Vector3(
                        Math.sin(Date.now() * 0.01) * 20,
                        Math.cos(Date.now() * 0.008) * 15,
                        Math.sin(Date.now() * 0.012) * 20
                    );
                    aimPoint.add(evasionOffset);
                }

                return aimPoint;
            }

            calculateLeadPoint(targetPos, targetVel, distance) {
                const bulletSpeed = 30; // Average weapon speed
                const timeToTarget = distance / bulletSpeed;

                const leadPoint = targetPos.clone();
                leadPoint.add(targetVel.clone().multiplyScalar(timeToTarget));

                return leadPoint;
            }

            fireWeapon() {
                this.ship.lastShot = Date.now();

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.ship.mesh.quaternion);

                // Add slight spread for realism
                const spread = 0.02;
                direction.x += (Math.random() - 0.5) * spread;
                direction.y += (Math.random() - 0.5) * spread;
                direction.normalize();

                switch (this.state.currentWeapon) {
                    case 'rockets':
                        const rocket = new Rocket(this.ship.mesh.position.clone(), direction, this.ship);
                        lasers.push(rocket);
                        playSound('missile', 0.8);
                        break;

                    case 'laser':
                        const laser = new Laser(
                            this.ship.mesh.position,
                            direction,
                            0x00ffff,
                            this.ship,
                            10,
                            40
                        );
                        lasers.push(laser);
                        playSound('shoot', 1.2);
                        break;

                    default: // plasma
                        const plasma = new Laser(
                            this.ship.mesh.position,
                            direction,
                            this.ship.config.color,
                            this.ship,
                            20,
                            25
                        );
                        lasers.push(plasma);
                        playSound('shoot');
                }
            }

            manageSpecialWeapons() {
                // Nuclear missile decision
                if (this.ship.nuclearReady && this.situation.enemies <= 3) {
                    const shouldFireNuke = this.evaluateNuclearOption();

                    if (shouldFireNuke) {
                        this.fireNuclearMissile();
                    }
                }
            }

            evaluateNuclearOption() {
                // Complex decision making for nuclear weapon
                if (this.situation.healthRatio < 0.3 && this.situation.enemies > 1) {
                    return true; // Desperation
                }

                if (this.ship.target && this.ship.target.isPlayer &&
                    this.personality.aggression > 0.8) {
                    return Math.random() < 0.1; // Target player
                }

                // Check for clustered enemies
                let clusteredEnemies = 0;
                const clusterCenter = new THREE.Vector3();

                this.memory.enemyData.forEach((data, enemy) => {
                    if (enemy.alive) {
                        ships.forEach(other => {
                            if (other !== enemy && other !== this.ship && other.alive) {
                                const dist = enemy.mesh.position.distanceTo(other.mesh.position);
                                if (dist < 300) {
                                    clusteredEnemies++;
                                    clusterCenter.add(enemy.mesh.position);
                                }
                            }
                        });
                    }
                });

                if (clusteredEnemies >= 2) {
                    clusterCenter.divideScalar(clusteredEnemies);
                    const distToCluster = this.ship.mesh.position.distanceTo(clusterCenter);

                    if (distToCluster > 400) { // Safe distance
                        return true;
                    }
                }

                return false;
            }

            fireNuclearMissile() {
                this.ship.nuclearReady = false;
                this.ship.nuclearCooldown = 600;

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.ship.mesh.quaternion);

                const missile = new NuclearMissile(
                    this.ship.mesh.position.clone(),
                    direction,
                    this.ship
                );
                missiles.push(missile);

                this.stats.missilesFired++;
                playSound('missile', 0.5);
            }

            deployCountermeasures() {
                // Create chaff/flare effect
                for (let i = 0; i < 10; i++) {
                    const flare = {
                        position: this.ship.mesh.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        ),
                        life: 60,
                        type: 'flare'
                    };
                    particles.push(flare);
                }

                // Confuse missiles
                missiles.forEach(missile => {
                    if (missile.target === this.ship && Math.random() < 0.5) {
                        missile.target = null; // Break lock
                    }
                });
            }

            updateTeamCoordination() {
                if (!this.weights.teamwork.formationFlying) return;

                // Share target information
                if (this.weights.teamwork.targetSharing && this.ship.target) {
                    ships.forEach(ally => {
                        if (ally !== this.ship && ally.alive && ally.ai &&
                            !ally.target && Math.random() < 0.1) {
                            ally.target = this.ship.target;
                        }
                    });
                }

                // Coordinate attacks
                if (this.weights.teamwork.coordinatedAttacks && this.ship.target) {
                    let alliesOnTarget = 0;
                    ships.forEach(ally => {
                        if (ally !== this.ship && ally.alive && ally.target === this.ship.target) {
                            alliesOnTarget++;
                        }
                    });

                    if (alliesOnTarget >= 2) {
                        // Synchronized attack
                        this.state.mode = 'attacking';
                    }
                }
            }

            checkPowerups() {
                powerups.forEach((powerup, index) => {
                    const distance = this.ship.mesh.position.distanceTo(powerup.mesh.position);

                    if (distance < 100 && this.evaluatePowerup(powerup)) {
                        // Move towards powerup
                        const toPowerup = new THREE.Vector3().subVectors(
                            powerup.mesh.position,
                            this.ship.mesh.position
                        );
                        toPowerup.normalize();

                        this.ship.velocity.add(toPowerup.multiplyScalar(2));
                    }
                });
            }

            evaluatePowerup(powerup) {
                // Decide if powerup is worth getting
                switch (powerup.type) {
                    case 'health':
                        return this.situation.healthRatio < 0.7;
                    case 'shield':
                        return this.ship.shield < CONFIG.SHIELD_HP * 0.5;
                    case 'boost':
                        return this.ship.boostEnergy < 50;
                    case 'weapon':
                        return true; // Always good
                    default:
                        return Math.random() < 0.5;
                }
            }

            scanForPowerups() {
                powerups.forEach(powerup => {
                    const distance = this.ship.mesh.position.distanceTo(powerup.mesh.position);

                    if (distance < this.weights.awareness.threatDetectionRange) {
                        if (this.evaluatePowerup(powerup) && Math.random() < 0.3) {
                            // Temporarily target powerup location
                            const toPowerup = new THREE.Vector3().subVectors(
                                powerup.mesh.position,
                                this.ship.mesh.position
                            );
                            toPowerup.normalize();

                            this.ship.velocity.add(toPowerup);
                        }
                    }
                });
            }
        }

        // Initialize Three.js Enhanced
        function init() {
            // Scene setup with better fog
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x88BBDD, weather.fog);

            // Enhanced camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 300, 600);
            camera.lookAt(0, 100, 0);

            // Enhanced renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // Create enhanced environment
            createEnhancedEnvironment();

            // Enhanced lighting
            createEnhancedLighting();

            // Initialize audio
            initAudio();

            // Start weather system
            startWeatherSystem();

            // Loading complete
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            }, 2000);

            // Start animation
            animate();
        }

        // Create enhanced environment
        function createEnhancedEnvironment() {
            // Ocean with waves
            const oceanGeometry = new THREE.PlaneGeometry(2000, 2000, 256, 256);
            const oceanMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.9,
                shininess: 100,
                reflectivity: 0.8
            });

            // Add wave displacement
            const vertices = oceanGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.01) * 5 + Math.cos(vertices[i + 1] * 0.01) * 5;
            }
            oceanGeometry.computeVertexNormals();

            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.z = -750;
            ocean.receiveShadow = true;
            scene.add(ocean);

            // Animated ocean
            ocean.userData.update = function(time) {
                const vertices = ocean.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const y = vertices[i + 1];
                    vertices[i + 2] = Math.sin(x * 0.01 + time) * 3 +
                        Math.cos(y * 0.01 + time * 0.8) * 3;
                }
                ocean.geometry.attributes.position.needsUpdate = true;
                ocean.geometry.computeVertexNormals();
            };

            // Enhanced terrain
            const terrainGeometry = new THREE.PlaneGeometry(3000, 1500, 100, 50);
            const terrainMaterial = new THREE.MeshPhongMaterial({
                color: 0x3a5f3a,
                roughness: 0.8,
                metalness: 0.2
            });

            // Add terrain features
            const terrainVertices = terrainGeometry.attributes.position.array;
            for (let i = 0; i < terrainVertices.length; i += 3) {
                const x = terrainVertices[i];
                const y = terrainVertices[i + 1];

                // Hills
                terrainVertices[i + 2] = Math.sin(x * 0.003) * 30 +
                    Math.cos(y * 0.005) * 20 +
                    Math.random() * 10;
            }
            terrainGeometry.computeVertexNormals();

            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.z = 750;
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            scene.add(terrain);

            // Sky dome with gradient
            const skyGeometry = new THREE.SphereGeometry(2500, 64, 64);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },
                    bottomColor: { value: new THREE.Color(0xffffff) },
                    offset: { value: 400 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
                fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Enhanced city
            createEnhancedCity();

            // Clouds system
            createCloudSystem();

            // Add carrier ships
            createCarrierShips();
        }

        // Create enhanced city
        function createEnhancedCity() {
            const cityGroup = new THREE.Group();

            // Skyscrapers with variety
            for (let i = 0; i < 50; i++) {
                const width = 30 + Math.random() * 70;
                const depth = 30 + Math.random() * 70;
                const height = 100 + Math.random() * 300;

                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);

                // Varied building colors
                const hue = Math.random() * 0.1 + 0.5;
                const buildingMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue, 0.1, 0.3 + Math.random() * 0.2),
                    emissive: new THREE.Color().setHSL(hue, 0.5, 0.1),
                    emissiveIntensity: 0.2
                });

                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.x = (Math.random() - 0.5) * 1200;
                building.position.y = height / 2;
                building.position.z = 300 + Math.random() * 700;
                building.castShadow = true;
                building.receiveShadow = true;

                // Add windows
                if (Math.random() > 0.5) {
                    const windowsGeometry = new THREE.PlaneGeometry(width * 0.9, height * 0.9);
                    const windowsMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffaa,
                        emissive: 0xffffaa,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.6
                    });

                    const windows = new THREE.Mesh(windowsGeometry, windowsMaterial);
                    windows.position.z = depth / 2 + 0.1;
                    building.add(windows);
                }

                cityGroup.add(building);
            }

            // Add bridges
            for (let i = 0; i < 3; i++) {
                const bridgeGeometry = new THREE.BoxGeometry(100, 10, 500);
                const bridgeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666
                });

                const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                bridge.position.set(
                    (i - 1) * 400,
                    20,
                    0
                );
                bridge.castShadow = true;
                cityGroup.add(bridge);
            }

            scene.add(cityGroup);
        }

        // Create cloud system
        function createCloudSystem() {
            const cloudGroup = new THREE.Group();

            for (let i = 0; i < 30; i++) {
                const cloud = new THREE.Group();

                // Create cloud from multiple spheres
                for (let j = 0; j < 5 + Math.random() * 5; j++) {
                    const size = 20 + Math.random() * 40;
                    const cloudPartGeometry = new THREE.SphereGeometry(size, 8, 6);
                    const cloudPartMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7 + Math.random() * 0.3
                    });

                    const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudPartMaterial);
                    cloudPart.position.set(
                        (Math.random() - 0.5) * size,
                        (Math.random() - 0.5) * size * 0.5,
                        (Math.random() - 0.5) * size
                    );
                    cloud.add(cloudPart);
                }

                cloud.position.set(
                    (Math.random() - 0.5) * 3000,
                    350 + Math.random() * 300,
                    (Math.random() - 0.5) * 3000
                );

                cloud.userData.speed = 0.1 + Math.random() * 0.3;
                cloudGroup.add(cloud);
            }

            cloudGroup.userData.update = function(time) {
                cloudGroup.children.forEach(cloud => {
                    cloud.position.x += cloud.userData.speed;
                    if (cloud.position.x > 1500) {
                        cloud.position.x = -1500;
                    }
                });
            };

            scene.add(cloudGroup);
        }

        // Create carrier ships
        function createCarrierShips() {
            // Aircraft carrier
            const carrierGroup = new THREE.Group();

            // Hull
            const hullGeometry = new THREE.BoxGeometry(300, 30, 80);
            const hullMaterial = new THREE.MeshPhongMaterial({
                color: 0x444444
            });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            carrierGroup.add(hull);

            // Deck
            const deckGeometry = new THREE.BoxGeometry(280, 5, 70);
            const deckMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333
            });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.y = 17.5;
            carrierGroup.add(deck);

            // Control tower
            const towerGeometry = new THREE.BoxGeometry(30, 40, 20);
            const towerMaterial = new THREE.MeshPhongMaterial({
                color: 0x555555
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(100, 35, 20);
            carrierGroup.add(tower);

            carrierGroup.position.set(-200, 0, -600);
            carrierGroup.castShadow = true;
            carrierGroup.receiveShadow = true;

            scene.add(carrierGroup);

            // Destroyer
            const destroyerGroup = new THREE.Group();

            const destroyerHull = new THREE.BoxGeometry(150, 20, 40);
            const destroyer = new THREE.Mesh(destroyerHull, hullMaterial);
            destroyerGroup.add(destroyer);

            destroyerGroup.position.set(300, 0, -700);
            scene.add(destroyerGroup);
        }

        // Enhanced lighting
        function createEnhancedLighting() {
            // Ambient light with color
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);

            // Hemisphere light for sky/ground color
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x3a5f3a, 0.6);
            scene.add(hemisphereLight);

            // Main sun light
            const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
            sunLight.position.set(500, 800, 300);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -1000;
            sunLight.shadow.camera.right = 1000;
            sunLight.shadow.camera.top = 1000;
            sunLight.shadow.camera.bottom = -1000;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 2000;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // Secondary fill light
            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            fillLight.position.set(-300, 400, -200);
            scene.add(fillLight);

            // Fog light
            const fogLight = new THREE.PointLight(0xffffff, 0.5, 1000);
            fogLight.position.set(0, 500, 0);
            scene.add(fogLight);
        }

        // Weather system
        function startWeatherSystem() {
            // Dynamic weather changes
            setInterval(() => {
                const weatherType = Math.random();

                if (weatherType < 0.3) {
                    // Clear weather
                    weather.fog = 0.0008;
                    weather.rain = false;
                    weather.lightning = false;
                    weather.wind = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        0,
                        (Math.random() - 0.5) * 2
                    );
                } else if (weatherType < 0.6) {
                    // Foggy weather
                    weather.fog = 0.003;
                    weather.rain = false;
                    weather.lightning = false;
                    weather.wind = new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        0,
                        (Math.random() - 0.5) * 5
                    );
                } else if (weatherType < 0.8) {
                    // Rainy weather
                    weather.fog = 0.002;
                    weather.rain = true;
                    weather.lightning = false;
                    weather.wind = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        -2,
                        (Math.random() - 0.5) * 10
                    );
                } else {
                    // Storm
                    weather.fog = 0.004;
                    weather.rain = true;
                    weather.lightning = true;
                    weather.wind = new THREE.Vector3(
                        (Math.random() - 0.5) * 15,
                        -3,
                        (Math.random() - 0.5) * 15
                    );
                }

                scene.fog.density = weather.fog;

                if (weather.lightning) {
                    triggerLightning();
                }
            }, 30000); // Change weather every 30 seconds
        }

        // Lightning effect
        function triggerLightning() {
            const lightningLight = new THREE.PointLight(0xffffff, 10, 2000);
            lightningLight.position.set(
                (Math.random() - 0.5) * 1000,
                500 + Math.random() * 300,
                (Math.random() - 0.5) * 1000
            );
            scene.add(lightningLight);

            // Flash sequence
            setTimeout(() => {
                lightningLight.intensity = 0;
                setTimeout(() => {
                    lightningLight.intensity = 8;
                    setTimeout(() => {
                        scene.remove(lightningLight);
                        playSound('explosion', 0.3);
                    }, 100);
                }, 50);
            }, 100);
        }

        // Menu functions enhanced
        function startPlayerMode() {
            gameMode = 'player';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('playerHUD').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('radar').style.display = 'block';
            document.getElementById('aiGeneration').style.display = 'block';
            startBattle();
        }

        function startMixedMode() {
            gameMode = 'mixed';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('playerHUD').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('radar').style.display = 'block';
            document.getElementById('aiGeneration').style.display = 'block';
            startBattle();
        }

        function startAIMode() {
            gameMode = 'ai';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('aiGeneration').style.display = 'block';
            startBattle();
        }

        function returnToMenu() {
            gameState = 'menu';
            cleanupBattle();
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('playerHUD').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('radar').style.display = 'none';
            document.getElementById('winnerOverlay').style.display = 'none';
            document.getElementById('aiGeneration').style.display = 'none';
            document.getElementById('comboCounter').style.display = 'none';
        }

        function restartBattle() {
            document.getElementById('winnerOverlay').style.display = 'none';
            cleanupBattle();
            startBattle();
        }

        // Setup enhanced button event listeners
        document.getElementById('btnPlayerMode').addEventListener('click', startPlayerMode);
        document.getElementById('btnMixedMode').addEventListener('click', startMixedMode);
        document.getElementById('btnAIMode').addEventListener('click', startAIMode);
        document.getElementById('btnRestart').addEventListener('click', restartBattle);
        document.getElementById('btnMenu').addEventListener('click', returnToMenu);

        // Enhanced Ship class
        class Ship {
            constructor(config, index) {
                this.config = config || {
                    name: 'Elite AI',
                    color: 0xff0000,
                    emissive: 0xff0000
                };
                this.name = this.config.name;
                this.health = CONFIG.SHIP_HP;
                this.shield = CONFIG.SHIELD_HP;
                this.alive = true;
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.target = null;
                this.lastShot = 0;
                this.score = 0;
                this.kills = 0;
                this.isPlayer = false;
                this.boostEnergy = CONFIG.BOOST_MAX;
                this.boost = false;
                this.isHostile = true;
                this.nuclearReady = true;
                this.nuclearCooldown = 0;

                // Use Elite AI
                if (!this.isPlayer) {
                    this.ai = new EliteAI(this);
                }

                this.createEnhancedModel();

                // Position ships in formation
                const formationRadius = CONFIG.ARENA_SIZE * 0.7;
                const angle = (Math.PI * 2 * index) / CONFIG.SHIPS;
                this.mesh.position.x = Math.cos(angle) * formationRadius;
                this.mesh.position.z = Math.sin(angle) * formationRadius;
                this.mesh.position.y = 200 + (index % 3) * 50;

                // Initial velocity
                this.velocity.set(
                    (Math.random() - 0.5) * 5,
                    0,
                    (Math.random() - 0.5) * 5
                );
            }

            createEnhancedModel() {
                const group = new THREE.Group();

                // Advanced fighter jet design
                // Fuselage
                const fuselageShape = new THREE.Shape();
                fuselageShape.moveTo(0, 0);
                fuselageShape.lineTo(12, 2);
                fuselageShape.lineTo(40, 3);
                fuselageShape.lineTo(42, 2);
                fuselageShape.lineTo(42, -2);
                fuselageShape.lineTo(40, -3);
                fuselageShape.lineTo(12, -2);
                fuselageShape.lineTo(0, 0);

                const extrudeSettings = {
                    depth: 80,
                    bevelEnabled: true,
                    bevelSegments: 3,
                    steps: 2,
                    bevelSize: 1,
                    bevelThickness: 1
                };

                const fuselageGeometry = new THREE.ExtrudeGeometry(fuselageShape, extrudeSettings);
                const fuselageMaterial = new THREE.MeshPhongMaterial({
                    color: this.config.color,
                    emissive: this.config.emissive,
                    emissiveIntensity: 0.3,
                    metalness: 0.8,
                    roughness: 0.2
                });

                const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                fuselage.rotation.x = Math.PI / 2;
                fuselage.rotation.y = Math.PI / 2;
                fuselage.position.x = -40;
                group.add(fuselage);

                // Main wings
                const wingGeometry = new THREE.BoxGeometry(140, 3, 40);
                wingGeometry.vertices = wingGeometry.vertices || [];
                const wings = new THREE.Mesh(wingGeometry, fuselageMaterial);
                wings.position.x = -10;
                group.add(wings);

                // Swept wing tips
                const wingTipGeometry = new THREE.ConeGeometry(10, 30, 4);
                const leftWingTip = new THREE.Mesh(wingTipGeometry, fuselageMaterial);
                leftWingTip.position.set(-10, 70, 0);
                leftWingTip.rotation.z = Math.PI / 6;
                group.add(leftWingTip);

                const rightWingTip = leftWingTip.clone();
                rightWingTip.position.y = -70;
                rightWingTip.rotation.z = -Math.PI / 6;
                group.add(rightWingTip);

                // Canopy
                const canopyGeometry = new THREE.SphereGeometry(10, 16, 12);
                const canopyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x111111,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.8,
                    envMapIntensity: 1
                });
                const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                canopy.position.set(25, 0, 5);
                canopy.scale.set(1.5, 1, 1);
                group.add(canopy);

                // Tail fins
                const tailGeometry = new THREE.BoxGeometry(3, 40, 25);
                const tailFin = new THREE.Mesh(tailGeometry, fuselageMaterial);
                tailFin.position.set(-35, 0, 15);
                group.add(tailFin);

                // Horizontal stabilizers
                const stabilizerGeometry = new THREE.BoxGeometry(50, 2, 15);
                const stabilizer = new THREE.Mesh(stabilizerGeometry, fuselageMaterial);
                stabilizer.position.set(-35, 0, 5);
                group.add(stabilizer);

                // Engine exhausts with glow
                const engineGroup = new THREE.Group();
                for (let i = 0; i < 2; i++) {
                    const engineGeometry = new THREE.CylinderGeometry(5, 7, 25, 8);
                    const engineMaterial = new THREE.MeshBasicMaterial({
                        color: 0x0099ff,
                        emissive: 0x00ffff
                    });
                    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                    engine.position.set(-45, (i === 0 ? 15 : -15), 0);
                    engine.rotation.z = Math.PI / 2;
                    engineGroup.add(engine);

                    // Engine glow
                    const glowGeometry = new THREE.SphereGeometry(8, 8, 8);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.copy(engine.position);
                    engineGroup.add(glow);
                }
                group.add(engineGroup);

                // Weapons pods
                for (let i = 0; i < 4; i++) {
                    const podGeometry = new THREE.CylinderGeometry(2, 2, 15, 6);
                    const podMaterial = new THREE.MeshPhongMaterial({
                        color: 0x333333
                    });
                    const pod = new THREE.Mesh(podGeometry, podMaterial);
                    pod.position.set(
                        -5 + i * 3,
                        (i % 2 === 0 ? 40 : -40),
                        -5
                    );
                    pod.rotation.z = Math.PI / 2;
                    group.add(pod);
                }

                // Add navigation lights
                const redLight = new THREE.PointLight(0xff0000, 0.5, 50);
                redLight.position.set(-10, 70, 0);
                group.add(redLight);

                const greenLight = new THREE.PointLight(0x00ff00, 0.5, 50);
                greenLight.position.set(-10, -70, 0);
                group.add(greenLight);

                const strobeLight = new THREE.PointLight(0xffffff, 2, 100);
                strobeLight.position.set(-35, 0, 25);
                group.add(strobeLight);

                // Store lights for animation
                this.navigationLights = { red: redLight, green: greenLight, strobe: strobeLight };

                this.mesh = group;
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);

                // Add engine trail effect
                this.engineTrail = new EngineTrail(this);
            }

            update() {
                if (!this.alive) return;

                // AI movement
                if (!this.isPlayer && this.ai) {
                    this.ai.update();
                }

                // Apply physics
                this.velocity.add(this.acceleration);

                // Apply drag
                this.velocity.multiplyScalar(CONFIG.DRAG);

                // Apply weather effects
                this.velocity.add(weather.wind.clone().multiplyScalar(0.01));

                // Speed limits
                const maxSpeed = this.boost ? CONFIG.BOOST_SPEED : CONFIG.SHIP_SPEED;
                if (this.velocity.length() > maxSpeed) {
                    this.velocity.normalize().multiplyScalar(maxSpeed);
                }

                // Update position
                this.mesh.position.add(this.velocity.clone().multiplyScalar(0.1));

                // Reset acceleration
                this.acceleration.set(0, 0, 0);

                // Boundaries with bounce
                const boundary = CONFIG.ARENA_SIZE;
                ['x', 'z'].forEach(axis => {
                    if (Math.abs(this.mesh.position[axis]) > boundary) {
                        this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                        this.velocity[axis] *= -0.7;

                        if (!this.isPlayer) {
                            // AI boundary avoidance
                            const avoidance = new THREE.Vector3();
                            avoidance[axis] = -Math.sign(this.mesh.position[axis]) * 10;
                            this.velocity.add(avoidance);
                        }
                    }
                });

                // Advanced height limits with ground effect
                if (this.mesh.position.y < CONFIG.MIN_HEIGHT) {
                    this.mesh.position.y = CONFIG.MIN_HEIGHT;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.6;

                    // Ground effect - extra lift near ground
                    if (this.mesh.position.y < CONFIG.MIN_HEIGHT + 20) {
                        this.velocity.y += 2;
                    }
                }
                if (this.mesh.position.y > CONFIG.MAX_HEIGHT) {
                    this.mesh.position.y = CONFIG.MAX_HEIGHT;
                    this.velocity.y = -Math.abs(this.velocity.y) * 0.8;
                }

                // Update systems
                this.updateBoost();
                this.updateShield();
                this.updateWeapons();
                this.updateVisuals();

                // Update engine trail
                if (this.engineTrail) {
                    this.engineTrail.update();
                }
            }

            updateBoost() {
                if (this.boost && this.boostEnergy > 0) {
                    this.boostEnergy -= CONFIG.BOOST_DRAIN;

                    // Boost effects
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(this.mesh.quaternion);
                    this.acceleration.add(forward.multiplyScalar(2));

                    // Create boost particles
                    if (Math.random() < 0.3) {
                        this.createBoostParticle();
                    }
                } else {
                    this.boost = false;
                    this.boostEnergy = Math.min(CONFIG.BOOST_MAX, this.boostEnergy + CONFIG.BOOST_RECHARGE);
                }

                // Update player UI
                if (this.isPlayer) {
                    const boostBar = document.getElementById('playerBoostBar');
                    const boostValue = document.getElementById('boostValue');
                    if (boostBar) {
                        boostBar.style.width = (this.boostEnergy / CONFIG.BOOST_MAX * 100) + '%';
                        boostValue.textContent = Math.round(this.boostEnergy) + '%';
                    }
                }
            }

            updateShield() {
                // Shield regeneration
                if (this.shield < CONFIG.SHIELD_HP) {
                    this.shield = Math.min(CONFIG.SHIELD_HP, this.shield + CONFIG.SHIELD_REGEN);
                }

                // Update UI
                if (this.isPlayer) {
                    const shieldBar = document.getElementById('playerShieldBar');
                    const shieldValue = document.getElementById('shieldValue');
                    if (shieldBar) {
                        shieldBar.style.width = (this.shield / CONFIG.SHIELD_HP * 100) + '%';
                        shieldValue.textContent = Math.round(this.shield) + '%';
                    }
                }
            }

            updateWeapons() {
                // Nuclear weapon cooldown
                if (!this.nuclearReady && this.nuclearCooldown > 0) {
                    this.nuclearCooldown--;
                    if (this.nuclearCooldown <= 0) {
                        this.nuclearReady = true;
                    }
                }
            }

            updateVisuals() {
                // Animate navigation lights
                if (this.navigationLights) {
                    const time = Date.now() * 0.001;
                    this.navigationLights.strobe.intensity = Math.sin(time * 10) > 0 ? 3 : 0;
                }

                // Damage effects
                if (this.health < 50) {
                    // Smoke effect
                    if (Math.random() < 0.1) {
                        this.createSmokeParticle();
                    }

                    // Sparks
                    if (Math.random() < 0.05) {
                        this.createSparkParticle();
                    }
                }

                // Speed lines when boosting
                if (this.boost && this.isPlayer) {
                    this.createSpeedLine();
                }
            }

            createBoostParticle() {
                const particle = {
                    position: this.mesh.position.clone(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5
                    ).add(this.velocity.clone().multiplyScalar(-0.5)),
                    life: 30,
                    type: 'boost',
                    color: 0x00ffff,
                    size: 5
                };
                particles.push(particle);
            }

            createSmokeParticle() {
                const particle = {
                    position: this.mesh.position.clone(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2
                    ),
                    life: 60,
                    type: 'smoke',
                    color: 0x333333,
                    size: 10
                };
                particles.push(particle);
            }

            createSparkParticle() {
                for (let i = 0; i < 5; i++) {
                    const particle = {
                        position: this.mesh.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        ),
                        life: 20,
                        type: 'spark',
                        color: 0xffff00,
                        size: 2
                    };
                    particles.push(particle);
                }
            }

            createSpeedLine() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);

                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    100
                );

                positions[0] = this.mesh.position.x + offset.x;
                positions[1] = this.mesh.position.y + offset.y;
                positions[2] = this.mesh.position.z + offset.z;

                positions[3] = this.mesh.position.x + offset.x;
                positions[4] = this.mesh.position.y + offset.y;
                positions[5] = this.mesh.position.z + offset.z + 200;

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.LineBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3
                });

                const line = new THREE.Line(geometry, material);
                scene.add(line);

                // Fade out
                const fadeOut = () => {
                    material.opacity *= 0.9;
                    if (material.opacity > 0.01) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        scene.remove(line);
                    }
                };
                fadeOut();
            }

            fire() {
                this.lastShot = Date.now();

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.mesh.quaternion);

                const laser = new Laser(this.mesh.position, direction, this.config.color, this);
                lasers.push(laser);

                playSound('shoot');
            }

            takeDamage(amount, attacker) {
                // Shield absorption
                if (this.shield > 0) {
                    const shieldDamage = Math.min(amount, this.shield);
                    this.shield -= shieldDamage;
                    amount -= shieldDamage;

                    if (shieldDamage > 0) {
                        this.createShieldHitEffect();
                        playSound('shield');
                    }
                }

                // Health damage
                if (amount > 0) {
                    this.health -= amount;
                    playSound('hit');

                    if (this.isPlayer) {
                        showDamageIndicator();
                    }
                }

                // Update AI stats
                if (this.ai) {
                    this.ai.stats.damageTaken += amount;
                    this.ai.memory.lastHit = Date.now();
                }

                if (attacker && attacker.ai) {
                    attacker.ai.stats.damageDealt += amount;
                }

                // Check death
                if (this.health <= 0) {
                    this.alive = false;
                    if (attacker) {
                        attacker.kills++;
                        attacker.score += 100;

                        totalKills++;
                        updateCombo();
                        hideCombo();

                        if (attacker.ai) {
                            attacker.ai.stats.kills++;
                        }

                        // Bonus for killing player
                        if (this.isPlayer && attacker.ai) {
                            attacker.score += 400;
                            showNotification(`${attacker.name} eliminated PLAYER! +500`, 'powerup');
                        }
                    }
                    this.destroy();
                }

                // Update UI
                if (this.isPlayer) {
                    const healthBar = document.getElementById('playerHealthBar');
                    const healthValue = document.getElementById('healthValue');
                    const shieldBar = document.getElementById('playerShieldBar');

                    if (healthBar) {
                        healthBar.style.width = (this.health / CONFIG.SHIP_HP * 100) + '%';
                        healthValue.textContent = Math.round(this.health) + '%';
                    }
                    if (shieldBar) {
                        shieldBar.style.width = (this.shield / CONFIG.SHIELD_HP * 100) + '%';
                    }
                }
            }

            createShieldHitEffect() {
                // Create shield bubble effect
                const shieldGeometry = new THREE.SphereGeometry(60, 16, 16);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const shieldEffect = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shieldEffect.position.copy(this.mesh.position);
                scene.add(shieldEffect);

                // Animate
                const animateShield = () => {
                    shieldEffect.scale.multiplyScalar(1.05);
                    shieldMaterial.opacity *= 0.9;

                    if (shieldMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateShield);
                    } else {
                        scene.remove(shieldEffect);
                    }
                };
                animateShield();
            }

            destroy() {
                // Epic explosion effect
                this.createExplosion();

                // Drop powerup chance
                if (Math.random() < 0.3) {
                    this.dropPowerup();
                }

                // Remove from scene
                scene.remove(this.mesh);

                if (this.engineTrail) {
                    this.engineTrail.destroy();
                }

                playSound('explosion');

                // Show kill notification
                if (!this.isPlayer) {
                    showNotification(`${this.name} eliminated!`);
                }
            }

            createExplosion() {
                // Main explosion
                const explosionGroup = new THREE.Group();
                explosionGroup.position.copy(this.mesh.position);

                // Core explosion
                const coreGeometry = new THREE.SphereGeometry(40, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                explosionGroup.add(core);

                // Outer explosion
                const outerGeometry = new THREE.SphereGeometry(60, 16, 16);
                const outerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const outer = new THREE.Mesh(outerGeometry, outerMaterial);
                explosionGroup.add(outer);

                // Shockwave
                const shockwaveGeometry = new THREE.RingGeometry(1, 10, 32);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.rotation.x = -Math.PI / 2;
                explosionGroup.add(shockwave);

                scene.add(explosionGroup);

                // Create debris
                for (let i = 0; i < 20; i++) {
                    const debrisGeometry = new THREE.BoxGeometry(
                        Math.random() * 10 + 5,
                        Math.random() * 10 + 5,
                        Math.random() * 10 + 5
                    );
                    const debrisMaterial = new THREE.MeshPhongMaterial({
                        color: this.config.color,
                        emissive: this.config.emissive,
                        emissiveIntensity: 0.5
                    });
                    const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                    debris.position.copy(this.mesh.position);
                    debris.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 30,
                        Math.random() * 20,
                        (Math.random() - 0.5) * 30
                    );
                    debris.angularVelocity = new THREE.Vector3(
                        Math.random() * 0.3,
                        Math.random() * 0.3,
                        Math.random() * 0.3
                    );
                    debris.life = 300;
                    scene.add(debris);

                    // Animate debris
                    const animateDebris = () => {
                        debris.position.add(debris.velocity.clone().multiplyScalar(0.1));
                        debris.velocity.y -= CONFIG.GRAVITY;
                        debris.rotation.x += debris.angularVelocity.x;
                        debris.rotation.y += debris.angularVelocity.y;
                        debris.rotation.z += debris.angularVelocity.z;
                        debris.life--;

                        if (debris.position.y < -100 || debris.life <= 0) {
                            scene.remove(debris);
                        } else {
                            requestAnimationFrame(animateDebris);
                        }
                    };
                    animateDebris();
                }

                // Animate explosion
                const animateExplosion = () => {
                    // Core expansion
                    core.scale.multiplyScalar(1.15);
                    coreMaterial.opacity *= 0.85;

                    // Outer expansion
                    outer.scale.multiplyScalar(1.2);
                    outerMaterial.opacity *= 0.8;

                    // Shockwave expansion
                    shockwave.scale.multiplyScalar(1.3);
                    shockwaveMaterial.opacity *= 0.9;

                    if (coreMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateExplosion);
                    } else {
                        scene.remove(explosionGroup);
                    }
                };
                animateExplosion();

                // Create fire particles
                for (let i = 0; i < 50; i++) {
                    const particle = {
                        position: this.mesh.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 40,
                            Math.random() * 30,
                            (Math.random() - 0.5) * 40
                        ),
                        life: 30 + Math.random() * 30,
                        type: 'fire',
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00,
                        size: 5 + Math.random() * 10
                    };
                    particles.push(particle);
                }
            }

            dropPowerup() {
                const types = ['health', 'shield', 'weapon', 'boost'];
                const type = types[Math.floor(Math.random() * types.length)];

                const powerup = new Powerup(this.mesh.position.clone(), type);
                powerups.push(powerup);
            }
        }

        // Enhanced Player Ship class
        class PlayerShip extends Ship {
            constructor() {
                const playerConfig = {
                    name: 'PLAYER',
                    color: 0x00ff00,
                    emissive: 0x00ff00
                };
                super(playerConfig, -1);

                this.mesh.position.set(0, 200, 400);
                this.isPlayer = true;
                this.isHostile = false;

                this.keys = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    fire: false,
                    boost: false,
                    special: false,
                    switchWeapon: false,
                    repair: false,
                    targetLock: false
                };

                this.weaponType = 'PLASMA CANNON';
                this.specialWeaponReady = true;
                this.specialCooldown = 0;
                this.currentWeaponIndex = 0;
                this.weapons = ['PLASMA CANNON', 'LASER BEAM', 'ROCKET PODS'];
                this.weaponStats = {
                    'PLASMA CANNON': { damage: 20, fireRate: 200, speed: 25, color: 0x00ff00 },
                    'LASER BEAM': { damage: 10, fireRate: 100, speed: 40, color: 0x00ffff },
                    'ROCKET PODS': { damage: 50, fireRate: 800, speed: 15, color: 0xff6600 }
                };

                this.repairDrones = 3;
                this.targetLockActive = false;
                this.lockedTarget = null;

                // Camera reference
                this.cameraOffset = new THREE.Vector3(0, 50, 150);
            }

            update() {
                if (!this.alive) return;

                // Movement with improved physics
                const rotationSpeed = 0.03;
                const pitchSpeed = 0.02;

                // Pitch control
                if (this.keys.up) {
                    this.mesh.rotation.x = Math.max(this.mesh.rotation.x - pitchSpeed, -Math.PI / 3);
                } else if (this.keys.down) {
                    this.mesh.rotation.x = Math.min(this.mesh.rotation.x + pitchSpeed, Math.PI / 4);
                } else {
                    this.mesh.rotation.x *= 0.95; // Auto-level
                }

                // Roll and turn
                if (this.keys.left) {
                    this.mesh.rotation.z = Math.min(this.mesh.rotation.z + rotationSpeed * 1.5, Math.PI / 3);
                    this.mesh.rotation.y += rotationSpeed;
                } else if (this.keys.right) {
                    this.mesh.rotation.z = Math.max(this.mesh.rotation.z - rotationSpeed * 1.5, -Math.PI / 3);
                    this.mesh.rotation.y -= rotationSpeed;
                } else {
                    this.mesh.rotation.z *= 0.9; // Auto-level roll
                }

                // Forward thrust
                const speed = this.keys.boost && this.boostEnergy > 0 ? CONFIG.BOOST_SPEED : CONFIG.SHIP_SPEED;
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.mesh.quaternion);

                this.velocity = forward.multiplyScalar(speed);

                // Add lift based on speed and pitch
                const lift = Math.abs(this.mesh.rotation.x) * speed * 0.1;
                this.velocity.y += lift;

                // Boost management
                if (this.keys.boost && this.boostEnergy > 0) {
                    this.boost = true;
                    playSound('boost');
                } else {
                    this.boost = false;
                }

                // Fire weapons
                if (this.keys.fire && Date.now() - this.lastShot > this.weaponStats[this.weaponType].fireRate) {
                    this.fire();
                }

                // Special weapon
                if (this.keys.special && this.specialWeaponReady) {
                    this.fireNuclearMissile();
                }

                // Switch weapon
                if (this.keys.switchWeapon && !this.weaponSwitchCooldown) {
                    this.switchWeapon();
                    this.weaponSwitchCooldown = true;
                    setTimeout(() => { this.weaponSwitchCooldown = false; }, 300);
                }

                // Repair drone
                if (this.keys.repair && this.repairDrones > 0 && this.health < CONFIG.SHIP_HP) {
                    this.deployRepairDrone();
                }

                // Target lock
                if (this.keys.targetLock) {
                    this.engageTargetLock();
                }

                // Update special cooldown
                if (!this.specialWeaponReady) {
                    this.specialCooldown--;
                    if (this.specialCooldown <= 0) {
                        this.specialWeaponReady = true;
                        document.getElementById('specialReady').textContent = 'ARMED';
                        document.getElementById('specialReady').classList.add('special-ready');
                        playSound('powerup');
                    } else {
                        const seconds = Math.ceil(this.specialCooldown / 60);
                        document.getElementById('specialReady').textContent = `${seconds}s`;
                        document.getElementById('specialReady').classList.remove('special-ready');
                    }
                }

                // Update UI
                this.updateUI();

                // Apply parent update
                super.update();

                // Update radar
                updateRadar();
            }

            updateUI() {
                // Score
                this.score = this.kills * 100 + Math.floor(timer / 10);
                document.getElementById('playerScore').textContent = this.score;

                // Health
                const healthValue = document.getElementById('healthValue');
                if (healthValue) healthValue.textContent = Math.round(this.health) + '%';

                // Kill count
                document.getElementById('killCount').textContent = totalKills;
            }

            switchWeapon() {
                this.currentWeaponIndex = (this.currentWeaponIndex + 1) % this.weapons.length;
                this.weaponType = this.weapons[this.currentWeaponIndex];

                document.getElementById('playerWeapon').textContent = this.weaponType;
                showNotification(`Weapon: ${this.weaponType}`, 'normal');
                playSound('powerup');
            }

            fire() {
                this.lastShot = Date.now();

                const weaponData = this.weaponStats[this.weaponType];

                // Multiple firing points for some weapons
                if (this.weaponType === 'ROCKET PODS') {
                    // Fire from both wings
                    for (let i = 0; i < 2; i++) {
                        const offset = i === 0 ? 40 : -40;
                        const position = this.mesh.position.clone();

                        const right = new THREE.Vector3(1, 0, 0);
                        right.applyQuaternion(this.mesh.quaternion);
                        position.add(right.multiplyScalar(offset));

                        const direction = new THREE.Vector3(0, 0, -1);
                        direction.applyQuaternion(this.mesh.quaternion);

                        const rocket = new Rocket(position, direction, this);
                        lasers.push(rocket);
                    }
                } else {
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.mesh.quaternion);

                    const laser = new Laser(
                        this.mesh.position,
                        direction,
                        weaponData.color,
                        this,
                        weaponData.damage,
                        weaponData.speed
                    );
                    lasers.push(laser);
                }

                playSound('shoot', this.weaponType === 'LASER BEAM' ? 1.5 : 1);
            }

            fireNuclearMissile() {
                this.specialWeaponReady = false;
                this.specialCooldown = 600; // 10 seconds
                this.nuclearReady = false;
                this.nuclearCooldown = 600;

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.mesh.quaternion);

                const missile = new NuclearMissile(this.mesh.position.clone(), direction, this);
                missiles.push(missile);

                showNotification('☢️ NUCLEAR MISSILE LAUNCHED!', 'powerup');
                playSound('missile', 0.5);

                // Camera shake
                this.cameraShake(10, 500);
            }

            deployRepairDrone() {
                this.repairDrones--;

                const drone = new RepairDrone(this);

                showNotification(`🔧 Repair Drone Deployed! (${this.repairDrones} left)`, 'powerup');
                playSound('powerup');
            }

            engageTargetLock() {
                if (!this.targetLockActive) {
                    // Find nearest enemy
                    let nearestEnemy = null;
                    let nearestDist = Infinity;

                    ships.forEach(ship => {
                        if (ship !== this && ship.alive) {
                            const dist = this.mesh.position.distanceTo(ship.mesh.position);
                            if (dist < nearestDist && dist < 500) {
                                nearestDist = dist;
                                nearestEnemy = ship;
                            }
                        }
                    });

                    if (nearestEnemy) {
                        this.lockedTarget = nearestEnemy;
                        this.targetLockActive = true;
                        showNotification('🎯 TARGET LOCKED', 'normal');
                        playSound('shield');
                    }
                } else {
                    this.targetLockActive = false;
                    this.lockedTarget = null;
                    showNotification('🎯 Target Lock Disengaged', 'normal');
                }
            }

            cameraShake(intensity, duration) {
                const startTime = Date.now();

                const shake = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed < duration) {
                        const factor = 1 - elapsed / duration;
                        camera.position.x += (Math.random() - 0.5) * intensity * factor;
                        camera.position.y += (Math.random() - 0.5) * intensity * factor;
                        requestAnimationFrame(shake);
                    }
                };
                shake();
            }

            takeDamage(amount, attacker) {
                super.takeDamage(amount, attacker);

                if (this.alive) {
                    // Warning sounds for low health
                    if (this.health < 30 && this.health > 0) {
                        playSound('alarm');
                    }
                }
            }

            destroy() {
                super.destroy();

                // Game over screen
                document.getElementById('winnerName').textContent = 'MISSION FAILED';
                document.getElementById('winnerName').style.color = '#ff0000';
                document.getElementById('winnerStats').innerHTML =
                    `Final Score: ${this.score}<br>` +
                    `Eliminations: ${this.kills}<br>` +
                    `Survival Time: ${CONFIG.BATTLE_TIME - timer}s`;
                document.getElementById('restartText').style.display = 'none';
                document.getElementById('menuButtons').style.display = 'block';
                document.getElementById('winnerOverlay').style.display = 'flex';

                playSound('explosion', 0.5);
            }
        }

        // Laser class enhanced
        class Laser {
            constructor(position, direction, color, owner, damage = CONFIG.DAMAGE, speed = CONFIG.LASER_SPEED) {
                this.owner = owner;
                this.damage = damage;
                this.velocity = direction.multiplyScalar(speed);
                this.life = 180; // 3 seconds

                // Enhanced laser visuals
                const group = new THREE.Group();

                // Main laser beam
                const geometry = new THREE.CylinderGeometry(1, 1.5, 50, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    transparent: true,
                    opacity: 0.9
                });
                const beam = new THREE.Mesh(geometry, material);
                group.add(beam);

                // Glow effect
                const glowGeometry = new THREE.CylinderGeometry(2, 3, 45, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                group.add(glow);

                // Trail effect
                const trailGeometry = new THREE.CylinderGeometry(0.5, 2, 30, 6);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.z = 35;
                group.add(trail);

                this.mesh = group;
                this.mesh.position.copy(position);

                // Align with direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                this.mesh.quaternion.copy(quaternion);

                scene.add(this.mesh);

                // Add light
                this.light = new THREE.PointLight(color, 1, 50);
                this.light.position.copy(position);
                scene.add(this.light);
            }

            update() {
                this.mesh.position.add(this.velocity.clone().multiplyScalar(0.1));
                this.light.position.copy(this.mesh.position);

                this.life--;

                // Check boundaries
                if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5 || this.life <= 0) {
                    this.destroy();
                    return false;
                }

                // Check collisions
                for (let ship of ships) {
                    if (ship !== this.owner && ship.alive) {
                        const distance = this.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < 50) { // Hit detection radius
                            ship.takeDamage(this.damage, this.owner);

                            // Track hit for AI
                            if (this.owner && this.owner.ai) {
                                this.owner.ai.stats.shotsHit++;
                            }

                            this.createHitEffect(ship.mesh.position);
                            this.destroy();
                            return false;
                        }
                    }
                }

                return true;
            }

            createHitEffect(position) {
                // Impact flash
                const flashGeometry = new THREE.SphereGeometry(20, 8, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: this.mesh.children[0].material.color,
                    transparent: true,
                    opacity: 1
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(position);
                scene.add(flash);

                // Animate flash
                const animateFlash = () => {
                    flash.scale.multiplyScalar(1.2);
                    flashMaterial.opacity *= 0.8;

                    if (flashMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateFlash);
                    } else {
                        scene.remove(flash);
                    }
                };
                animateFlash();

                // Create sparks
                for (let i = 0; i < 10; i++) {
                    const particle = {
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        ),
                        life: 20,
                        type: 'spark',
                        color: this.mesh.children[0].material.color,
                        size: 3
                    };
                    particles.push(particle);
                }
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.light);
            }
        }

        // Enhanced Rocket class
        class Rocket {
            constructor(position, direction, owner) {
                this.owner = owner;
                this.damage = 50;
                this.velocity = direction.multiplyScalar(20);
                this.acceleration = direction.clone().multiplyScalar(30);
                this.life = 240; // 4 seconds
                this.target = null;

                // Find target
                if (owner.isPlayer && owner.lockedTarget) {
                    this.target = owner.lockedTarget;
                } else {
                    // Auto-target nearest enemy
                    let nearestDist = 300;
                    ships.forEach(ship => {
                        if (ship !== owner && ship.alive) {
                            const dist = position.distanceTo(ship.mesh.position);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                this.target = ship;
                            }
                        }
                    });
                }

                // Rocket model
                const group = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.CylinderGeometry(2, 3, 25, 6);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff6600,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Warhead
                const warheadGeometry = new THREE.ConeGeometry(3, 10, 6);
                const warheadMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffaa00,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.7
                });
                const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
                warhead.position.x = 17.5;
                warhead.rotation.z = -Math.PI / 2;
                group.add(warhead);

                // Fins
                for (let i = 0; i < 4; i++) {
                    const finGeometry = new THREE.BoxGeometry(10, 0.5, 5);
                    const fin = new THREE.Mesh(finGeometry, bodyMaterial);
                    fin.position.x = -10;
                    fin.rotation.x = (Math.PI / 2) * i;
                    group.add(fin);
                }

                this.mesh = group;
                this.mesh.position.copy(position);

                // Align with direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
                this.mesh.quaternion.copy(quaternion);

                scene.add(this.mesh);

                // Engine flame
                this.createEngineFlame();
            }

            createEngineFlame() {
                const flameGeometry = new THREE.ConeGeometry(3, 15, 8);
                const flameMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                this.flame = new THREE.Mesh(flameGeometry, flameMaterial);
                this.flame.position.x = -20;
                this.flame.rotation.z = Math.PI / 2;
                this.mesh.add(this.flame);

                // Flame light
                this.flameLight = new THREE.PointLight(0x00ffff, 2, 100);
                this.flameLight.position.copy(this.mesh.position);
                scene.add(this.flameLight);
            }

            update() {
                this.life--;

                // Guidance system
                if (this.target && this.target.alive && this.life > 30) {
                    const toTarget = new THREE.Vector3().subVectors(
                        this.target.mesh.position,
                        this.mesh.position
                    );
                    toTarget.normalize();

                    // Proportional navigation
                    const turnRate = 0.05;
                    this.velocity.lerp(toTarget.multiplyScalar(this.velocity.length()), turnRate);
                }

                // Accelerate
                this.velocity.add(this.acceleration.clone().multiplyScalar(0.01));

                // Max speed
                const maxSpeed = 40;
                if (this.velocity.length() > maxSpeed) {
                    this.velocity.normalize().multiplyScalar(maxSpeed);
                }

                // Update position
                this.mesh.position.add(this.velocity.clone().multiplyScalar(0.1));
                this.flameLight.position.copy(this.mesh.position);

                // Update rotation to face velocity
                const lookAtPos = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(lookAtPos);
                this.mesh.rotateZ(Math.PI / 2);

                // Animate flame
                this.flame.scale.x = 0.8 + Math.random() * 0.4;
                this.flame.material.opacity = 0.6 + Math.random() * 0.4;

                // Smoke trail
                if (Math.random() < 0.3) {
                    const particle = {
                        position: this.mesh.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            Math.random() * 2,
                            (Math.random() - 0.5) * 2
                        ),
                        life: 40,
                        type: 'smoke',
                        color: 0x666666,
                        size: 5
                    };
                    particles.push(particle);
                }

                // Check boundaries
                if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5 ||
                    this.life <= 0 ||
                    this.mesh.position.y < 0) {
                    this.explode();
                    return false;
                }

                // Check collisions
                for (let ship of ships) {
                    if (ship !== this.owner && ship.alive) {
                        const distance = this.mesh.position.distanceTo(ship.mesh.position);
                        if (distance < 50) {
                            ship.takeDamage(this.damage, this.owner);
                            this.explode();
                            return false;
                        }
                    }
                }

                return true;
            }

            explode() {
                // Explosion effect
                const explosionGeometry = new THREE.SphereGeometry(40, 16, 16);
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(this.mesh.position);
                scene.add(explosion);

                // Shockwave
                const shockwaveGeometry = new THREE.RingGeometry(1, 5, 32);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.copy(this.mesh.position);
                shockwave.lookAt(camera.position);
                scene.add(shockwave);

                // Animate explosion
                const animateExplosion = () => {
                    explosion.scale.multiplyScalar(1.2);
                    explosionMaterial.opacity *= 0.85;

                    shockwave.scale.multiplyScalar(1.3);
                    shockwaveMaterial.opacity *= 0.9;

                    if (explosionMaterial.opacity > 0.01) {
                        requestAnimationFrame(animateExplosion);
                    } else {
                        scene.remove(explosion);
                        scene.remove(shockwave);
                    }
                };
                animateExplosion();

                // Fragments
                for (let i = 0; i < 15; i++) {
                    const particle = {
                        position: this.mesh.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 30,
                            Math.random() * 20,
                            (Math.random() - 0.5) * 30
                        ),
                        life: 40,
                        type: 'fragment',
                        color: 0xff6600,
                        size: 3
                    };
                    particles.push(particle);
                }

                playSound('explosion');
                this.destroy();
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.flameLight);
            }
        }

        // Enhanced Nuclear Missile class
        class NuclearMissile {
            constructor(position, direction, owner) {
                this.owner = owner;
                this.velocity = direction.normalize().multiplyScalar(CONFIG.LASER_SPEED * 0.5);
                this.target = null;
                this.lifetime = 0;
                this.maxLifetime = 360; // 6 seconds
                this.armed = false;
                this.armTime = 60; // 1 second to arm

                // Create missile model
                const group = new THREE.Group();

                // Main body
                const bodyGeometry = new THREE.CylinderGeometry(4, 6, 80, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Warhead
                const warheadGeometry = new THREE.ConeGeometry(6, 20, 8);
                const warheadMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8
                });
                const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
                warhead.position.x = 50;
                warhead.rotation.z = -Math.PI / 2;
                group.add(warhead);

                // Radiation symbol
                const symbolGeometry = new THREE.PlaneGeometry(20, 20);
                const symbolTexture = this.createRadiationTexture();
                const symbolMaterial = new THREE.MeshBasicMaterial({
                    map: symbolTexture,
                    transparent: true,
                    emissive: 0xffff00,
                    emissiveIntensity: 1
                });
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.z = 6.1;
                group.add(symbol);

                // Fins
                for (let i = 0; i < 4; i++) {
                    const finGeometry = new THREE.BoxGeometry(20, 1, 15);
                    const fin = new THREE.Mesh(finGeometry, bodyMaterial);
                    fin.position.x = -30;
                    fin.rotation.x = (Math.PI / 2) * i;
                    group.add(fin);
                }

                this.mesh = group;
                this.mesh.position.copy(position);

                // Align with direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
                this.mesh.quaternion.copy(quaternion);

                scene.add(this.mesh);

                // Warning systems
                this.createWarningSystems();

                // Find initial target
                this.findTarget();
            }

            createRadiationTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');

                // Clear background
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, 128, 128);

                // Draw radiation symbol
                ctx.strokeStyle = '#ffff00';
                ctx.fillStyle = '#ffff00';
                ctx.lineWidth = 4;

                // Center circle
                ctx.beginPath();
                ctx.arc(64, 64, 10, 0, Math.PI * 2);
                ctx.fill();

                // Three triangular sections
                for (let i = 0; i < 3; i++) {
                    ctx.save();
                    ctx.translate(64, 64);
                    ctx.rotate((Math.PI * 2 / 3) * i);

                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(-20, -50);
                    ctx.lineTo(20, -50);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            createWarningSystems() {
                // Warning light
                this.warningLight = new THREE.PointLight(0xff0000, 5, 200);
                this.warningLight.position.copy(this.mesh.position);
                scene.add(this.warningLight);

                // Tracking beam (visual indicator)
                const beamGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1000, 4);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.2
                });
                this.trackingBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                this.mesh.add(this.trackingBeam);
                this.trackingBeam.position.x = 500;
                this.trackingBeam.rotation.z = Math.PI / 2;

                // Alert all players
                showNotification('⚠️ NUCLEAR MISSILE DETECTED! ⚠️', 'powerup');
                playSound('alarm');
            }

            findTarget() {
                let nearestDist = Infinity;
                let nearestShip = null;

                ships.forEach(ship => {
                    if (ship !== this.owner && ship.alive) {
                        const dist = this.mesh.position.distanceTo(ship.mesh.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestShip = ship;
                        }
                    }
                });

                this.target = nearestShip;
            }

            update() {
                this.lifetime++;

                // Arm the warhead
                if (!this.armed && this.lifetime > this.armTime) {
                    this.armed = true;
                    showNotification('☢️ NUCLEAR WARHEAD ARMED!', 'powerup');
                }

                // Self-destruct if too old
                if (this.lifetime > this.maxLifetime) {
                    this.explode();
                    return false;
                }

                // Update target
                if (!this.target || !this.target.alive) {
                    this.findTarget();
                }

                // Advanced guidance
                if (this.target && this.armed) {
                    const toTarget = new THREE.Vector3();
                    toTarget.subVectors(this.target.mesh.position, this.mesh.position);
                    const distance = toTarget.length();
                    toTarget.normalize();

                    // Proportional navigation with prediction
                    const targetVelocity = this.target.velocity || new THREE.Vector3();
                    const timeToImpact = distance / this.velocity.length();
                    const predictedPos = this.target.mesh.position.clone();
                    predictedPos.add(targetVelocity.clone().multiplyScalar(timeToImpact));

                    const toPredicted = new THREE.Vector3();
                    toPredicted.subVectors(predictedPos, this.mesh.position);
                    toPredicted.normalize();

                    // Smooth turning
                    const turnSpeed = 0.03;
                    this.velocity.lerp(toPredicted.multiplyScalar(this.velocity.length()), turnSpeed);

                    // Update tracking beam
                    if (this.trackingBeam) {
                        const beamLength = distance;
                        this.trackingBeam.scale.y = beamLength / 1000;
                        this.trackingBeam.position.x = beamLength / 2;
                    }
                }

                // Update position
                this.mesh.position.add(this.velocity.clone().multiplyScalar(0.1));

                // Update rotation
                const lookAtPos = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(lookAtPos);
                this.mesh.rotateZ(Math.PI / 2);

                // Update warning systems
                this.warningLight.position.copy(this.mesh.position);
                this.warningLight.intensity = 5 + Math.sin(Date.now() * 0.01) * 3;

                // Engine effects
                if (Math.random() < 0.5) {
                    const particle = {
                        position: this.mesh.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 5
                        ).sub(this.velocity.clone().multiplyScalar(0.1)),
                        life: 60,
                        type: 'nuclear_trail',
                        color: 0xff0000,
                        size: 8
                    };
                    particles.push(particle);
                }

                // Check for impact
                if (this.armed) {
                    // Ground impact
                    if (this.mesh.position.y < 10) {
                        this.explode();
                        return false;
                    }

                    // Ship impact
                    if (this.target) {
                        const distance = this.mesh.position.distanceTo(this.target.mesh.position);
                        if (distance < 60) {
                            this.explode();
                            return false;
                        }
                    }
                }

                return true;
            }

            explode() {
                // Nuclear explosion sequence
                const blastCenter = this.mesh.position.clone();

                // Initial flash
                const flashGeometry = new THREE.SphereGeometry(50, 32, 32);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 2
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(blastCenter);
                scene.add(flash);

                // Fireball
                const fireballGeometry = new THREE.SphereGeometry(80, 32, 32);
                const fireballMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1
                });
                const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
                fireball.position.copy(blastCenter);
                scene.add(fireball);

                // Multiple shockwaves
                const shockwaves = [];
                for (let i = 0; i < 3; i++) {
                    const shockwaveGeometry = new THREE.RingGeometry(1, 10, 64);
                    const shockwaveMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8 - i * 0.2,
                        side: THREE.DoubleSide
                    });
                    const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                    shockwave.position.copy(blastCenter);
                    shockwave.position.y += i * 10;
                    shockwave.rotation.x = -Math.PI / 2;
                    scene.add(shockwave);
                    shockwaves.push(shockwave);
                }

                // Mushroom cloud stem
                const stemGeometry = new THREE.CylinderGeometry(40, 80, 200, 16);
                const stemMaterial = new THREE.MeshBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.7
                });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.copy(blastCenter);
                stem.position.y += 100;
                scene.add(stem);

                // Mushroom cloud cap
                const capGeometry = new THREE.SphereGeometry(100, 16, 12);
                const capMaterial = new THREE.MeshBasicMaterial({
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.8
                });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.copy(blastCenter);
                cap.position.y += 200;
                cap.scale.y = 0.5;
                scene.add(cap);

                // Damage calculation
                const blastRadius = 600;
                ships.forEach(ship => {
                    if (ship.alive) {
                        const distance = blastCenter.distanceTo(ship.mesh.position);
                        if (distance < blastRadius) {
                            // Damage falloff
                            const damageFactor = 1 - (distance / blastRadius);
                            const damage = Math.max(0, damageFactor * 300);
                            ship.takeDamage(damage, this.owner);

                            // Knockback
                            const knockback = new THREE.Vector3();
                            knockback.subVectors(ship.mesh.position, blastCenter);
                            knockback.normalize();
                            knockback.multiplyScalar(damageFactor * 50);
                            ship.velocity.add(knockback);
                        }
                    }
                });

                // Camera shake for player
                if (playerShip && playerShip.alive) {
                    const playerDist = blastCenter.distanceTo(playerShip.mesh.position);
                    if (playerDist < blastRadius * 1.5) {
                        const shakeIntensity = Math.max(0, 1 - playerDist / (blastRadius * 1.5)) * 20;
                        playerShip.cameraShake(shakeIntensity, 1000);
                    }
                }

                // Animate explosion
                let frame = 0;
                const animateNuclearExplosion = () => {
                    frame++;

                    // Flash
                    flash.scale.multiplyScalar(1.5);
                    flashMaterial.opacity *= 0.85;

                    // Fireball expansion
                    fireball.scale.multiplyScalar(1.2);
                    fireballMaterial.opacity *= 0.95;

                    // Shockwaves
                    shockwaves.forEach((shockwave, i) => {
                        shockwave.scale.multiplyScalar(1.3 - i * 0.05);
                        shockwave.material.opacity *= 0.93;
                    });

                    // Mushroom cloud rise
                    stem.position.y += 2;
                    stem.scale.y *= 1.02;
                    cap.position.y += 3;
                    cap.scale.x *= 1.01;
                    cap.scale.z *= 1.01;

                    // Continue animation
                    if (frame < 150) {
                        requestAnimationFrame(animateNuclearExplosion);
                    } else {
                        // Cleanup
                        scene.remove(flash);
                        scene.remove(fireball);
                        shockwaves.forEach(s => scene.remove(s));

                        // Fade out mushroom cloud
                        const fadeCloud = () => {
                            stemMaterial.opacity *= 0.98;
                            capMaterial.opacity *= 0.98;

                            if (stemMaterial.opacity > 0.01) {
                                requestAnimationFrame(fadeCloud);
                            } else {
                                scene.remove(stem);
                                scene.remove(cap);
                            }
                        };
                        setTimeout(fadeCloud, 2000);
                    }
                };
                animateNuclearExplosion();

                // Create radioactive particles
                for (let i = 0; i < 100; i++) {
                    const particle = {
                        position: blastCenter.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 80,
                            Math.random() * 60,
                            (Math.random() - 0.5) * 80
                        ),
                        life: 100 + Math.random() * 100,
                        type: 'radioactive',
                        color: Math.random() > 0.5 ? 0x00ff00 : 0xffff00,
                        size: 5 + Math.random() * 10
                    };
                    particles.push(particle);
                }

                // Sound effects
                playSound('explosion', 0.3);
                setTimeout(() => playSound('explosion', 0.5), 200);
                setTimeout(() => playSound('explosion', 0.7), 500);

                // Achievement notification
                if (this.owner === playerShip) {
                    showNotification('☢️ NUCLEAR DEVASTATION! +1000 POINTS', 'powerup');
                    playerShip.score += 1000;
                }

                this.destroy();
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.warningLight);
                if (this.trackingBeam) {
                    scene.remove(this.trackingBeam);
                }
            }
        }

        // Powerup class
        class Powerup {
            constructor(position, type) {
                this.type = type;
                this.position = position.clone();
                this.collected = false;
                this.lifetime = 600; // 10 seconds

                // Create powerup model
                const group = new THREE.Group();

                // Container
                const containerGeometry = new THREE.OctahedronGeometry(15, 0);
                const containerMaterial = new THREE.MeshPhongMaterial({
                    color: this.getColor(),
                    emissive: this.getColor(),
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const container = new THREE.Mesh(containerGeometry, containerMaterial);
                group.add(container);

                // Inner glow
                const glowGeometry = new THREE.SphereGeometry(20, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: this.getColor(),
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                group.add(glow);

                // Icon
                this.createIcon(group);

                this.mesh = group;
                this.mesh.position.copy(position);
                scene.add(this.mesh);

                // Light
                this.light = new THREE.PointLight(this.getColor(), 2, 100);
                this.light.position.copy(position);
                scene.add(this.light);
            }

            getColor() {
                switch (this.type) {
                    case 'health': return 0x00ff00;
                    case 'shield': return 0x00ffff;
                    case 'weapon': return 0xff00ff;
                    case 'boost': return 0xffaa00;
                    default: return 0xffffff;
                }
            }

            createIcon(group) {
                const iconGeometry = new THREE.PlaneGeometry(10, 10);
                let iconText = '';

                switch (this.type) {
                    case 'health': iconText = '+'; break;
                    case 'shield': iconText = '◊'; break;
                    case 'weapon': iconText = '※'; break;
                    case 'boost': iconText = '↑'; break;
                }

                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(iconText, 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const iconMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });

                const icon = new THREE.Mesh(iconGeometry, iconMaterial);
                icon.position.z = 1;
                group.add(icon);
            }

            update() {
                this.lifetime--;

                // Rotation
                this.mesh.rotation.y += 0.02;
                this.mesh.rotation.x += 0.01;

                // Floating motion
                this.mesh.position.y += Math.sin(Date.now() * 0.003) * 0.5;

                // Pulse effect
                const scale = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                this.mesh.scale.set(scale, scale, scale);

                // Check collection
                ships.forEach(ship => {
                    if (ship.alive && !this.collected) {
                        const distance = ship.mesh.position.distanceTo(this.mesh.position);
                        if (distance < 50) {
                            this.collect(ship);
                        }
                    }
                });

                // Fade out when expiring
                if (this.lifetime < 60) {
                    this.mesh.children[0].material.opacity = this.lifetime / 60;
                }

                return this.lifetime > 0 && !this.collected;
            }

            collect(ship) {
                this.collected = true;

                let message = '';

                switch (this.type) {
                    case 'health':
                        const healthBoost = 30;
                        ship.health = Math.min(CONFIG.SHIP_HP, ship.health + healthBoost);
                        message = `+${healthBoost} HEALTH`;
                        break;

                    case 'shield':
                        ship.shield = CONFIG.SHIELD_HP;
                        message = 'SHIELD RECHARGED';
                        break;

                    case 'weapon':
                        if (ship.isPlayer) {
                            ship.switchWeapon();
                            message = 'WEAPON UPGRADE';
                        } else {
                            ship.score += 50;
                            message = '+50 POINTS';
                        }
                        break;

                    case 'boost':
                        ship.boostEnergy = CONFIG.BOOST_MAX;
                        message = 'BOOST RECHARGED';
                        break;
                }

                if (ship.isPlayer || ship === playerShip) {
                    showNotification(`✨ ${message}`, 'powerup');
                }

                if (ship.ai) {
                    ship.ai.stats.powerupsCollected++;
                }

                playSound('powerup');
                this.destroy();
            }

            destroy() {
                scene.remove(this.mesh);
                scene.remove(this.light);
            }
        }

        // Repair Drone class
        class RepairDrone {
            constructor(owner) {
                this.owner = owner;
                this.lifetime = 600; // 10 seconds
                this.healRate = 0.5; // HP per frame
                this.orbitRadius = 80;
                this.orbitSpeed = 0.05;
                this.orbitAngle = Math.random() * Math.PI * 2;

                // Create drone model
                const group = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.SphereGeometry(5, 8, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);

                // Tools
                for (let i = 0; i < 4; i++) {
                    const toolGeometry = new THREE.CylinderGeometry(1, 1, 10, 4);
                    const tool = new THREE.Mesh(toolGeometry, bodyMaterial);
                    tool.position.x = Math.cos(i * Math.PI / 2) * 7;
                    tool.position.z = Math.sin(i * Math.PI / 2) * 7;
                    tool.rotation.z = Math.PI / 4;
                    group.add(tool);
                }

                this.mesh = group;
                scene.add(this.mesh);

                // Healing beam
                const beamGeometry = new THREE.CylinderGeometry(0.5, 2, 80, 8);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.5
                });
                this.healBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                scene.add(this.healBeam);

                // Light
                this.light = new THREE.PointLight(0x00ff00, 1, 100);
                scene.add(this.light);

                this.active = true;
            }

            update() {
                if (!this.active || !this.owner.alive) {
                    this.destroy();
                    return false;
                }

                this.lifetime--;
                if (this.lifetime <= 0) {
                    this.destroy();
                    return false;
                }

                // Orbit around owner
                this.orbitAngle += this.orbitSpeed;
                const x = this.owner.mesh.position.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                const z = this.owner.mesh.position.z + Math.sin(this.orbitAngle) * this.orbitRadius;
                const y = this.owner.mesh.position.y + 20;

                this.mesh.position.set(x, y, z);
                this.mesh.rotation.y += 0.1;

                // Update heal beam
                const distance = this.mesh.position.distanceTo(this.owner.mesh.position);
                this.healBeam.position.copy(this.mesh.position);
                this.healBeam.position.lerp(this.owner.mesh.position, 0.5);
                this.healBeam.scale.y = distance / 80;
                this.healBeam.lookAt(this.owner.mesh.position);
                this.healBeam.rotateX(Math.PI / 2);

                // Update light
                this.light.position.copy(this.mesh.position);

                // Heal owner
                if (this.owner.health < CONFIG.SHIP_HP) {
                    this.owner.health = Math.min(CONFIG.SHIP_HP, this.owner.health + this.healRate);

                    // Create healing particles
                    if (Math.random() < 0.3) {
                        const particle = {
                            position: this.owner.mesh.position.clone(),
                            velocity: new THREE.Vector3(0, 2, 0),
                            life: 30,
                            type: 'heal',
                            color: 0x00ff00,
                            size: 3
                        };
                        particles.push(particle);
                    }
                }

                return true;
            }

            destroy() {
                this.active = false;
                scene.remove(this.mesh);
                scene.remove(this.healBeam);
                scene.remove(this.light);
            }
        }

        // Engine Trail effect
        class EngineTrail {
            constructor(ship) {
                this.ship = ship;
                this.trail = [];
                this.maxLength = 20;
            }

            update() {
                if (!this.ship.alive) {
                    this.destroy();
                    return;
                }

                // Add new trail segment
                const segment = {
                    position: this.ship.mesh.position.clone(),
                    opacity: 1,
                    scale: 1
                };

                // Get engine positions
                const engineOffsets = [
                    new THREE.Vector3(-45, 15, 0),
                    new THREE.Vector3(-45, -15, 0)
                ];

                engineOffsets.forEach(offset => {
                    const worldOffset = offset.clone();
                    worldOffset.applyQuaternion(this.ship.mesh.quaternion);

                    const trailPos = this.ship.mesh.position.clone().add(worldOffset);

                    const geometry = new THREE.SphereGeometry(5, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: this.ship.boost ? 0x00ffff : 0x0066cc,
                        transparent: true,
                        opacity: segment.opacity
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(trailPos);

                    scene.add(mesh);

                    this.trail.push({
                        mesh: mesh,
                        material: material,
                        life: this.maxLength
                    });
                });

                // Update existing trail
                this.trail.forEach((segment, index) => {
                    segment.life--;
                    segment.material.opacity = segment.life / this.maxLength;
                    segment.mesh.scale.multiplyScalar(0.95);

                    if (segment.life <= 0) {
                        scene.remove(segment.mesh);
                    }
                });

                // Remove old segments
                this.trail = this.trail.filter(segment => segment.life > 0);
            }

            destroy() {
                this.trail.forEach(segment => {
                    scene.remove(segment.mesh);
                });
                this.trail = [];
            }
        }

        // Particle System
        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.life--;

                if (particle.life <= 0) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                    particles.splice(index, 1);
                    return;
                }

                // Update position
                particle.position.add(particle.velocity.clone().multiplyScalar(0.1));

                // Apply gravity to some particles
                if (particle.type === 'debris' || particle.type === 'fragment') {
                    particle.velocity.y -= CONFIG.GRAVITY * 0.5;
                }

                // Update visual
                if (!particle.mesh) {
                    const geometry = new THREE.SphereGeometry(particle.size, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: particle.color,
                        transparent: true,
                        opacity: 1
                    });
                    particle.mesh = new THREE.Mesh(geometry, material);
                    scene.add(particle.mesh);
                }

                particle.mesh.position.copy(particle.position);

                // Fade out
                const lifeRatio = particle.life / 60;
                particle.mesh.material.opacity = lifeRatio;

                // Special effects
                switch (particle.type) {
                    case 'fire':
                        particle.mesh.scale.multiplyScalar(1.05);
                        particle.velocity.y += 0.2;
                        break;
                    case 'smoke':
                        particle.mesh.scale.multiplyScalar(1.02);
                        particle.velocity.y += 0.1;
                        particle.mesh.material.opacity *= 0.95;
                        break;
                    case 'radioactive':
                        particle.mesh.material.color.setHex(
                            Math.random() > 0.5 ? 0x00ff00 : 0xffff00
                        );
                        break;
                }
            });
        }

        // Game Management Functions
        function startBattle() {
            timer = CONFIG.BATTLE_TIME;
            ships = [];
            lasers = [];
            missiles = [];
            powerups = [];
            particles = [];
            gameState = 'battle';
            playerShip = null;
            totalKills = 0;
            comboKills = 0;

            // Create ships based on mode
            if (gameMode === 'player' || gameMode === 'mixed') {
                playerShip = new PlayerShip();
                ships.push(playerShip);
                setupPlayerControls();
            }

            // Create AI ships
            const aiCount = gameMode === 'player' ? 5 : (gameMode === 'mixed' ? 5 : 6);
            const aiColors = [
                0xff0000, // Red
                0x0000ff, // Blue
                0xff00ff, // Magenta
                0xffff00, // Yellow
                0xff6600, // Orange
                0x00ffff  // Cyan
            ];

            for (let i = 0; i < aiCount; i++) {
                const config = {
                    name: `Elite AI-${i + 1}`,
                    color: aiColors[i % aiColors.length],
                    emissive: aiColors[i % aiColors.length]
                };
                const ship = new Ship(config, i);
                ships.push(ship);
            }

            showNotification('🚀 BATTLE COMMENCING - AI GENERATION 5000 🚀', 'powerup');

            // Start game loop
            gameLoop();

            // Start powerup spawning
            spawnPowerups();
        }

        function gameLoop() {
            if (gameState !== 'battle') return;

            timer--;
            updateHUD();

            const alive = ships.filter(s => s.alive);

            // Check player death in player modes
            if ((gameMode === 'player' || gameMode === 'mixed') && playerShip && !playerShip.alive) {
                endBattle();
                return;
            }

            // Check win conditions
            if (alive.length <= 1 || timer <= 0) {
                endBattle();
                return;
            }

            // Continue loop
            setTimeout(gameLoop, 1000);
        }

        function spawnPowerups() {
            if (gameState !== 'battle') return;

            // Random spawn
            if (Math.random() < 0.1 && powerups.length < 5) {
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5,
                    50 + Math.random() * 200,
                    (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5
                );

                const types = ['health', 'shield', 'weapon', 'boost'];
                const type = types[Math.floor(Math.random() * types.length)];

                const powerup = new Powerup(position, type);
                powerups.push(powerup);
            }

            // Continue spawning
            setTimeout(spawnPowerups, CONFIG.POWERUP_SPAWN_TIME);
        }

        function endBattle() {
            gameState = 'ended';

            const alive = ships.filter(s => s.alive);
            const winner = alive.length > 0 ? alive[0] : ships[0];

            // Show winner screen
            if (winner && !winner.isPlayer) {
                document.getElementById('winnerName').textContent = winner.name;
                document.getElementById('winnerName').style.color = '#' + winner.config.color.toString(16).padStart(6, '0');

                let statsText = `Final Score: ${winner.score}<br>`;
                statsText += `Eliminations: ${winner.kills}<br>`;

                if (winner.ai) {
                    const accuracy = winner.ai.stats.shotsFired > 0 ?
                        Math.round((winner.ai.stats.shotsHit / winner.ai.stats.shotsFired) * 100) : 0;
                    statsText += `Accuracy: ${accuracy}%<br>`;
                    statsText += `Maneuvers: ${winner.ai.stats.maneuversExecuted}<br>`;
                    statsText += `Damage Dealt: ${winner.ai.stats.damageDealt}`;
                }

                document.getElementById('winnerStats').innerHTML = statsText;
                document.getElementById('restartText').style.display = 'block';
                document.getElementById('menuButtons').style.display = 'none';
                document.getElementById('winnerOverlay').style.display = 'flex';

                // Auto-restart in AI mode
                if (gameMode === 'ai') {
                    let countdown = 5;
                    const countInterval = setInterval(() => {
                        countdown--;
                        document.getElementById('countdown').textContent = countdown;
                        if (countdown <= 0) {
                            clearInterval(countInterval);
                            document.getElementById('winnerOverlay').style.display = 'none';
                            cleanupBattle();
                            startBattle();
                        }
                    }, 1000);
                }
            } else if (winner && winner.isPlayer) {
                // Player victory
                document.getElementById('winnerName').textContent = '🎉 MISSION ACCOMPLISHED 🎉';
                document.getElementById('winnerName').style.color = '#00ff00';
                document.getElementById('winnerStats').innerHTML =
                    `Final Score: ${winner.score}<br>` +
                    `Eliminations: ${winner.kills}<br>` +
                    `Accuracy: CLASSIFIED<br>` +
                    `Rank: ACE PILOT`;
                document.getElementById('restartText').style.display = 'none';
                document.getElementById('menuButtons').style.display = 'block';
                document.getElementById('winnerOverlay').style.display = 'flex';

                playSound('powerup');
            }
        }

        function cleanupBattle() {
            // Remove all game objects
            ships.forEach(ship => {
                if (ship.mesh) scene.remove(ship.mesh);
                if (ship.engineTrail) ship.engineTrail.destroy();
            });

            lasers.forEach(laser => {
                if (laser.mesh) scene.remove(laser.mesh);
                if (laser.light) scene.remove(laser.light);
            });

            missiles.forEach(missile => {
                if (missile.mesh) scene.remove(missile.mesh);
                if (missile.warningLight) scene.remove(missile.warningLight);
            });

            powerups.forEach(powerup => {
                if (powerup.mesh) scene.remove(powerup.mesh);
                if (powerup.light) scene.remove(powerup.light);
            });

            particles.forEach(particle => {
                if (particle.mesh) scene.remove(particle.mesh);
            });

            // Clear arrays
            ships = [];
            lasers = [];
            missiles = [];
            powerups = [];
            particles = [];
        }

        function updateHUD() {
            // Update survivor count
            const alive = ships.filter(s => s.alive);
            document.getElementById('aliveCount').textContent = alive.length;

            // Update timer
            const minutes = Math.floor(timer / 60);
            const seconds = timer % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Update kill count
            document.getElementById('killCount').textContent = totalKills;
        }

        // Enhanced Player Controls
        function setupPlayerControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!playerShip || !playerShip.alive) return;

                switch(e.key.toLowerCase()) {
                    case 'arrowup': playerShip.keys.up = true; e.preventDefault(); break;
                    case 'arrowdown': playerShip.keys.down = true; e.preventDefault(); break;
                    case 'arrowleft': playerShip.keys.left = true; e.preventDefault(); break;
                    case 'arrowright': playerShip.keys.right = true; e.preventDefault(); break;
                    case ' ': playerShip.keys.fire = true; e.preventDefault(); break;
                    case 'shift': playerShip.keys.boost = true; e.preventDefault(); break;
                    case 'e': playerShip.keys.special = true; e.preventDefault(); break;
                    case 'q': playerShip.keys.switchWeapon = true; e.preventDefault(); break;
                    case 'r': playerShip.keys.repair = true; e.preventDefault(); break;
                    case 'tab': playerShip.keys.targetLock = true; e.preventDefault(); break;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (!playerShip || !playerShip.alive) return;

                switch(e.key.toLowerCase()) {
                    case 'arrowup': playerShip.keys.up = false; break;
                    case 'arrowdown': playerShip.keys.down = false; break;
                    case 'arrowleft': playerShip.keys.left = false; break;
                    case 'arrowright': playerShip.keys.right = false; break;
                    case ' ': playerShip.keys.fire = false; break;
                    case 'shift': playerShip.keys.boost = false; break;
                    case 'e': playerShip.keys.special = false; break;
                    case 'q': playerShip.keys.switchWeapon = false; break;
                    case 'r': playerShip.keys.repair = false; break;
                    case 'tab': playerShip.keys.targetLock = false; break;
                }
            });

            // Mouse controls (optional)
            let mouseX = 0, mouseY = 0;

            document.addEventListener('mousemove', (e) => {
                if (!playerShip || !playerShip.alive) return;

                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            document.addEventListener('mousedown', (e) => {
                if (!playerShip || !playerShip.alive) return;

                if (e.button === 0) { // Left click
                    playerShip.keys.fire = true;
                } else if (e.button === 2) { // Right click
                    playerShip.keys.boost = true;
                    e.preventDefault();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (!playerShip || !playerShip.alive) return;

                if (e.button === 0) {
                    playerShip.keys.fire = false;
                } else if (e.button === 2) {
                    playerShip.keys.boost = false;
                }
            });

            // Prevent right-click menu
            document.addEventListener('contextmenu', (e) => {
                if (gameState === 'battle') {
                    e.preventDefault();
                }
            });
        }

        // Main Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0001;

            // Update camera based on game mode
            updateCamera(time);

            // Update game objects if battle is active
            if (gameState === 'battle') {
                // Update ships
                ships.forEach(ship => ship.update());

                // Update projectiles
                lasers = lasers.filter(laser => laser.update());
                missiles = missiles.filter(missile => missile.update());

                // Update powerups
                powerups = powerups.filter(powerup => powerup.update());

                // Update particles
                updateParticles();

                // Update repair drones (handled by ships)
            }

            // Update environment
            updateEnvironment(time);

            // Render scene
            renderer.render(scene, camera);
        }

        // Camera System
        function updateCamera(time) {
            if (gameMode === 'player' && playerShip && playerShip.alive) {
                // First-person follow camera
                const offset = playerShip.cameraOffset.clone();
                offset.applyQuaternion(playerShip.mesh.quaternion);

                const targetPos = playerShip.mesh.position.clone().add(offset);
                camera.position.lerp(targetPos, 0.1);

                const lookOffset = new THREE.Vector3(0, 0, -200);
                lookOffset.applyQuaternion(playerShip.mesh.quaternion);
                const lookTarget = playerShip.mesh.position.clone().add(lookOffset);

                camera.lookAt(lookTarget);

            } else if (gameMode === 'mixed' && playerShip && playerShip.alive) {
                // Third-person camera
                const distance = 180;
                const height = 80;

                const offset = new THREE.Vector3(
                    Math.sin(playerShip.mesh.rotation.y) * distance,
                    height,
                    Math.cos(playerShip.mesh.rotation.y) * distance
                );

                const targetPos = playerShip.mesh.position.clone().add(offset);
                camera.position.lerp(targetPos, 0.08);
                camera.lookAt(playerShip.mesh.position);

            } else {
                // Cinematic camera for AI mode or when player is dead
                const radius = 600 + Math.sin(time * 0.5) * 200;
                camera.position.x = Math.cos(time) * radius;
                camera.position.z = Math.sin(time) * radius;
                camera.position.y = 300 + Math.sin(time * 2) * 100;

                // Look at center of action
                if (ships.length > 0) {
                    const avgPos = new THREE.Vector3();
                    let count = 0;

                    ships.forEach(ship => {
                        if (ship.alive) {
                            avgPos.add(ship.mesh.position);
                            count++;
                        }
                    });

                    if (count > 0) {
                        avgPos.divideScalar(count);
                        camera.lookAt(avgPos);
                    }
                } else {
                    camera.lookAt(0, 100, 0);
                }
            }
        }

        // Environment Updates
        function updateEnvironment(time) {
            // Update ocean waves
            scene.traverse((child) => {
                if (child.userData.update) {
                    child.userData.update(time);
                }
            });

            // Update clouds
            const clouds = scene.getObjectByName('cloudGroup');
            if (clouds && clouds.userData.update) {
                clouds.userData.update(time);
            }

            // Weather effects
            if (weather.rain) {
                createRainEffect();
            }

            // Random lightning in storms
            if (weather.lightning && Math.random() < 0.001) {
                triggerLightning();
            }
        }

        // Rain Effect
        function createRainEffect() {
            if (Math.random() < 0.3) {
                const rainDrop = {
                    position: new THREE.Vector3(
                        camera.position.x + (Math.random() - 0.5) * 500,
                        camera.position.y + 200,
                        camera.position.z + (Math.random() - 0.5) * 500
                    ),
                    velocity: new THREE.Vector3(0, -20, 0).add(weather.wind),
                    life: 100,
                    type: 'rain',
                    color: 0x4488ff,
                    size: 1
                };
                particles.push(rainDrop);
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Prevent scrolling with arrow keys
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        // Performance monitoring
        let lastTime = performance.now();
        let fps = 0;
        let frameCount = 0;

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();

            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;

                // Optional: Display FPS
                // console.log(`FPS: ${fps}`);
            }
        }

        // Call updateFPS in animate loop if needed
        function animateWithFPS() {
            updateFPS();
            animate();
        }

        // Initialize the game
        init();

    }); // End of window load event

    // ====================================
    // FIN DU CODE - SKY & SEA BATTLE 3D
    // ====================================
</script>
<script src="game2.js"></script>
</body>
</html>