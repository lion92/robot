<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Drone Battle Arena - Spectateur (ciel √©toil√©)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0b1739, #111b3a);
            overflow: hidden;
            font-family: monospace;
            color: #fff;
        }
        canvas { position: absolute; top: 0; left: 0; }
        #stats {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px; border-radius: 10px; font-size: 14px; min-width: 200px;
        }
        #teams {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px; border-radius: 10px; font-size: 14px;
        }
        .team-blue { color: #4facfe; }
        .team-red { color: #ff6b6b; }
        #controls {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px; border-radius: 10px; display: flex; gap: 10px; flex-wrap: wrap;
        }
        button {
            padding: 8px 16px; border: none; background: #4facfe; color: white;
            border-radius: 5px; cursor: pointer; font-size: 14px;
        }
        button:hover { background: #00f2fe; }
        #winner {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 48px; font-weight: bold; text-shadow: 0 0 20px rgba(255,255,255,0.5);
            display: none; animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="stats">
    <h3>‚öîÔ∏è BATAILLE EN COURS</h3>
    <div>Dur√©e: <span id="time">0</span>s</div>
    <div>Tirs: <span id="shots">0</span></div>
    <div>√âliminations: <span id="kills">0</span></div>
</div>

<div id="teams">
    <div class="team-blue">üîµ √âquipe Bleue: <span id="blue-count">0</span></div>
    <div class="team-red">üî¥ √âquipe Rouge: <span id="red-count">0</span></div>
</div>

<div id="controls">
    <button onclick="startBattle(5)">5v5</button>
    <button onclick="startBattle(10)">10v10</button>
    <button onclick="startBattle(20)">20v20 CHAOS</button>
    <button onclick="toggleCamera()">üì∑ Changer Vue</button>
    <button onclick="toggleSpeed()">‚è© Vitesse x<span id="speed">1</span></button>
</div>

<div id="winner"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer;
    let drones = [], bullets = [], particles = [];
    let stats = { time: 0, shots: 0, kills: 0 };
    let gameSpeed = 1;
    let cameraMode = 0;
    let battleStart = 0;

    // ‚òÖ‚òÖ CIEL √âTOIL√â ‚òÖ‚òÖ
    let starLayers = []; // { points, material, phase, rotSpeed }

    // Init Three.js
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0a0a, 200, 1500);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 1, 4000);
    camera.position.set(0, 300, 500);

    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('c'),
        antialias: true,
        alpha: true
    });
    renderer.setSize(innerWidth, innerHeight);

    // Lighting
    scene.add(new THREE.AmbientLight(0x404040, 0.3));
    const moon = new THREE.DirectionalLight(0x4a90e2, 0.5);
    moon.position.set(200, 400, 200);
    moon.castShadow = true;
    scene.add(moon);

    // City glow
    const cityGlow = new THREE.HemisphereLight(0xff9500, 0x1a1a1a, 0.4);
    scene.add(cityGlow);

    // Central Park ground
    const parkGround = new THREE.Mesh(
        new THREE.PlaneGeometry(1200, 1200, 30, 30),
        new THREE.MeshPhongMaterial({ color: 0x2d5016, roughness: 0.8, metalness: 0.2 })
    );
    parkGround.rotation.x = -Math.PI/2;
    parkGround.receiveShadow = true;
    scene.add(parkGround);

    // Park paths
    const pathMaterial = new THREE.MeshPhongMaterial({ color: 0x8b7355, roughness: 0.9 });
    const pathH = new THREE.Mesh(new THREE.PlaneGeometry(1200, 20), pathMaterial);
    pathH.rotation.x = -Math.PI/2; pathH.position.y = 0.1; scene.add(pathH);
    const pathV = new THREE.Mesh(new THREE.PlaneGeometry(20, 1200), pathMaterial);
    pathV.rotation.x = -Math.PI/2; pathV.position.y = 0.1; scene.add(pathV);
    for(let i = 0; i < 2; i++) {
        const diagPath = new THREE.Mesh(new THREE.PlaneGeometry(15, 800), pathMaterial);
        diagPath.rotation.x = -Math.PI/2;
        diagPath.rotation.z = (i === 0 ? Math.PI/4 : -Math.PI/4);
        diagPath.position.y = 0.1;
        scene.add(diagPath);
    }

    // Create trees
    function createTrees() {
        for(let x = -500; x <= 500; x += 60) {
            for(let z = -500; z <= 500; z += 60) {
                if(Math.abs(x) < 20 || Math.abs(z) < 20) continue;
                if(Math.abs(x) < 100 && Math.abs(z) < 100) continue;

                const posX = x + (Math.random() - 0.5) * 20;
                const posZ = z + (Math.random() - 0.5) * 20;
                const treeType = Math.random();

                if(treeType < 0.6) {
                    const treeGroup = new THREE.Group();
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(3, 4, 20),
                        new THREE.MeshPhongMaterial({ color: 0x4a3c28 })
                    );
                    trunk.position.y = 10; treeGroup.add(trunk);

                    const foliageColor = [0x2d5016, 0x3a5f0b, 0x4d7c0f][Math.floor(Math.random() * 3)];
                    for(let j = 0; j < 3; j++) {
                        const foliage = new THREE.Mesh(
                            new THREE.SphereGeometry(12 - j*2, 6, 5),
                            new THREE.MeshPhongMaterial({ color: foliageColor, flatShading: true })
                        );
                        foliage.position.y = 25 + j*5;
                        foliage.position.x = (Math.random() - 0.5) * 5;
                        foliage.position.z = (Math.random() - 0.5) * 5;
                        treeGroup.add(foliage);
                    }
                    treeGroup.position.set(posX, 0, posZ);
                    treeGroup.scale.y = 0.8 + Math.random() * 0.4;
                    scene.add(treeGroup);

                } else if(treeType < 0.85) {
                    const pineGroup = new THREE.Group();
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(2, 3, 25),
                        new THREE.MeshPhongMaterial({ color: 0x5d4e37 })
                    );
                    trunk.position.y = 12.5; pineGroup.add(trunk);
                    for(let j = 0; j < 3; j++) {
                        const cone = new THREE.Mesh(
                            new THREE.ConeGeometry(10 - j*2, 15 - j*3, 6),
                            new THREE.MeshPhongMaterial({ color: 0x0f5132, flatShading: true })
                        );
                        cone.position.y = 20 + j*8; pineGroup.add(cone);
                    }
                    pineGroup.position.set(posX, 0, posZ);
                    scene.add(pineGroup);

                } else {
                    const bushGroup = new THREE.Group();
                    for(let j = 0; j < 3; j++) {
                        const bush = new THREE.Mesh(
                            new THREE.SphereGeometry(5 + Math.random()*3, 5, 4),
                            new THREE.MeshPhongMaterial({ color: 0x3a5f0b, flatShading: true })
                        );
                        bush.position.set((Math.random() - 0.5) * 10, 5, (Math.random() - 0.5) * 10);
                        bushGroup.add(bush);
                    }
                    bushGroup.position.set(posX, 0, posZ);
                    scene.add(bushGroup);
                }
            }
        }
    }

    // Lake + fountain
    const lake = new THREE.Mesh(
        new THREE.CircleGeometry(80, 16),
        new THREE.MeshPhongMaterial({ color: 0x006994, transparent: true, opacity: 0.8, shininess: 100 })
    );
    lake.rotation.x = -Math.PI/2; lake.position.y = 0.05; scene.add(lake);

    const fountainGroup = new THREE.Group();
    const fountainBase = new THREE.Mesh(
        new THREE.CylinderGeometry(15, 18, 5),
        new THREE.MeshPhongMaterial({ color: 0x808080 })
    );
    fountainBase.position.y = 2.5; fountainGroup.add(fountainBase);
    const fountainPillar = new THREE.Mesh(
        new THREE.CylinderGeometry(3, 3, 20),
        new THREE.MeshPhongMaterial({ color: 0x909090 })
    );
    fountainPillar.position.y = 10; fountainGroup.add(fountainPillar);
    for(let i = 0; i < 20; i++) {
        const droplet = new THREE.Mesh(
            new THREE.SphereGeometry(0.5),
            new THREE.MeshBasicMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.6 })
        );
        droplet.position.set((Math.random()-0.5)*10, 20 + Math.random()*10, (Math.random()-0.5)*10);
        fountainGroup.add(droplet);
    }
    scene.add(fountainGroup);

    // Benches
    function createBenches() {
        const benchPositions = [
            {x: -100, z: 50}, {x: 100, z: 50},
            {x: -100, z: -50}, {x: 100, z: -50},
            {x: 50, z: 100}, {x: -50, z: 100},
            {x: 50, z: -100}, {x: -50, z: -100}
        ];
        benchPositions.forEach(pos => {
            const benchGroup = new THREE.Group();
            const seat = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
            seat.position.y = 5; benchGroup.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(20, 8, 1), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
            back.position.set(0, 9, -3.5); benchGroup.add(back);
            for(let i = -8; i <= 8; i += 16) {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 1), new THREE.MeshPhongMaterial({ color: 0x696969 }));
                leg.position.set(i, 2.5, 0); benchGroup.add(leg);
            }
            benchGroup.position.set(pos.x, 0, pos.z);
            benchGroup.rotation.y = Math.atan2(pos.z, pos.x);
            scene.add(benchGroup);
        });
    }

    // Park lamps
    function createParkLamps() {
        const lampPositions = [
            {x: -150, z: -150}, {x: 150, z: -150},
            {x: -150, z: 150},  {x: 150, z: 150},
            {x: 0, z: -200},    {x: 0, z: 200},
            {x: -200, z: 0},    {x: 200, z: 0}
        ];
        lampPositions.forEach(pos => {
            const lampGroup = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 30), new THREE.MeshPhongMaterial({ color: 0x2c2c2c }));
            pole.position.y = 15; lampGroup.add(pole);
            const lampHead = new THREE.Mesh(
                new THREE.SphereGeometry(4, 6, 4),
                new THREE.MeshPhongMaterial({ color: 0xfffacd, emissive: 0xffff00, emissiveIntensity: 0.5 })
            );
            lampHead.position.y = 30; lampGroup.add(lampHead);
            const lampLight = new THREE.PointLight(0xffd700, 0.5, 80);
            lampLight.position.y = 30; lampGroup.add(lampLight);
            lampGroup.position.set(pos.x, 0, pos.z);
            scene.add(lampGroup);
        });
    }

    createTrees();
    createBenches();
    createParkLamps();

    // ‚òÖ‚òÖ Cr√©e le ciel √©toil√© ‚òÖ‚òÖ
    function createStarfield() {
        const layerDefs = [
            { count: 1200, size: 1.8, radius: 1800, rotSpeed: 0.00003 },
            { count: 900,  size: 1.4, radius: 2000, rotSpeed: 0.00002 },
            { count: 700,  size: 1.1, radius: 2300, rotSpeed: 0.00001 },
        ];

        layerDefs.forEach(def => {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(def.count * 3);

            for (let i = 0; i < def.count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = def.radius + (Math.random() - 0.5) * 80;

                positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.cos(phi);
                positions[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
            }

            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: def.size,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                fog: false
            });

            const points = new THREE.Points(geom, mat);
            scene.add(points);

            starLayers.push({
                points,
                material: mat,
                phase: Math.random() * Math.PI * 2,
                rotSpeed: def.rotSpeed
            });
        });

        // (Optionnel) lune discr√®te + lumi√®re douce
        const moonSphere = new THREE.Mesh(
            new THREE.SphereGeometry(40, 16, 12),
            new THREE.MeshPhongMaterial({ color: 0xe8e8ff, emissive: 0x8888ff, emissiveIntensity: 0.4 })
        );
        moonSphere.position.set(-900, 600, -900);
        scene.add(moonSphere);

        const moonLight2 = new THREE.DirectionalLight(0xcad7ff, 0.35);
        moonLight2.position.copy(moonSphere.position).normalize();
        scene.add(moonLight2);
    }
    createStarfield();

    // Boeing 747
    class Boeing747 {
        constructor() {
            const group = new THREE.Group();
            const fuselage = new THREE.Mesh(
                new THREE.CylinderGeometry(8, 8, 80, 12),
                new THREE.MeshPhongMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 })
            );
            fuselage.rotation.z = Math.PI / 2; group.add(fuselage);

            const nose = new THREE.Mesh(new THREE.ConeGeometry(8, 15, 12), fuselage.material);
            nose.rotation.z = -Math.PI / 2; nose.position.x = 47.5; group.add(nose);

            const tail = new THREE.Mesh(new THREE.ConeGeometry(8, 10, 12), fuselage.material);
            tail.rotation.z = Math.PI / 2; tail.position.x = -45; tail.scale.y = 0.8; group.add(tail);

            const wings = new THREE.Mesh(new THREE.BoxGeometry(60, 1, 15), new THREE.MeshPhongMaterial({ color: 0xa0a0a0, metalness: 0.7 }));
            wings.position.y = -2; wings.scale.z = 1; wings.scale.x = 1.5; group.add(wings);

            const fin = new THREE.Mesh(new THREE.BoxGeometry(2, 20, 10), wings.material);
            fin.position.set(-35, 10, 0); group.add(fin);

            const stabilizer = new THREE.Mesh(new THREE.BoxGeometry(25, 1, 8), wings.material);
            stabilizer.position.set(-35, 10, 0); group.add(stabilizer);

            const enginePositions = [
                { x: 10, y: -5, z: 20 }, { x: 10, y: -5, z: -20 },
                { x: -5, y: -5, z: 35 }, { x: -5, y: -5, z: -35 }
            ];
            enginePositions.forEach(pos => {
                const engine = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 3, 10, 8),
                    new THREE.MeshPhongMaterial({ color: 0x333333, metalness: 0.9 })
                );
                engine.rotation.z = Math.PI / 2; engine.position.set(pos.x, pos.y, pos.z); group.add(engine);
            });

            for(let i = -30; i <= 30; i += 4) {
                const windowGeometry = new THREE.BoxGeometry(1.5, 2, 1);
                const windowMaterial = new THREE.MeshBasicMaterial({ color: 0x87ceeb, emissive: 0x87ceeb, emissiveIntensity: 0.3 });
                const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                window1.position.set(i, 2, 8.5); group.add(window1);
                const window2 = window1.clone(); window2.position.z = -8.5; group.add(window2);
            }

            const redLight = new THREE.PointLight(0xff0000, 1, 50); redLight.position.set(-5, -5, -45); group.add(redLight);
            const greenLight = new THREE.PointLight(0x00ff00, 1, 50); greenLight.position.set(-5, -5, 45); group.add(greenLight);
            const strobeLight = new THREE.PointLight(0xffffff, 2, 100); strobeLight.position.set(0, 15, 0); group.add(strobeLight);
            this.strobeLight = strobeLight;

            this.mesh = group;
            this.mesh.position.set(-800, 400, -600);
            this.velocity = new THREE.Vector3(2, 0, 1.5);
            this.mesh.rotation.y = Math.atan2(1.5, 2);
            scene.add(this.mesh);
        }
        update() {
            this.mesh.position.add(this.velocity);
            if(this.mesh.position.x > 1000) {
                this.mesh.position.x = -1000;
                this.mesh.position.z = -600 + Math.random() * 1200;
                this.mesh.position.y = 350 + Math.random() * 150;
            }
            this.mesh.rotation.z = Math.sin(Date.now() * 0.0005) * 0.1;
            this.mesh.position.y += Math.sin(Date.now() * 0.0003) * 0.2;
            this.strobeLight.intensity = Math.sin(Date.now() * 0.01) > 0 ? 2 : 0;
        }
    }
    let boeing = null;

    // Buildings
    const buildings = [];
    function createBuildings() {
        const buildingColors = [0x2c3e50, 0x34495e, 0x2c3853, 0x273c55, 0x1e2936];
        for(let x = -500; x <= 500; x += 150) {
            for(let z = -500; z <= 500; z += 150) {
                if(Math.abs(x) < 150 && Math.abs(z) < 150) continue;
                const width = 40 + Math.random() * 40;
                const depth = 40 + Math.random() * 40;
                const height = 80 + Math.random() * 200;

                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    new THREE.MeshPhongMaterial({ color: buildingColors[Math.floor(Math.random()*buildingColors.length)], emissive: 0x000000, emissiveIntensity: 0.1 })
                );
                building.position.set(x + (Math.random() - 0.5) * 30, height/2, z + (Math.random() - 0.5) * 30);
                building.castShadow = true; building.receiveShadow = true;
                scene.add(building); buildings.push(building);

                const windowRows = Math.floor(height / 15);
                const windowCols = Math.floor(width / 10);
                for(let row = 0; row < windowRows; row++) {
                    for(let col = 0; col < windowCols; col++) {
                        if(Math.random() > 0.7) {
                            const window = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 1), new THREE.MeshBasicMaterial({ color: 0xffeb3b, emissive: 0xffeb3b }));
                            window.position.set(building.position.x + (col - windowCols/2) * 10, row * 15 + 10, building.position.z + depth/2 + 0.5);
                            scene.add(window);
                            const window2 = window.clone(); window2.position.z = building.position.z - depth/2 - 0.5; scene.add(window2);
                        }
                    }
                }

                const rooftop = new THREE.Mesh(new THREE.BoxGeometry(width * 0.8, 5, depth * 0.8), new THREE.MeshPhongMaterial({ color: 0x1a1a1a }));
                rooftop.position.set(building.position.x, height + 2.5, building.position.z);
                scene.add(rooftop);

                if(Math.random() > 0.5) {
                    const antenna = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 30), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
                    antenna.position.set(building.position.x + (Math.random() - 0.5) * width/2, height + 15, building.position.z + (Math.random() - 0.5) * depth/2);
                    scene.add(antenna);
                    const light = new THREE.PointLight(0xff0000, 0.5, 30);
                    light.position.copy(antenna.position); light.position.y += 15; scene.add(light);
                }
            }
        }

        // Street lights
        for(let i = -400; i <= 400; i += 200) {
            for(let j = -400; j <= 400; j += 200) {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 40), new THREE.MeshPhongMaterial({ color: 0x444444 }));
                pole.position.set(i, 20, j); scene.add(pole);
                const streetLight = new THREE.PointLight(0xffa500, 0.8, 100);
                streetLight.position.set(i, 40, j); scene.add(streetLight);
            }
        }
    }
    createBuildings();

    // Arena boundaries (invisible walls)
    for(let i = 0; i < 4; i++) {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(i < 2 ? 1200 : 10, 500, i < 2 ? 10 : 1200),
            new THREE.MeshPhongMaterial({ visible: false })
        );
        wall.position.set(i === 1 ? 600 : i === 3 ? -600 : 0, 250, i === 0 ? 600 : i === 2 ? -600 : 0);
        scene.add(wall);
    }

    // Drone AI
    class DroneAI {
        constructor(team, position) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.OctahedronGeometry(10, 0),
                new THREE.MeshPhongMaterial({
                    color: team === 'blue' ? 0x4facfe : 0xff6b6b,
                    emissive: team === 'blue' ? 0x0066cc : 0xcc0000,
                    emissiveIntensity: 0.5
                })
            );
            group.add(body);
            for(let i = 0; i < 4; i++) {
                const angle = (i/4) * Math.PI * 2;
                const rotor = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 1, 3),
                    new THREE.MeshBasicMaterial({ color: 0x1a1a1a, transparent: true, opacity: 0.8 })
                );
                rotor.position.x = Math.cos(angle) * 12;
                rotor.position.z = Math.sin(angle) * 12;
                rotor.position.y = 5;
                group.add(rotor);
            }
            const light = new THREE.PointLight(team === 'blue' ? 0x4facfe : 0xff6b6b, 0.5, 50);
            group.add(light);

            this.mesh = group; this.mesh.position.copy(position);
            this.team = team; this.health = 100;
            this.velocity = new THREE.Vector3();
            this.target = null; this.lastShot = 0;
            this.state = 'hunting'; this.dodgeTimer = 0;
            this.accuracy = 0.7 + Math.random() * 0.3;
            this.aggressiveness = 0.5 + Math.random() * 0.5;
            this.reactionTime = 100 + Math.random() * 200;
            scene.add(this.mesh);
        }

        update() {
            this.mesh.children.forEach((child, i) => { if(i > 0 && i < 5) child.rotation.y += 0.4 * gameSpeed; });
            this.findTarget();
            this.movement();
            this.combat();
            this.mesh.position.add(this.velocity.clone().multiplyScalar(gameSpeed));

            const bound = 580;
            ['x', 'z'].forEach(axis => {
                if(Math.abs(this.mesh.position[axis]) > bound) {
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * bound;
                    this.velocity[axis] *= -0.5;
                }
            });

            const minHeight = 50, maxHeight = 250;
            const targetHeight = minHeight + Math.sin(Date.now() * 0.001 + this.mesh.id) * 30 + Math.random() * (maxHeight - minHeight - 60);
            this.mesh.position.y += (targetHeight - this.mesh.position.y) * 0.05;
            this.mesh.position.y = Math.max(minHeight, Math.min(maxHeight, this.mesh.position.y));
        }

        findTarget() {
            let minDist = Infinity, newTarget = null;
            drones.forEach(d => {
                if(d.team !== this.team && d.health > 0) {
                    const dist = this.mesh.position.distanceTo(d.mesh.position);
                    if(dist < minDist) { minDist = dist; newTarget = d; }
                }
            });
            this.target = newTarget;
            this.state = this.target ? (minDist < 200 ? 'combat' : 'pursuit') : 'patrol';
        }

        movement() {
            const speed = 3;
            switch(this.state) {
                case 'combat':
                    if(this.target) {
                        const angle = Date.now() * 0.002;
                        const radius = 150;
                        const targetPos = new THREE.Vector3(
                            this.target.mesh.position.x + Math.cos(angle) * radius,
                            this.mesh.position.y,
                            this.target.mesh.position.z + Math.sin(angle) * radius
                        );
                        const dir = targetPos.clone().sub(this.mesh.position).normalize();
                        this.velocity.lerp(dir.multiplyScalar(speed), 0.1);
                        this.dodgeBullets();
                        this.avoidBuildings();
                    }
                    break;
                case 'pursuit':
                    if(this.target) {
                        const dir = this.target.mesh.position.clone().sub(this.mesh.position).normalize();
                        this.velocity.lerp(dir.multiplyScalar(speed * 1.5), 0.05);
                        this.avoidBuildings();
                    }
                    break;
                case 'patrol':
                    if(Math.random() < 0.02) {
                        this.velocity.x += (Math.random() - 0.5) * 2;
                        this.velocity.z += (Math.random() - 0.5) * 2;
                    }
                    this.velocity.multiplyScalar(0.95);
                    this.avoidBuildings();
                    break;
            }
            if(this.velocity.length() > speed * 2) {
                this.velocity.normalize().multiplyScalar(speed * 2);
            }
        }

        avoidBuildings() {
            buildings.forEach(building => {
                const dist = this.mesh.position.distanceTo(building.position);
                if(dist < 80) {
                    const avoidDir = this.mesh.position.clone().sub(building.position).normalize();
                    this.velocity.add(avoidDir.multiplyScalar(5));
                    if(this.mesh.position.y < building.geometry.parameters.height + 20) this.velocity.y = 3;
                }
            });
        }

        dodgeBullets() {
            bullets.forEach(b => {
                if(b.team !== this.team) {
                    const dist = this.mesh.position.distanceTo(b.position);
                    if(dist < 100) {
                        const dodge = this.mesh.position.clone().sub(b.position).normalize();
                        this.velocity.add(dodge.multiplyScalar(5));
                    }
                }
            });
        }

        combat() {
            if(!this.target || this.target.health <= 0) return;
            const dist = this.mesh.position.distanceTo(this.target.mesh.position);
            const now = Date.now();
            if(dist < 300 && now - this.lastShot > this.reactionTime) {
                const timeToHit = dist / 15;
                const predictedPos = this.target.mesh.position.clone().add(this.target.velocity.clone().multiplyScalar(timeToHit));
                if(Math.random() < this.accuracy * this.aggressiveness) {
                    this.shoot(predictedPos);
                    this.lastShot = now;
                }
            }
        }

        shoot(targetPos) {
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(2),
                new THREE.MeshBasicMaterial({ color: this.team === 'blue' ? 0x00f2fe : 0xff6b6b, emissive: this.team === 'blue' ? 0x00f2fe : 0xff6b6b })
            );
            bullet.position.copy(this.mesh.position);
            bullet.velocity = targetPos.clone().sub(this.mesh.position).normalize().multiplyScalar(15);
            bullet.team = this.team; bullet.owner = this; bullet.life = 100;
            scene.add(bullet); bullets.push(bullet); stats.shots++;
        }

        takeDamage(damage) {
            this.health -= damage;
            for(let i = 0; i < 5; i++) {
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshBasicMaterial({ color: this.team === 'blue' ? 0x4facfe : 0xff6b6b })
                );
                p.position.copy(this.mesh.position);
                p.velocity = new THREE.Vector3((Math.random()-0.5)*5, Math.random()*5, (Math.random()-0.5)*5);
                p.life = 20; scene.add(p); particles.push(p);
            }
            if(this.health <= 0) { this.explode(); return true; }
            return false;
        }

        explode() {
            for(let i = 0; i < 30; i++) {
                const p = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(3),
                    new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00 })
                );
                p.position.copy(this.mesh.position);
                p.velocity = new THREE.Vector3((Math.random()-0.5)*15, Math.random()*15, (Math.random()-0.5)*15);
                p.life = 40; scene.add(p); particles.push(p);
            }
            scene.remove(this.mesh);
            stats.kills++;
        }
    }

    // Battle control
    function startBattle(teamSize) {
        drones.forEach(d => scene.remove(d.mesh));
        bullets.forEach(b => scene.remove(b));
        particles.forEach(p => scene.remove(p));
        drones = []; bullets = []; particles = [];

        stats = { time: 0, shots: 0, kills: 0 };
        battleStart = Date.now();
        document.getElementById('winner').style.display = 'none';

        if(!boeing) boeing = new Boeing747();

        for(let i = 0; i < teamSize; i++) {
            drones.push(new DroneAI('blue', new THREE.Vector3(-400 + Math.random()*100, 100 + Math.random()*100, (Math.random()-0.5)*400)));
            drones.push(new DroneAI('red',  new THREE.Vector3( 400 - Math.random()*100, 100 + Math.random()*100, (Math.random()-0.5)*400)));
        }
    }

    function toggleCamera() { cameraMode = (cameraMode + 1) % 3; }
    function toggleSpeed() {
        gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 4 : 1;
        document.getElementById('speed').textContent = gameSpeed;
    }

    // Main loop
    function animate() {
        requestAnimationFrame(animate);

        // ‚òÖ‚òÖ update ciel √©toil√© (scintillement + rotation lente)
        const t = Date.now() * 0.001;
        starLayers.forEach(layer => {
            layer.points.rotation.y += layer.rotSpeed * gameSpeed;
            const twinkle = 0.8 + 0.2 * Math.sin(t * 0.9 + layer.phase);
            layer.material.opacity = twinkle;
        });

        if(boeing) boeing.update();

        drones = drones.filter(d => { if(d.health > 0) { d.update(); return true; } return false; });

        bullets = bullets.filter(b => {
            b.position.add(b.velocity.clone().multiplyScalar(gameSpeed));
            b.life -= gameSpeed;
            drones.forEach((d, i) => {
                if(d.team !== b.team && b.position.distanceTo(d.mesh.position) < 15) {
                    if(d.takeDamage(25)) drones.splice(i, 1);
                    scene.remove(b); b.life = 0;
                }
            });
            if(b.life <= 0) { scene.remove(b); return false; }
            return true;
        });

        particles = particles.filter(p => {
            p.position.add(p.velocity.clone().multiplyScalar(gameSpeed));
            p.velocity.y -= 0.3 * gameSpeed;
            p.life -= gameSpeed;
            if(p.material && 'opacity' in p.material) p.material.opacity = p.life / 40;
            p.rotation.x += 0.1; p.rotation.y += 0.1;
            if(p.life <= 0) { scene.remove(p); return false; }
            return true;
        });

        const time = Date.now() * 0.0005;
        switch(cameraMode) {
            case 0:
                camera.position.x = Math.cos(time) * 600;
                camera.position.z = Math.sin(time) * 600;
                camera.position.y = 300;
                camera.lookAt(0, 0, 0);
                break;
            case 1:
                camera.position.set(0, 800, 0);
                camera.lookAt(0, 0, 0);
                break;
            case 2:
                if(drones.length > 0) {
                    const drone = drones[Math.floor(Math.random() * drones.length)];
                    camera.position.lerp(drone.mesh.position.clone().add(new THREE.Vector3(100, 100, 100)), 0.02);
                    camera.lookAt(drone.mesh.position);
                }
                break;
        }

        if(battleStart) stats.time = Math.floor((Date.now() - battleStart) / 1000);
        const blueCount = drones.filter(d => d.team === 'blue').length;
        const redCount  = drones.filter(d => d.team === 'red').length;

        document.getElementById('time').textContent = stats.time;
        document.getElementById('shots').textContent = stats.shots;
        document.getElementById('kills').textContent = stats.kills;
        document.getElementById('blue-count').textContent = blueCount;
        document.getElementById('red-count').textContent = redCount;

        if(drones.length > 0 && (blueCount === 0 || redCount === 0)) {
            const winner = document.getElementById('winner');
            winner.textContent = blueCount > 0 ? 'üîµ VICTOIRE BLEUE!' : 'üî¥ VICTOIRE ROUGE!';
            winner.style.color = blueCount > 0 ? '#4facfe' : '#ff6b6b';
            winner.style.display = 'block';
        }

        renderer.render(scene, camera);
    }

    // Start with 5v5
    startBattle(5);
    animate();

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
</script>
</body>
</html>
