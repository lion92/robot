<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille d'Amour 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .hud, .leaderboard {
            position: fixed;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .hud { top: 20px; left: 20px; }
        .hud h4 { color: #fff; margin-bottom: 15px; font-weight: 600; font-size: 16px; }
        .hud div { font-size: 14px; margin: 8px 0; font-weight: 300; opacity: 0.9; }

        .leaderboard { top: 20px; right: 20px; min-width: 220px; }
        .leaderboard h4 { color: #fff; margin-bottom: 15px; font-weight: 600; font-size: 16px; }
        .leaderboard div { font-size: 12px; margin: 6px 0; font-weight: 300; opacity: 0.9; }

        .timer {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 64px; font-weight: 700; text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            z-index: 200; display: none;
        }

        .controls {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 150;
        }

        .btn {
            padding: 15px 30px; background: linear-gradient(45deg, #667eea, #764ba2);
            border: none; color: white; font-family: inherit; font-weight: 600;
            border-radius: 50px; cursor: pointer; transition: all 0.3s ease;
            font-size: 14px; box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-3px); box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
            background: linear-gradient(45deg, #764ba2, #667eea);
        }

        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .birth-effect {
            position: fixed;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            z-index: 250;
            animation: birthPop 2s ease-out forwards;
        }

        @keyframes birthPop {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 0; }
        }
    </style>
</head>
<body>
<div id="gameContainer"></div>

<div class="hud">
    <h4>ðŸŒ³ BATAILLE AU PARC</h4>
    <div>Bataille #<span id="battleNumber">1</span></div>
    <div>Participants: <span id="aliveRobots">16</span></div>
    <div>Zone: <span id="zoneSize">100</span>%</div>
    <div>Total CÅ“urs: <span id="totalKills">0</span></div>
    <div>Naissances: <span id="totalBirths">0</span></div>
    <div>Record: <span id="recordKills">0</span></div>
</div>

<div class="timer" id="timer">3:00</div>

<div class="leaderboard">
    <h4>ðŸ’– CLASSEMENT</h4>
    <div id="leaderboardContent"></div>
</div>

<div class="controls">
    <button class="btn" id="startBtn">ðŸŒ¸ DÃ‰MARRER BATAILLE</button>
    <button class="btn" id="resetBtn">ðŸ”„ RESET</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Configuration
    const CONFIG = {
        ROBOTS: 16, BATTLE_TIME: 180, ROBOT_HP: 100, LOVE: 15,
        ROBOT_SPEED: 0.2, LOVE_COOLDOWN: 800, ARENA_SIZE: 80, DETECTION_RANGE: 35,
        ZONE_SHRINK_RATE: 0.05, AUTO_RESTART: true, RESTART_DELAY: 5000,
        REPRODUCTION_THRESHOLD: 4, MAX_ROBOTS: 50
    };

    const ROBOT_TYPES = [
        { name: 'Classique', bodyShape: 'sphere', headShape: 'sphere', colors: ['#ff6b6b', '#4ecdc4'] },
        { name: 'Cubique', bodyShape: 'cube', headShape: 'cube', colors: ['#45b7d1', '#96ceb4'] },
        { name: 'Cylindrique', bodyShape: 'cylinder', headShape: 'sphere', colors: ['#feca57', '#ff9ff3'] },
        { name: 'Pyramidal', bodyShape: 'cone', headShape: 'sphere', colors: ['#54a0ff', '#5f27cd'] },
        { name: 'OctaÃ¨dre', bodyShape: 'octahedron', headShape: 'octahedron', colors: ['#00d2d3', '#ff9f43'] },
        { name: 'Capsule', bodyShape: 'capsule', headShape: 'sphere', colors: ['#10ac84', '#ee5a24'] },
        { name: 'Cristal', bodyShape: 'diamond', headShape: 'diamond', colors: ['#a55eea', '#26de81'] },
        { name: 'Ovale', bodyShape: 'ellipsoid', headShape: 'ellipsoid', colors: ['#fd79a8', '#fdcb6e'] }
    ];

    const NAMES = ['Amour', 'Tendresse', 'CÃ¢lin', 'Bisou', 'Sourire', 'Joie', 'Bonheur', 'Rire', 'Espoir', 'RÃªve', 'Magie', 'Charme', 'Douceur', 'Passion', 'Caresse', 'Ã‰motion'];
    const CHILD_SUFFIXES = [' Jr', ' II', ' Mini', ' BÃ©bÃ©', ' Petit', ' Doux', ' Mignon', ' Adorable'];

    // Variables globales
    let gameState = 'idle', battleTimer = CONFIG.BATTLE_TIME, battleNumber = 1;
    let currentArenaSize = CONFIG.ARENA_SIZE, robots = [], projectiles = [];
    let stats = { totalShots: 0, totalKills: 0, totalBirths: 0, startTime: 0 };
    let overallStats = { totalBattles: 0, recordKills: 0, recordHolder: null };
    let scene, camera, renderer, robotMeshes = [], projectileMeshes = [];
    let cats = [], birds = [], catMeshes = [], birdMeshes = [];
    let nextRobotId = 0;

    // Initialisation Three.js
    function initThreeJS() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 80, 200);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 60, 80);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87ceeb);
        document.getElementById('gameContainer').appendChild(renderer.domElement);

        // Ã‰clairage naturel du parc
        scene.add(new THREE.AmbientLight(0x404040, 0.8));

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xfff8dc, 0.4);
        fillLight.position.set(-30, 40, -30);
        scene.add(fillLight);

        // Sol du parc
        const floor = new THREE.Mesh(
            new THREE.CircleGeometry(CONFIG.ARENA_SIZE, 64),
            new THREE.MeshLambertMaterial({ color: 0x4a7c59, transparent: true, opacity: 0.9 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Chemins
        const path = new THREE.Mesh(
            new THREE.RingGeometry(15, 20, 64),
            new THREE.MeshLambertMaterial({ color: 0x8d8d8d, transparent: true, opacity: 0.8 })
        );
        path.rotation.x = -Math.PI / 2;
        path.position.y = 0.01;
        scene.add(path);

        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const smallPath = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 25),
                new THREE.MeshLambertMaterial({ color: 0x8d8d8d })
            );
            smallPath.position.set(Math.cos(angle) * 30, 0.05, Math.sin(angle) * 30);
            smallPath.rotation.y = angle;
            scene.add(smallPath);
        }

        setupControls();
        window.addEventListener('resize', onWindowResize);
    }

    function setupControls() {
        let mouseDown = false, angle = 0, height = 60;

        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);
        document.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                angle += e.movementX * 0.01;
                height = Math.max(30, Math.min(120, height - e.movementY * 0.5));
                updateCamera();
            }
        });
        document.addEventListener('wheel', (e) => {
            height = Math.max(25, Math.min(150, height + e.deltaY * 0.1));
            updateCamera();
        });

        function updateCamera() {
            const distance = 100;
            camera.position.set(Math.sin(angle) * distance, height, Math.cos(angle) * distance);
            camera.lookAt(0, 0, 0);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Initialisation du jeu
    function initGame() {
        robots = []; projectiles = []; cats = []; birds = [];
        currentArenaSize = CONFIG.ARENA_SIZE;
        stats = { totalShots: 0, totalKills: 0, totalBirths: 0, startTime: Date.now() };
        nextRobotId = 0;
        clearMeshes();
        createRobots();
        createParkElements();
        updateArenaVisuals();
        updateUI();

        setTimeout(() => {
            createCats();
            createBirds();
        }, 100);
    }

    function clearMeshes() {
        [...robotMeshes, ...projectileMeshes, ...catMeshes, ...birdMeshes].forEach(mesh => scene.remove(mesh));
        robotMeshes = []; projectileMeshes = []; catMeshes = []; birdMeshes = [];
    }

    function createRobots() {
        for (let i = 0; i < CONFIG.ROBOTS; i++) {
            createRobot(i);
        }
    }

    function createRobot(index, parent = null) {
        const angle = Math.random() * Math.PI * 2;
        const radius = CONFIG.ARENA_SIZE * 0.6 + Math.random() * CONFIG.ARENA_SIZE * 0.2;

        const robotType = parent ? parent.robotType : ROBOT_TYPES[index % ROBOT_TYPES.length];

        const robot = {
            id: nextRobotId++,
            name: parent ? parent.name + CHILD_SUFFIXES[Math.floor(Math.random() * CHILD_SUFFIXES.length)] : NAMES[index % NAMES.length],
            color: parent ? parent.color : robotType.colors[Math.floor(Math.random() * robotType.colors.length)],
            robotType: robotType,
            x: parent ? parent.x + (Math.random() - 0.5) * 4 : Math.cos(angle) * radius,
            y: 1.5,
            z: parent ? parent.z + (Math.random() - 0.5) * 4 : Math.sin(angle) * radius,
            vx: 0, vz: 0, health: CONFIG.ROBOT_HP, maxHealth: CONFIG.ROBOT_HP,
            hearts: 0, loves: 0, alive: true, size: parent ? 2.0 : 2.5,
            lastLove: 0, target: null, friends: [], happiness: 60,
            kindness: parent ? Math.min(90, parent.kindness + (Math.random() - 0.5) * 20) : 50 + Math.random() * 40,
            charm: parent ? Math.min(80, parent.charm + (Math.random() - 0.5) * 15) : 40 + Math.random() * 35,
            weapon: { type: parent ? parent.weapon.type : ['romantic', 'friendship', 'caring'][Math.floor(Math.random() * 3)] },
            parent: parent ? parent.id : null,
            generation: parent ? parent.generation + 1 : 0,
            hasReproduced: false
        };

        robots.push(robot);
        createRobotMesh(robot);

        if (parent) {
            showBirthEffect(robot);
            stats.totalBirths++;
        }

        return robot;
    }

    function showBirthEffect(robot) {
        const effect = document.createElement('div');
        effect.className = 'birth-effect';
        effect.textContent = 'ðŸ‘¶ðŸ’•';
        effect.style.color = robot.color;

        const vector = new THREE.Vector3(robot.x, robot.y + 2, robot.z);
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

        effect.style.left = x + 'px';
        effect.style.top = y + 'px';

        document.body.appendChild(effect);
        setTimeout(() => document.body.removeChild(effect), 2000);
    }

    function createRobotMesh(robot) {
        const group = new THREE.Group();
        const color = new THREE.Color(robot.color);
        const scale = robot.generation > 0 ? 1.2 : 1.5;
        const type = robot.robotType;

        // Corps selon le type de robot
        let bodyGeometry;
        switch (type.bodyShape) {
            case 'cube':
                bodyGeometry = new THREE.BoxGeometry(2 * scale, 2 * scale, 2 * scale);
                break;
            case 'cylinder':
                bodyGeometry = new THREE.CylinderGeometry(1 * scale, 1 * scale, 2.5 * scale, 16);
                break;
            case 'cone':
                bodyGeometry = new THREE.ConeGeometry(1.2 * scale, 2.5 * scale, 12);
                break;
            case 'octahedron':
                bodyGeometry = new THREE.OctahedronGeometry(1.3 * scale);
                break;
            case 'capsule':
                bodyGeometry = new THREE.CapsuleGeometry(0.8 * scale, 1.5 * scale, 4, 8);
                break;
            case 'diamond':
                bodyGeometry = new THREE.OctahedronGeometry(1.2 * scale);
                break;
            case 'ellipsoid':
                bodyGeometry = new THREE.SphereGeometry(1.2 * scale, 16, 12);
                break;
            default:
                bodyGeometry = new THREE.SphereGeometry(1.2 * scale, 16, 16);
        }

        const body = new THREE.Mesh(bodyGeometry, new THREE.MeshLambertMaterial({ color: color }));
        body.position.y = 2.2 * scale;
        body.castShadow = true;

        if (type.bodyShape === 'diamond' || type.bodyShape === 'octahedron') {
            body.material.transparent = true;
            body.material.opacity = 0.8;
            body.material.emissive = color.clone().multiplyScalar(0.2);
        }
        if (type.bodyShape === 'ellipsoid') {
            body.scale.set(1, 0.7, 1.3);
        }

        group.add(body);

        // TÃªte
        let headGeometry;
        switch (type.headShape) {
            case 'cube':
                headGeometry = new THREE.BoxGeometry(1.2 * scale, 1.2 * scale, 1.2 * scale);
                break;
            case 'octahedron':
                headGeometry = new THREE.OctahedronGeometry(0.6 * scale);
                break;
            case 'diamond':
                headGeometry = new THREE.OctahedronGeometry(0.65 * scale);
                break;
            case 'ellipsoid':
                headGeometry = new THREE.SphereGeometry(0.8 * scale, 12, 10);
                break;
            default:
                headGeometry = new THREE.SphereGeometry(0.8 * scale, 16, 16);
        }

        const head = new THREE.Mesh(headGeometry, new THREE.MeshLambertMaterial({
            color: color.clone().multiplyScalar(1.2)
        }));
        head.position.y = 3.8 * scale;
        head.castShadow = true;

        if (type.headShape === 'diamond') {
            head.material.transparent = true;
            head.material.opacity = 0.9;
            head.material.emissive = color.clone().multiplyScalar(0.3);
            head.rotation.y = Math.PI / 4;
        }
        if (type.headShape === 'ellipsoid') {
            head.scale.set(1.2, 0.8, 1);
        }

        group.add(head);

        // Yeux
        const eyeIntensity = robot.generation > 0 ? 1.2 : 0.8;
        const eyeColor = type.bodyShape === 'diamond' ? 0xffffff : 0x4ecdc4;
        const eyeSize = type.headShape === 'cube' ? 0.08 : 0.12;

        [-0.25, 0.25].forEach((x, index) => {
            const eye = new THREE.Mesh(
                new THREE.SphereGeometry(eyeSize * scale, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: eyeColor,
                    emissive: eyeColor,
                    emissiveIntensity: eyeIntensity
                })
            );

            eye.position.set(x * scale, 3.9 * scale, 0.6 * scale);

            if (type.bodyShape === 'diamond') {
                eye.material.emissiveIntensity = eyeIntensity + Math.sin(Date.now() * 0.01 + index) * 0.3;
            }

            group.add(eye);
        });

        // Bras
        [-0.9, 0.9].forEach(x => {
            let armGeometry;
            switch (type.bodyShape) {
                case 'cube':
                    armGeometry = new THREE.BoxGeometry(0.3 * scale, 1.5 * scale, 0.3 * scale);
                    break;
                case 'diamond':
                case 'octahedron':
                    armGeometry = new THREE.OctahedronGeometry(0.15 * scale);
                    break;
                default:
                    armGeometry = new THREE.CylinderGeometry(0.22 * scale, 0.22 * scale, 1.5 * scale, 8);
            }

            const arm = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: color }));
            arm.position.set(x * scale, 2.7 * scale, 0);

            if (type.bodyShape === 'diamond' || type.bodyShape === 'octahedron') {
                arm.scale.set(1, 3, 1);
                arm.material.transparent = true;
                arm.material.opacity = 0.7;
            }

            arm.castShadow = true;
            group.add(arm);
        });

        // Jambes
        [-0.45, 0.45].forEach(x => {
            let legGeometry;
            switch (type.bodyShape) {
                case 'cube':
                    legGeometry = new THREE.BoxGeometry(0.25 * scale, 1.8 * scale, 0.25 * scale);
                    break;
                case 'diamond':
                    legGeometry = new THREE.OctahedronGeometry(0.12 * scale);
                    break;
                default:
                    legGeometry = new THREE.CylinderGeometry(0.18 * scale, 0.18 * scale, 1.8 * scale, 8);
            }

            const leg = new THREE.Mesh(legGeometry, new THREE.MeshLambertMaterial({ color: color }));
            leg.position.set(x * scale, 0.9 * scale, 0);

            if (type.bodyShape === 'diamond') {
                leg.scale.set(1, 4, 1);
                leg.material.transparent = true;
                leg.material.opacity = 0.7;
            }

            leg.castShadow = true;
            group.add(leg);
        });

        // Accessoires spÃ©ciaux
        if (type.bodyShape === 'cone') {
            const antenna = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 0.8 * scale, 6),
                new THREE.MeshLambertMaterial({ color: 0xffff00 })
            );
            antenna.position.set(0, 4.6 * scale, 0);

            const antennaTip = new THREE.Mesh(
                new THREE.SphereGeometry(0.1 * scale, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 })
            );
            antennaTip.position.set(0, 5 * scale, 0);

            group.add(antenna);
            group.add(antennaTip);
        }

        if (type.bodyShape === 'cylinder') {
            const propeller = new THREE.Mesh(
                new THREE.BoxGeometry(1.5 * scale, 0.1 * scale, 0.2 * scale),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            propeller.position.set(0, 4.5 * scale, 0);
            group.add(propeller);
        }

        group.position.set(robot.x, 0, robot.z);
        robotMeshes.push(group);
        scene.add(group);
    }

    function createParkElements() {
        // Fontaine centrale
        const fountain = new THREE.Group();
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(3, 4, 1, 16),
            new THREE.MeshLambertMaterial({ color: 0x9da0a4 })
        );
        base.position.y = 0.5;
        base.castShadow = true;
        fountain.add(base);

        const water = new THREE.Mesh(
            new THREE.CylinderGeometry(2.8, 2.8, 0.3, 16),
            new THREE.MeshLambertMaterial({ color: 0x4ecdc4, transparent: true, opacity: 0.7 })
        );
        water.position.y = 0.85;
        fountain.add(water);

        const column = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.4, 2, 8),
            new THREE.MeshLambertMaterial({ color: 0x9da0a4 })
        );
        column.position.y = 2;
        column.castShadow = true;
        fountain.add(column);

        scene.add(fountain);

        // Arbres Ã  chats
        const catTreePositions = [
            {x: 30, z: 30}, {x: -30, z: 30}, {x: 30, z: -30}, {x: -30, z: -30},
            {x: 50, z: 0}, {x: -50, z: 0}, {x: 0, z: 50}, {x: 0, z: -50},
            {x: 40, z: 20}, {x: -40, z: -20}
        ];

        catTreePositions.forEach(pos => {
            const catTree = new THREE.Group();

            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1.2, 3, 8),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            catTree.add(trunk);

            const platforms = [
                { y: 2.5, radius: 1.5 },
                { y: 4, radius: 1.2 },
                { y: 5.5, radius: 1 }
            ];

            platforms.forEach(platform => {
                const platformMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(platform.radius, platform.radius, 0.3, 16),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                platformMesh.position.y = platform.y;
                platformMesh.castShadow = true;
                catTree.add(platformMesh);
            });

            catTree.position.set(pos.x, 0, pos.z);
            scene.add(catTree);
        });

        // Arbres normaux
        const treeRings = [
            { radius: 35, count: 16 },
            { radius: 55, count: 20 },
            { radius: 70, count: 24 }
        ];

        treeRings.forEach(ring => {
            for (let i = 0; i < ring.count; i++) {
                const angle = (i / ring.count) * Math.PI * 2;
                const x = Math.cos(angle) * ring.radius + (Math.random() - 0.5) * 8;
                const z = Math.sin(angle) * ring.radius + (Math.random() - 0.5) * 8;

                const tree = new THREE.Group();