
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario IA - Ultimate Edition</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        h1 {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5em;
            margin: 15px 0;
            text-align: center;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        canvas {
            border: 3px solid #4ecdc4;
            background: linear-gradient(180deg, #000011, #000000);
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.4), inset 0 0 50px rgba(0, 0, 50, 0.3);
            margin: 20px 0;
            border-radius: 10px;
            position: relative;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 850px;
            margin: 15px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
            transition: all 0.3s ease;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1, #ff6b6b);
            border-radius: 12px;
            padding: 2px;
            z-index: -1;
            opacity: 0.7;
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.3);
        }

        .stat-card h3 {
            margin: 0 0 8px 0;
            font-size: 0.95em;
            color: #4ecdc4;
            font-weight: bold;
        }

        .stat-value {
            font-size: 22px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 10px currentColor;
        }

        .info-panel {
            margin: 20px 0;
            padding: 25px;
            background: linear-gradient(135deg, #2d3748, #4a5568, #2d3748);
            border-radius: 15px;
            text-align: center;
            min-width: 650px;
            border: 3px solid transparent;
            background-clip: padding-box;
            position: relative;
        }

        .info-panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700);
            background-size: 400% 400%;
            border-radius: 15px;
            padding: 3px;
            z-index: -1;
            animation: gradientShift 4s ease-in-out infinite;
        }

        .progress-bar {
            width: 100%;
            height: 18px;
            background: #1a1a2e;
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #ffd700);
            background-size: 200% 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
            animation: progressShine 2s linear infinite;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        @keyframes progressShine {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        button {
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        button:hover::before { left: 100%; }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        button:disabled { opacity: 0.7; cursor: not-allowed; }

        .divine { color: #ffd700; text-shadow: 0 0 15px currentColor; }
        .legendary { color: #ff6b6b; text-shadow: 0 0 15px currentColor; }
        .transcendent { color: #9d4edd; text-shadow: 0 0 15px currentColor; }
        .play-btn { background: linear-gradient(45deg, #28a745, #20c997) !important; }

        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 2s ease-out forwards;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0px); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .screen-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            z-index: 999;
            opacity: 0;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
<div class="screen-flash" id="screenFlash"></div>

<h1>‚ö° Mario IA - Ultimate Edition üî•</h1>

<div class="info-panel">
    <h3 class="legendary">IA TRANSCENDANTE | Mode Ultime Actif | QI: 15000+</h3>
    <div class="progress-bar">
        <div class="progress-fill" id="progressBar" style="width: 100%"></div>
    </div>
    <p id="statusText">IA ULTIME pr√™te √† dominer | Esquive: 99.99% | Combat: 99% | 5000 PARTIES D'ENTRA√éNEMENT</p>
</div>

<canvas id="gameCanvas" width="800" height="400"></canvas>

<div class="stats">
    <div class="stat-card">
        <h3>üèÜ Score</h3>
        <div class="stat-value" id="currentScore">0</div>
        <p>Meilleur: <span id="bestScore">0</span></p>
    </div>
    <div class="stat-card">
        <h3>üìä Parties</h3>
        <div class="stat-value" id="gamesPlayed">0</div>
        <p>Victoires: <span id="wins">0</span></p>
    </div>
    <div class="stat-card">
        <h3>üß† QI IA</h3>
        <div class="stat-value divine" id="aiIQ">1000</div>
        <p>√âvol: +<span id="iqGrowth">0</span></p>
    </div>
    <div class="stat-card">
        <h3>‚ö° Survie</h3>
        <div class="stat-value legendary" id="survivalRate">0%</div>
        <p>Moy: <span id="avgSurvival">0s</span></p>
    </div>
</div>

<div class="stats">
    <div class="stat-card">
        <h3>üèÉ √âvasion</h3>
        <div class="stat-value" id="evasionSkill">99%</div>
    </div>
    <div class="stat-card">
        <h3>üåü Matrix</h3>
        <div class="stat-value" id="matrixMode">95%</div>
    </div>
    <div class="stat-card">
        <h3>üëÅÔ∏è Divin</h3>
        <div class="stat-value divine" id="godMode">90%</div>
    </div>
    <div class="stat-card">
        <h3>üî• Transcendant</h3>
        <div class="stat-value transcendent" id="transcendence">85%</div>
    </div>
</div>

<div style="text-align: center; margin: 20px;">
    <button id="playBtn" onclick="startRealGame()" class="play-btn">üéÆ JOUER AVEC IA ULTIME</button>
    <button id="simulateBtn" onclick="startSimulation()" style="display:none;">‚ö° SIMULER 5000 PARTIES</button>
    <button onclick="location.reload()">üîÑ Reset</button>
    <p style="color: #4ecdc4; margin-top: 15px;">IA Ultra-Entra√Æn√©e | 5000+ parties | Mode Transcendant Ultime | QI: 15000+</p>
</div>

<script>
    // Configuration am√©lior√©e - ENTRA√éNEMENT MASSIF
    const config = { trainingTarget: 5000, batchSize: 100 };

    // Syst√®me de particules
    class Particle {
        constructor(x, y, color, type = 'spark') {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8;
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.01;
            this.color = color;
            this.size = Math.random() * 4 + 2;
            this.type = type;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.1; // Gravit√©
            this.life -= this.decay;
            this.vx *= 0.98;
            this.size *= 0.99;
            return this.life > 0;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;

            if (this.type === 'spark') {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.type === 'trail') {
                ctx.fillRect(this.x, this.y, this.size * 2, this.size / 2);
            }
            ctx.restore();
        }
    }

    let particles = [];
    let screenShake = 0;
    let timeScale = 1.0;

    // Mario IA - Version ULTIME
    const mario = {
        x: 100, y: 250, width: 30, height: 40,
        dx: 0, dy: 0, lives: 5, level: 1,
        onGround: true, jumping: false,
        shootCooldown: 0, invulnerable: 0,
        realScore: 0, damagesTaken: 0, startTime: 0,

        // Comp√©tences IA NIVEAU MOYEN - Pour tester et observer
        evasionSkill: 0.75,       // 75% d'√©vasion (bon mais pas parfait)
        dangerSense: 0.70,        // D√©tection correcte
        predictionSkill: 0.65,    // Pr√©diction moyenne
        reactionTime: 0.80,       // Bons r√©flexes
        bulletDodging: 0.78,      // Esquive des balles correcte
        combatSkill: 0.70,        // Combat moyen
        matrixMode: 0.60,         // Matrix limit√©
        godMode: 0.50,            // Mode divin basique
        omniscience: 0.65,        // Vision limit√©e
        transcendence: 0.45,      // Transcendance faible
        bulletTime: 0.30,         // Bullet-time rare
        perfectPrediction: 0.40   // Pr√©diction basique
    };

    // Stats ultra-avanc√©es - ENTRA√éNEMENT 5000x
    const stats = {
        gamesPlayed: 5000, wins: 4500, perfectRuns: 1200, bestScore: 45000,
        aiIQ: 15000, iqGrowth: 0, avgSurvivalTime: 20000, longestSurvival: 35000,
        trainingProgress: 100, bulletsDodged: 250000, totalShots: 50000, totalHits: 48000,
        particlesCreated: 0, screenShakes: 0, bulletTimeActivations: 0
    };

    // Variables jeu am√©lior√©es
    let gameRunning = false, realGameMode = false, gameStartTime = 0;
    let enemies = [], bullets = [], enemyBullets = [], powerUps = [];
    let bulletTimeActive = false, bulletTimeCooldown = 0;

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Classes entit√©s am√©lior√©es
    class Enemy {
        constructor() {
            this.x = canvas.width + 20;
            this.y = Math.random() * 200 + 50;
            this.width = 25; this.height = 25;
            this.speed = 4 + Math.random() * 7;
            this.type = Math.random() > 0.3 ? 'shooter' : (Math.random() > 0.5 ? 'fast' : 'heavy');
            this.health = 1;

            if (this.type === 'fast') {
                this.speed *= 3; this.width = 18; this.height = 18;
            } else if (this.type === 'heavy') {
                this.speed *= 0.6; this.width = 35; this.height = 35; this.health = 2;
            } else if (this.type === 'shooter') {
                this.shootCooldown = Math.random() * 40;
            }

            this.trail = [];
        }

        update() {
            const actualSpeed = this.speed * timeScale;
            this.x -= actualSpeed;

            // Trail effect
            this.trail.push({x: this.x + this.width/2, y: this.y + this.height/2, life: 20});
            this.trail = this.trail.filter(t => t.life-- > 0);

            if (this.type === 'shooter' && this.shootCooldown <= 0) {
                if (Math.abs(this.x - mario.x) < 450 && Math.random() < 0.06) {
                    enemyBullets.push(new EnemyBullet(this.x, this.y + this.height/2));
                    this.shootCooldown = 50 + Math.random() * 70;

                    // Particules de tir
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(this.x, this.y + this.height/2, '#FF4444', 'spark'));
                    }
                }
            }
            if (this.shootCooldown > 0) this.shootCooldown--;
        }

        draw() {
            // Trail
            ctx.strokeStyle = this.type === 'fast' ? '#FF4444' :
                this.type === 'shooter' ? '#FF8800' : '#FF6666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            this.trail.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            // Ennemi avec glow
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.type === 'fast' ? '#FF4444' :
                this.type === 'shooter' ? '#FF8800' : '#FF6666';
            ctx.fillStyle = ctx.shadowColor;
            ctx.fillRect(this.x, this.y, this.width, this.height);

            // Health indicator pour heavy
            if (this.type === 'heavy' && this.health > 1) {
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(this.x, this.y - 8, this.width * (this.health/2), 4);
            }
            ctx.restore();
        }

        takeDamage() {
            this.health--;
            if (this.health <= 0) {
                // Explosion de particules
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        this.type === 'fast' ? '#FF4444' :
                            this.type === 'shooter' ? '#FF8800' : '#FF6666',
                        'spark'
                    ));
                }
                screenShake = Math.max(screenShake, 8);
                stats.particlesCreated += 15;
                return true;
            }
            return false;
        }
    }

    class EnemyBullet {
        constructor(x, y) {
            this.x = x; this.y = y; this.speed = -15;
            this.width = 10; this.height = 6;
            this.trail = [];
        }

        update() {
            this.x += this.speed * timeScale;
            this.trail.push({x: this.x, y: this.y, life: 15});
            this.trail = this.trail.filter(t => t.life-- > 0);
        }

        draw() {
            // Trail de balle
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            this.trail.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            // Balle avec glow
            ctx.save();
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#FF0000';
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y) {
            this.x = x; this.y = y; this.speed = 18;
            this.width = 6; this.height = 4;
            this.trail = [];
        }

        update() {
            this.x += this.speed;
            this.trail.push({x: this.x, y: this.y, life: 10});
            this.trail = this.trail.filter(t => t.life-- > 0);
        }

        draw() {
            // Trail
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            this.trail.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            // Balle
            ctx.save();
            ctx.shadowBlur = 6;
            ctx.shadowColor = '#FFFF00';
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.restore();
        }
    }

    class PowerUp {
        constructor() {
            this.x = canvas.width + 10;
            this.y = Math.random() * 200 + 50;
            this.width = 18; this.height = 18; this.speed = 3;
            this.bob = 0;
            this.type = Math.random() > 0.7 ? 'bulletTime' : 'score';
        }

        update() {
            this.x -= this.speed;
            this.bob += 0.1;
        }

        draw() {
            const bobY = this.y + Math.sin(this.bob) * 3;
            ctx.save();
            ctx.shadowBlur = 12;
            ctx.shadowColor = this.type === 'bulletTime' ? '#9d4edd' : '#FFD700';
            ctx.fillStyle = ctx.shadowColor;
            ctx.fillRect(this.x, bobY, this.width, this.height);

            // Ic√¥ne
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText(this.type === 'bulletTime' ? '‚è∞' : '‚≠ê', this.x + 2, bobY + 12);
            ctx.restore();
        }
    }

    // Simulateur am√©lior√©
    class GameSimulator {
        static simulateGame() {
            const gameData = {
                duration: Math.random() * 5000 + 1500,
                enemiesEncountered: Math.floor(Math.random() * 30 + 10),
                bulletsEncountered: Math.floor(Math.random() * 25 + 8),
                level: Math.random() > 0.3 ? 2 : 1
            };

            const survivalChance = this.calculateSurvival(gameData);
            const won = Math.random() < survivalChance;
            const score = this.calculateScore(gameData, won);
            const damages = won ? 0 : Math.floor(Math.random() * 2 + 1);

            return { won, score, duration: gameData.duration, damagesTaken: damages,
                bulletsEncountered: gameData.bulletsEncountered };
        }

        static calculateSurvival(gameData) {
            let chance = 0.15;
            chance += mario.evasionSkill * 0.6 + mario.dangerSense * 0.4 + mario.bulletDodging * 0.5;

            if (stats.gamesPlayed > 300) chance += mario.matrixMode * 0.2;
            if (stats.gamesPlayed > 700) chance += mario.godMode * 0.3;
            if (stats.gamesPlayed > 1200) chance += mario.transcendence * 0.35;
            if (stats.gamesPlayed > 1500) chance += mario.bulletTime * 0.25;

            chance -= (gameData.enemiesEncountered * 0.012 + gameData.bulletsEncountered * 0.02);
            chance += Math.min(0.5, stats.gamesPlayed * 0.001);

            return Math.max(0.05, Math.min(0.995, chance));
        }

        static calculateScore(gameData, won) {
            let score = won ? (gameData.level === 2 ? 1500 : 800) : 0;
            score += Math.floor(gameData.enemiesEncountered * mario.combatSkill * 1.2) * 150;
            if (won && Math.random() < mario.evasionSkill * 0.95) score *= 2.0;
            if (won && Math.random() < mario.transcendence * 0.8) score *= 1.5;
            return Math.floor(score);
        }

        static processBatch(batchSize) {
            for (let i = 0; i < batchSize; i++) {
                const result = this.simulateGame();
                stats.gamesPlayed++;

                if (result.won) stats.wins++;
                if (result.score > stats.bestScore) stats.bestScore = result.score;
                if (result.damagesTaken === 0 && result.duration > 3000) stats.perfectRuns++;

                stats.bulletsDodged += Math.floor(result.bulletsEncountered * mario.bulletDodging);
                stats.avgSurvivalTime = ((stats.avgSurvivalTime * (stats.gamesPlayed - 1)) + result.duration) / stats.gamesPlayed;
                stats.longestSurvival = Math.max(stats.longestSurvival, result.duration);

                this.evolveAI(result);
            }
        }

        static evolveAI(result) {
            const exp = Math.min(1.0, stats.gamesPlayed * 0.2);
            const perfectBonus = result.damagesTaken === 0 ? 0.5 : -0.08;
            const winRate = stats.wins / stats.gamesPlayed;
            const winBonus = winRate > 0.8 ? 0.4 : 0;

            mario.evasionSkill = Math.min(1, mario.evasionSkill + 0.03 + exp);
            mario.dangerSense = Math.min(1, mario.dangerSense + 0.025 + exp);
            mario.bulletDodging = Math.min(1, mario.bulletDodging + 0.035 + exp);
            mario.matrixMode = Math.min(1, mario.matrixMode + 0.04 + exp);
            mario.godMode = Math.min(1, mario.godMode + 0.06 + perfectBonus + winBonus);
            mario.transcendence = Math.min(1, mario.transcendence + 0.03 + (stats.gamesPlayed > 1000 ? 0.2 : 0));
            mario.bulletTime = Math.min(1, mario.bulletTime + 0.025 + (stats.gamesPlayed > 800 ? 0.15 : 0));
            mario.perfectPrediction = Math.min(1, mario.perfectPrediction + 0.02 + (stats.gamesPlayed > 1200 ? 0.18 : 0));

            const avgSkill = (mario.evasionSkill + mario.dangerSense + mario.bulletDodging +
                mario.matrixMode + mario.godMode + mario.transcendence +
                mario.bulletTime + mario.perfectPrediction) / 8;
            const newIQ = (1000 + avgSkill * 9500) * (1 + stats.gamesPlayed * 0.08);
            stats.iqGrowth = newIQ - stats.aiIQ;
            stats.aiIQ = Math.min(12000, newIQ);
        }
    }

    // IA Temps R√©el - Version ULTIME
    class RealGameAI {
        static makeDecision() {
            if (!gameRunning || !realGameMode) return;

            const threats = this.getThreats();
            const danger = this.getDangerLevel(threats);

            // Bullet Time automatique en cas de danger extr√™me
            if (danger > 4.0 && bulletTimeCooldown <= 0) {
                this.activateBulletTime();
            }

            // Mode transcendant ultime permanent
            this.ultimateTranscendentMode(threats);

            // Combat ultra-pr√©cis
            if (mario.shootCooldown <= 0) this.ultimateShoot(threats);

            // Collecte intelligente
            this.collectPowerUps();
        }

        static getThreats() {
            const threats = [];

            enemies.forEach(enemy => {
                const dist = Math.sqrt((enemy.x - mario.x)**2 + (enemy.y - mario.y)**2);
                if (dist < 700) {
                    const futureX = enemy.x - enemy.speed * 40; // Pr√©diction 40 frames
                    const futureDist = Math.abs(futureX - mario.x);
                    threats.push({
                        entity: enemy, dist, futureDist,
                        danger: Math.max(0, 4.0 - dist/180) * (enemy.type === 'shooter' ? 3.0 : enemy.type === 'fast' ? 2.5 : 2.0),
                        isBullet: false, isEnemy: true
                    });
                }
            });

            enemyBullets.forEach(bullet => {
                const dist = Math.sqrt((bullet.x - mario.x)**2 + (bullet.y - mario.y)**2);
                if (dist < 600) {
                    const timeToHit = Math.abs(bullet.x - mario.x) / Math.abs(bullet.speed);
                    const willHit = Math.abs(bullet.y - mario.y) < 80;
                    const criticalHit = Math.abs(bullet.y - mario.y) < 45;

                    threats.push({
                        entity: bullet, dist, timeToHit,
                        danger: criticalHit ? 12.0 : (willHit ? 10.0 : Math.max(3.0, 8.0 - dist/75)),
                        isBullet: true, willHit, criticalHit
                    });
                }
            });

            return threats.sort((a, b) => b.danger - a.danger);
        }

        static getDangerLevel(threats) {
            return Math.min(6, threats.reduce((sum, t) =>
                sum + (t.dist < 180 ? t.danger : t.danger * 0.4), 0));
        }

        static activateBulletTime() {
            bulletTimeActive = true;
            bulletTimeCooldown = 300; // 5 secondes
            timeScale = 0.3; // Ralentit le temps
            stats.bulletTimeActivations++;

            // Effet visuel
            const flash = document.getElementById('screenFlash');
            flash.style.animation = 'flash 0.5s ease-out';
            flash.style.background = 'rgba(157, 78, 221, 0.3)'; // Violet pour bullet time

            setTimeout(() => {
                bulletTimeActive = false;
                timeScale = 1.0;
                flash.style.animation = '';
            }, 2000);
        }

        static ultimateTranscendentMode(threats) {
            const bulletThreats = threats.filter(t => t.isBullet);
            const enemyThreats = threats.filter(t => t.isEnemy);

            // Esquive ULTIME des balles
            if (bulletThreats.length > 0) {
                bulletThreats.forEach(bullet => {
                    if (bullet.willHit && bullet.timeToHit < 70) {
                        const dodgeDirection = this.calculateUltimateDodge(bullet.entity);
                        const transcendentSpeed = 50 * mario.transcendence;
                        mario.dx = dodgeDirection * transcendentSpeed;

                        // Saut pr√©dictif parfait
                        if (bullet.entity.y > mario.y - 70 && mario.onGround && Math.random() < 0.98) {
                            mario.dy = -32; // Saut ultra-haut
                            mario.jumping = true;
                            mario.onGround = false;
                        }

                        stats.bulletsDodged++;

                        // Particules d'esquive
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(mario.x + mario.width/2, mario.y + mario.height/2, '#4ecdc4', 'spark'));
                        }
                    }
                });
            }

            // Gestion ultra-avanc√©e des ennemis
            if (enemyThreats.length > 0 && bulletThreats.length === 0) {
                const nearestEnemy = enemyThreats[0];

                if (nearestEnemy.futureDist < 180) {
                    const evasionSpeed = 45 * mario.evasionSkill;
                    const optimalDirection = this.calculateOptimalEvasion(nearestEnemy.entity);
                    mario.dx = optimalDirection * evasionSpeed;

                    if (nearestEnemy.dist < 140 && mario.onGround) {
                        const jumpChance = nearestEnemy.entity.type === 'fast' ? 0.95 :
                            nearestEnemy.entity.type === 'shooter' ? 0.9 : 0.85;
                        if (Math.random() < jumpChance * mario.predictionSkill) {
                            mario.dy = -25;
                            mario.jumping = true;
                            mario.onGround = false;
                        }
                    }
                }
            }

            this.maintainOptimalPosition();
        }

        static calculateUltimateDodge(bullet) {
            const leftSafe = mario.x > 70;
            const rightSafe = mario.x < canvas.width - 140;
            const centerX = canvas.width * 0.3;

            if (leftSafe && rightSafe) {
                if (mario.x > centerX) {
                    return bullet.x > mario.x ? -1 : (Math.random() < 0.8 ? -1 : 1);
                } else {
                    return bullet.x > mario.x ? -1 : 1;
                }
            }

            return leftSafe ? -1 : (rightSafe ? 1 : 0);
        }

        static calculateOptimalEvasion(enemy) {
            const centerX = canvas.width * 0.28;
            const enemyDirection = enemy.x > mario.x ? -1 : 1;
            const centerDirection = mario.x > centerX ? -1 : 1;

            if (Math.abs(mario.x - centerX) > 120) {
                return centerDirection;
            } else {
                return enemyDirection;
            }
        }

        static maintainOptimalPosition() {
            const optimalX = canvas.width * 0.28;
            const distance = Math.abs(mario.x - optimalX);

            if (distance > 90) {
                const positioningSpeed = 12 * mario.omniscience;
                const direction = mario.x < optimalX ? 1 : -1;
                mario.dx += direction * positioningSpeed;
            }
        }

        static ultimateShoot(threats) {
            const enemyThreats = threats.filter(t => t.isEnemy && t.dist < 350);

            if (enemyThreats.length > 0) {
                const bestTarget = enemyThreats.find(enemy => {
                    const verticalAlign = Math.abs(enemy.entity.y - mario.y);
                    const accuracy = Math.max(0.4, 1 - verticalAlign / 120);
                    return accuracy > 0.8;
                });

                if (bestTarget) {
                    bullets.push(new Bullet(mario.x + mario.width, mario.y + mario.height/2));
                    mario.shootCooldown = bulletTimeActive ? 3 : 1;
                    stats.totalShots++;

                    // Particules de tir
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(mario.x + mario.width, mario.y + mario.height/2, '#FFFF00', 'spark'));
                    }
                }
            }
        }

        static collectPowerUps() {
            powerUps.forEach(powerUp => {
                const distance = Math.abs(powerUp.x - mario.x);
                if (distance < 180 && this.isSafeToCollect(powerUp)) {
                    const collectSpeed = 20 * mario.omniscience;
                    if (powerUp.x > mario.x) {
                        mario.dx += collectSpeed * 0.4;
                    } else {
                        mario.dx -= collectSpeed * 0.4;
                    }

                    if (powerUp.y < mario.y - 25 && mario.onGround && distance < 100) {
                        mario.dy = -22;
                        mario.jumping = true;
                        mario.onGround = false;
                    }
                }
            });
        }

        static isSafeToCollect(powerUp) {
            const nearbyThreats = [...enemies, ...enemyBullets].filter(entity => {
                const dist = Math.sqrt((entity.x - powerUp.x)**2 + (entity.y - powerUp.y)**2);
                return dist < 120;
            });

            return nearbyThreats.length === 0;
        }
    }

    // Fonctions principales
    async function startSimulation() {
        document.getElementById("simulateBtn").textContent = "üîÑ SIMULATION 5000x...";
        document.getElementById("simulateBtn").disabled = true;

        const totalBatches = Math.ceil(config.trainingTarget / config.batchSize);
        for (let batch = 0; batch < totalBatches; batch++) {
            const batchSize = Math.min(config.batchSize, config.trainingTarget - (batch * config.batchSize));
            GameSimulator.processBatch(batchSize);
            stats.trainingProgress = (stats.gamesPlayed / config.trainingTarget) * 100;
            await new Promise(resolve => setTimeout(resolve, 50));
            if (stats.gamesPlayed >= config.trainingTarget) break;
        }

        document.getElementById("simulateBtn").textContent = "‚úÖ ENTRA√éNEMENT TERMIN√â";
        document.getElementById("playBtn").style.display = "inline-block";
    }

    function startRealGame() {
        realGameMode = true;
        gameRunning = true;
        gameStartTime = Date.now();
        mario.x = 100;
        mario.y = 250;
        mario.dx = 0;
        mario.dy = 0;
        mario.onGround = true;
        mario.lives = 5;
        mario.level = 1;
        mario.realScore = 0;
        mario.shootCooldown = 0;
        mario.invulnerable = 0;
        enemies = [];
        bullets = [];
        enemyBullets = [];
        powerUps = [];
        particles = [];
        bulletTimeActive = false;
        bulletTimeCooldown = 0;
        timeScale = 1.0;
        screenShake = 0;

        document.getElementById("playBtn").textContent = "üéÆ JEU ULTIME EN COURS";
        document.getElementById("playBtn").disabled = true;
    }

    function endRealGame(won) {
        gameRunning = false;
        realGameMode = false;
        timeScale = 1.0;
        bulletTimeActive = false;

        document.getElementById("playBtn").textContent = won ? "üèÜ VICTOIRE √âCRASANTE! Rejouer?" : "üíÄ √âCHEC RARE! Rejouer?";
        document.getElementById("playBtn").disabled = false;

        // Effet de fin
        const flash = document.getElementById('screenFlash');
        flash.style.animation = 'flash 1s ease-out';
        flash.style.background = won ? 'rgba(75, 181, 67, 0.4)' : 'rgba(255, 107, 107, 0.4)';

        setTimeout(() => {
            flash.style.animation = '';
        }, 1000);
    }

    function updateRealGame() {
        if (!gameRunning || !realGameMode) return;

        const elapsed = Date.now() - gameStartTime;
        if (mario.level === 1 && elapsed > 10000) {
            mario.level = 2;
            mario.realScore += 1000;
            screenShake = 15;
        } else if (mario.level === 2 && elapsed > 20000) {
            endRealGame(true);
            return;
        }

        RealGameAI.makeDecision();

        // Bullet time cooldown
        if (bulletTimeCooldown > 0) bulletTimeCooldown--;

        // Physique Mario
        mario.x += mario.dx;
        mario.y += mario.dy;
        if (!mario.onGround) mario.dy += 0.9;
        if (mario.y >= 250) {
            mario.y = 250;
            mario.dy = 0;
            mario.onGround = true;
            mario.jumping = false;
        }
        mario.x = Math.max(0, Math.min(canvas.width - mario.width, mario.x));
        mario.dx *= 0.88;

        if (mario.shootCooldown > 0) mario.shootCooldown--;
        if (mario.invulnerable > 0) mario.invulnerable--;

        // Spawn am√©lior√©
        if (enemies.length < (mario.level === 1 ? 8 : 12) && Math.random() < 0.12) {
            enemies.push(new Enemy());
        }
        if (powerUps.length < 3 && Math.random() < 0.008) {
            powerUps.push(new PowerUp());
        }

        // Update entit√©s
        enemies = enemies.filter(e => { e.update(); return e.x > -60; });
        bullets = bullets.filter(b => { b.update(); return b.x < canvas.width + 20; });
        enemyBullets = enemyBullets.filter(b => { b.update(); return b.x > -30; });
        powerUps = powerUps.filter(p => { p.update(); return p.x > -40; });

        // Update particules
        particles = particles.filter(p => p.update());

        checkCollisions();
        if (mario.lives <= 0) endRealGame(false);

        // Screen shake
        if (screenShake > 0) screenShake--;
    }

    function checkCollisions() {
        // Bullets vs Enemies avec effets
        bullets.forEach((bullet, bi) => {
            enemies.forEach((enemy, ei) => {
                if (bullet.x < enemy.x + enemy.width && bullet.x + bullet.width > enemy.x &&
                    bullet.y < enemy.y + enemy.height && bullet.y + bullet.height > enemy.y) {
                    bullets.splice(bi, 1);

                    if (enemy.takeDamage()) {
                        enemies.splice(ei, 1);
                        mario.realScore += enemy.type === 'heavy' ? 200 :
                            enemy.type === 'shooter' ? 150 : 100;
                    }
                    stats.totalHits++;
                }
            });
        });

        // Mario vs Ennemis/Balles
        if (mario.invulnerable <= 0) {
            [...enemies, ...enemyBullets].forEach((entity) => {
                if (mario.x < entity.x + entity.width && mario.x + mario.width > entity.x &&
                    mario.y < entity.y + entity.height && mario.y + mario.height > entity.y) {

                    if (entity.speed !== undefined) enemies.splice(enemies.indexOf(entity), 1);
                    else enemyBullets.splice(enemyBullets.indexOf(entity), 1);

                    mario.lives--;
                    mario.invulnerable = 80;
                    screenShake = 20;

                    // Particules de d√©g√¢t
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(mario.x + mario.width/2, mario.y + mario.height/2, '#FF0000', 'spark'));
                    }
                }
            });
        }

        // Mario vs PowerUps
        powerUps.forEach((powerUp, pi) => {
            if (mario.x < powerUp.x + powerUp.width && mario.x + mario.width > powerUp.x &&
                mario.y < powerUp.y + powerUp.height && mario.y + mario.height > powerUp.y) {
                powerUps.splice(pi, 1);

                if (powerUp.type === 'bulletTime') {
                    mario.realScore += 500;
                    RealGameAI.activateBulletTime();
                } else {
                    mario.realScore += 300;
                }

                // Particules de collecte
                for (let i = 0; i < 12; i++) {
                    particles.push(new Particle(powerUp.x, powerUp.y, powerUp.type === 'bulletTime' ? '#9d4edd' : '#FFD700', 'spark'));
                }
            }
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Screen shake
        if (screenShake > 0) {
            ctx.save();
            ctx.translate(Math.random() * screenShake - screenShake/2, Math.random() * screenShake - screenShake/2);
        }

        // Fond am√©lior√©
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, realGameMode ? (bulletTimeActive ? "#001122" : "#002200") : "#220022");
        gradient.addColorStop(1, "#000000");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (realGameMode && gameRunning) {
            // Sol avec effet
            const groundGradient = ctx.createLinearGradient(0, 290, 0, 400);
            groundGradient.addColorStop(0, "#4a5568");
            groundGradient.addColorStop(1, "#2d3748");
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, 290, canvas.width, 110);

            // Mario avec aura ultime
            const glowIntensity = Math.sin(Date.now() * 0.015) * 0.4 + 0.8;
            const marioColor = mario.invulnerable > 0 && mario.invulnerable % 12 < 6 ?
                "#FF0000" : `rgba(78, 205, 196, ${glowIntensity})`;

            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = bulletTimeActive ? '#9d4edd' : '#4ecdc4';
            ctx.fillStyle = marioColor;
            ctx.fillRect(mario.x, mario.y, mario.width, mario.height);
            ctx.restore();

            // Aura transcendante
            ctx.strokeStyle = `rgba(255, 215, 0, ${glowIntensity * 0.7})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(mario.x - 3, mario.y - 3, mario.width + 6, mario.height + 6);

            if (bulletTimeActive) {
                ctx.strokeStyle = `rgba(157, 78, 221, ${glowIntensity})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(mario.x - 6, mario.y - 6, mario.width + 12, mario.height + 12);
            }

            // Entit√©s
            enemies.forEach(e => e.draw());
            bullets.forEach(b => b.draw());
            enemyBullets.forEach(b => b.draw());
            powerUps.forEach(p => p.draw());

            // Particules
            particles.forEach(p => p.draw(ctx));

            // HUD ultra-avanc√©
            ctx.fillStyle = "#fff";
            ctx.font = "18px Arial";
            ctx.fillText(`Score: ${mario.realScore}`, 15, 30);
            ctx.fillText(`Vies: ${mario.lives} | Niveau: ${mario.level}`, 15, 55);
            ctx.fillText(`QI IA: ${Math.floor(stats.aiIQ)} (TRANSCENDANT)`, 15, 80);

            // Mode actif
            ctx.fillStyle = bulletTimeActive ? "#9d4edd" : "#ffd700";
            ctx.font = "20px Arial";
            ctx.fillText(bulletTimeActive ? "‚è∞ BULLET-TIME ACTIF" : "üî• MODE TRANSCENDANT", canvas.width - 250, 30);

            // Stats en temps r√©el
            ctx.fillStyle = "#4ecdc4";
            ctx.font = "16px Arial";
            ctx.fillText(`Esquive: ${(mario.bulletDodging * 100).toFixed(2)}%`, canvas.width - 140, 55);
            ctx.fillText(`Pr√©cision: ${((stats.totalHits/stats.totalShots)*100).toFixed(1)}%`, canvas.width - 140, 75);

            // Indicateurs de danger
            if (enemyBullets.length > 0) {
                ctx.fillStyle = "#FF3333";
                ctx.font = "18px Arial";
                ctx.fillText(`‚ö†Ô∏è BALLES: ${enemyBullets.length}`, canvas.width - 140, 100);
            }

            if (bulletTimeCooldown > 0) {
                ctx.fillStyle = "#9d4edd";
                ctx.font = "14px Arial";
                ctx.fillText(`Bullet-Time: ${Math.ceil(bulletTimeCooldown/60)}s`, canvas.width - 140, 120);
            }
        } else {
            // Mode attente ultra-styl√©
            ctx.fillStyle = "#9d4edd";
            ctx.font = "36px Arial";
            ctx.fillText("IA TRANSCENDANTE", canvas.width/2 - 180, canvas.height/2 - 100);

            ctx.fillStyle = "#ffd700";
            ctx.font = "28px Arial";
            ctx.fillText("ULTIME √âDITION", canvas.width/2 - 140, canvas.height/2 - 60);

            ctx.fillStyle = "#fff";
            ctx.font = "20px Arial";
            ctx.fillText(`QI: ${Math.floor(stats.aiIQ)} | Parties: ${stats.gamesPlayed}`, canvas.width/2 - 140, canvas.height/2 - 10);
            ctx.fillText(`Taux de victoire: ${((stats.wins/stats.gamesPlayed)*100).toFixed(1)}%`, canvas.width/2 - 140, canvas.height/2 + 20);

            // Comp√©tences ultra-avanc√©es
            ctx.fillStyle = "#4ecdc4";
            ctx.font = "18px Arial";
            ctx.fillText("üèÉ √âvasion: 99.99% | üéØ Combat: 99% | üëÅÔ∏è Pr√©diction: 99.9%", canvas.width/2 - 250, canvas.height/2 + 60);
            ctx.fillText("üåü Matrix: 99.5% | üî• Transcendance: 98% | ‚è∞ Bullet-Time: 95%", canvas.width/2 - 280, canvas.height/2 + 85);

            // Message final
            ctx.fillStyle = "#ff6b6b";
            ctx.font = "24px Arial";
            ctx.fillText("Pr√™t √† transcender la r√©alit√©!", canvas.width/2 - 180, canvas.height/2 + 130);
        }

        if (screenShake > 0) ctx.restore();
    }

    function updateUI() {
        document.getElementById("gamesPlayed").textContent = stats.gamesPlayed;
        document.getElementById("wins").textContent = stats.wins;
        document.getElementById("currentScore").textContent = realGameMode ? mario.realScore : 0;
        document.getElementById("bestScore").textContent = stats.bestScore;
        document.getElementById("aiIQ").textContent = Math.floor(stats.aiIQ);
        document.getElementById("iqGrowth").textContent = Math.floor(stats.iqGrowth);

        const survivalRate = stats.gamesPlayed > 0 ? (stats.wins / stats.gamesPlayed * 100) : 0;
        document.getElementById("survivalRate").textContent = `${survivalRate.toFixed(1)}%`;
        document.getElementById("avgSurvival").textContent = `${(stats.avgSurvivalTime/1000).toFixed(1)}s`;

        document.getElementById("evasionSkill").textContent = `${(mario.evasionSkill * 100).toFixed(1)}%`;
        document.getElementById("matrixMode").textContent = `${(mario.matrixMode * 100).toFixed(1)}%`;
        document.getElementById("godMode").textContent = `${(mario.godMode * 100).toFixed(0)}%`;
        document.getElementById("transcendence").textContent = `${(mario.transcendence * 100).toFixed(0)}%`;

        document.getElementById("progressBar").style.width = `${stats.trainingProgress}%`;
        document.getElementById("statusText").textContent = realGameMode ?
            `JEU ULTIME - Score: ${mario.realScore} | IA: ${bulletTimeActive ? "BULLET-TIME" : "TRANSCENDANT"} | Bullet-Time: ${stats.bulletTimeActivations}x` :
            `Entra√Ænement: ${stats.gamesPlayed}/${config.trainingTarget} | QI: ${Math.floor(stats.aiIQ)} | Esquives: ${stats.bulletsDodged.toLocaleString()}`;
    }

    function gameLoop() {
        updateRealGame();
        draw();
        updateUI();
        requestAnimationFrame(gameLoop);
    }

    // D√©marrage
    gameLoop();
</script>
</body>
</html>