<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Explorer - Monde Infini</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            min-width: 250px;
            border: 2px solid #4facfe;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 25px;
            border-radius: 10px;
            display: flex;
            gap: 15px;
            border: 2px solid #4facfe;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
        }
        button {
            padding: 10px 20px;
            border: none;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: linear-gradient(135deg, #00f2fe, #4facfe);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.5);
        }
        #radar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0,20,0,0.8);
            border: 2px solid #00ff00;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.5);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            top: -10px;
            transform: translateX(-50%);
        }
        #crosshair::after {
            height: 2px;
            width: 20px;
            top: 50%;
            left: -10px;
            transform: translateY(-50%);
        }
        .mode-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 20px currentColor;
            animation: fadeOut 2s forwards;
            pointer-events: none;
        }
        @keyframes fadeOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        #instructions {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 13px;
            border: 2px solid #4facfe;
            max-width: 250px;
        }
        .key {
            display: inline-block;
            background: #4facfe;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            font-weight: bold;
        }
        .health-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3838, #ffaa00, #00ff00);
            transition: width 0.3s;
        }

        /* Mobile controls */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 1000;
            pointer-events: none;
        }

        .joystick {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #4facfe;
            border-radius: 50%;
            pointer-events: auto;
        }

        #leftJoystick {
            left: 20px;
            bottom: 20px;
        }

        #rightJoystick {
            right: 20px;
            bottom: 20px;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #4facfe, #00f2fe);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .mobile-button {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(79, 172, 254, 0.8);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        #fireButton {
            right: 20px;
            bottom: 160px;
        }

        #upButton {
            right: 100px;
            bottom: 80px;
        }

        #downButton {
            right: 100px;
            bottom: 10px;
        }

        @media (max-width: 768px) and (orientation: landscape),
        (max-width: 768px) and (orientation: portrait) {
            #mobileControls {
                display: block;
            }

            #instructions {
                display: none;
            }

            #controls {
                bottom: 160px;
                padding: 10px;
                gap: 10px;
            }

            #controls button {
                padding: 8px 12px;
                font-size: 12px;
            }

            #hud {
                font-size: 12px;
                padding: 10px;
                min-width: 200px;
            }

            #radar {
                width: 150px;
                height: 150px;
            }
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
    <h3>üöÅ DRONE EXPLORER</h3>
    <div style="color: #00ff00; font-size: 16px;">Niveau <span id="levelNum">1</span>: <span id="levelName">Patrouille</span></div>
    <div style="color: #ffff00;">Objectif: <span id="objective">Chargement...</span></div>
    <div style="color: #00ffff;">Progression: <span id="progress">0</span>/<span id="total">3</span></div>
    <div>Temps: <span id="timer">00:00</span></div>
    <div>Position: X:<span id="posX">0</span> Z:<span id="posZ">0</span></div>
    <div>Altitude: <span id="altitude">100</span>m</div>
    <div>Vitesse: <span id="speed">0</span> km/h</div>
    <div>Sant√©: <div class="health-bar"><div class="health-fill" id="health" style="width: 100%"></div></div></div>
    <div>√âliminations: <span id="kills">0</span></div>
    <div>Zone: <span id="zone">Centre Ville</span></div>
</div>

<div id="radar">
    <canvas id="radarCanvas" width="200" height="200"></canvas>
</div>

<div id="controls">
    <button onclick="startLevel(1)">üìç Niveau 1: Patrouille</button>
    <button onclick="startLevel(2)">‚öîÔ∏è Niveau 2: D√©fense</button>
    <button onclick="toggleCamera()">üì∑ Vue: <span id="cameraBtn">3√®me Personne</span></button>
    <button onclick="restartLevel()">üîÑ Recommencer</button>
</div>

<div id="instructions">
    <h4>üìã CONTR√îLES PC</h4>
    <p><span class="key">‚Üë</span> Avancer</p>
    <p><span class="key">‚Üì</span> Reculer</p>
    <p><span class="key">‚Üê</span> Tourner gauche</p>
    <p><span class="key">‚Üí</span> Tourner droite</p>
    <p><span class="key">Espace</span> Monter</p>
    <p><span class="key">Shift</span> Descendre</p>
    <p><span class="key">Clic</span> Tirer (Combat)</p>
    <p><span class="key">E</span> Turbo</p>
    <p><span class="key">Tab</span> Changer Mode</p>
    <p><span class="key">C</span> Changer Vue</p>
    <p style="margin-top: 10px; color: #4facfe;">üí° Contr√¥les fl√®ches uniquement!</p>
</div>

<div id="mobileControls">
    <div id="leftJoystick" class="joystick">
        <div class="joystick-knob" id="leftKnob"></div>
    </div>
    <div id="rightJoystick" class="joystick">
        <div class="joystick-knob" id="rightKnob"></div>
    </div>
    <div id="upButton" class="mobile-button">‚Üë</div>
    <div id="downButton" class="mobile-button">‚Üì</div>
    <div id="fireButton" class="mobile-button">üî´</div>
</div>

<div id="crosshair"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer;
    let playerDrone, enemies = [], bullets = [], particles = [];
    let keys = {};
    let mouse = { x: 0, y: 0 };
    let mode = 'exploration';
    let cameraMode = 0;
    let stats = { kills: 0, health: 100, ammo: 100 };
    let ambientLight, sun, sky;

    // Level system
    let currentLevel = 0;
    let levelStartTime = 0;
    let objectives = [];
    let checkpoints = [];
    let currentCheckpoint = 0;
    let levelComplete = false;

    // Map settings - FINITE MAP
    const MAP_SIZE = 2000; // Total map size (2km x 2km)
    const CITY_BLOCKS = 8; // 8x8 grid of city blocks
    const BLOCK_SIZE = MAP_SIZE / CITY_BLOCKS;

    // Geometry cache
    const geometryCache = {
        box: {},
        cylinder: {},
        sphere: {},
        plane: {}
    };

    // Material cache
    const materialCache = new Map();

    // Get or create cached geometry
    function getCachedGeometry(type, ...params) {
        const key = params.join('_');
        if (!geometryCache[type][key]) {
            switch(type) {
                case 'box':
                    geometryCache[type][key] = new THREE.BoxGeometry(...params);
                    break;
                case 'cylinder':
                    geometryCache[type][key] = new THREE.CylinderGeometry(...params);
                    break;
                case 'sphere':
                    geometryCache[type][key] = new THREE.SphereGeometry(...params);
                    break;
                case 'plane':
                    geometryCache[type][key] = new THREE.PlaneGeometry(...params);
                    break;
            }
        }
        return geometryCache[type][key];
    }

    // Get or create cached material
    function getCachedMaterial(type, options) {
        const key = type + '_' + JSON.stringify(options);
        if (!materialCache.has(key)) {
            switch(type) {
                case 'phong':
                    materialCache.set(key, new THREE.MeshPhongMaterial(options));
                    break;
                case 'basic':
                    materialCache.set(key, new THREE.MeshBasicMaterial(options));
                    break;
            }
        }
        return materialCache.get(key);
    }

    // Init Three.js
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x11151c, 0.0008);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 3000);
    camera.position.set(0, 150, 200);

    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('c'),
        antialias: true,
        alpha: false,
        powerPreference: "high-performance",
        stencil: false,
        depth: true
    });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    renderer.outputEncoding = THREE.sRGBEncoding;

    // Lighting
    ambientLight = new THREE.AmbientLight(0x4466aa, 0.3);
    scene.add(ambientLight);

    sun = new THREE.DirectionalLight(0xffd4a3, 0.8);
    sun.position.set(300, 600, 300);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 4096;
    sun.shadow.mapSize.height = 4096;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 2000;
    sun.shadow.camera.left = -500;
    sun.shadow.camera.right = 500;
    sun.shadow.camera.top = 500;
    sun.shadow.camera.bottom = -500;
    sun.shadow.bias = -0.0005;
    scene.add(sun);

    const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x545454, 0.4);
    scene.add(hemiLight);

    const rimLight = new THREE.DirectionalLight(0x88ccff, 0.3);
    rimLight.position.set(-300, 400, -300);
    scene.add(rimLight);

    // Sky
    const skyGeo = new THREE.SphereGeometry(3000, 64, 64);
    const skyMat = new THREE.ShaderMaterial({
        uniforms: {
            topColor: { value: new THREE.Color(0x0088ff) },
            bottomColor: { value: new THREE.Color(0xffd4a3) },
            offset: { value: 400 },
            exponent: { value: 0.5 },
            time: { value: 0 }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            uniform float time;
            varying vec3 vWorldPosition;
            varying vec2 vUv;

            void main() {
                float h = normalize(vWorldPosition + offset).y;
                vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));

                float cloud = sin(vUv.x * 10.0 + time * 0.1) * cos(vUv.y * 8.0 + time * 0.05);
                cloud = smoothstep(0.3, 0.7, cloud) * 0.1;
                skyColor = mix(skyColor, vec3(1.0), cloud * h);

                gl_FragColor = vec4(skyColor, 1.0);
            }
        `,
        side: THREE.BackSide
    });
    sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Clouds
    const cloudCount = 5;
    for(let i = 0; i < cloudCount; i++) {
        const cloud = new THREE.Mesh(
            getCachedGeometry('plane', 300, 300),
            getCachedMaterial('basic', {
                color: 0xffffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            })
        );
        cloud.position.set(
            (Math.random() - 0.5) * 2000,
            300 + Math.random() * 200,
            (Math.random() - 0.5) * 2000
        );
        cloud.rotation.x = Math.PI / 2;
        cloud.scale.setScalar(0.5 + Math.random());
        scene.add(cloud);
        cloud.userData.velocity = 0.1 + Math.random() * 0.2;
        cloud.userData.isCloud = true;
    }

    // Player Drone Class
    class PlayerDrone {
        constructor() {
            const group = new THREE.Group();

            const bodyGeo = new THREE.OctahedronGeometry(12, 1);
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0x4facfe,
                emissive: 0x0066cc,
                emissiveIntensity: 0.3,
                metalness: 0.8,
                roughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);

            this.rotors = [];
            for(let i = 0; i < 4; i++) {
                const angle = (i/4) * Math.PI * 2;
                const rotorGroup = new THREE.Group();

                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 2, 2),
                    new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
                );
                arm.position.x = Math.cos(angle) * 7.5;
                arm.position.z = Math.sin(angle) * 7.5;
                arm.rotation.y = angle;
                rotorGroup.add(arm);

                const rotor = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 0.5, 3),
                    new THREE.MeshBasicMaterial({
                        color: 0x222222,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                rotor.position.x = Math.cos(angle) * 15;
                rotor.position.z = Math.sin(angle) * 15;
                rotor.position.y = 5;
                rotorGroup.add(rotor);
                this.rotors.push(rotor);

                group.add(rotorGroup);
            }

            const cockpit = new THREE.Mesh(
                new THREE.SphereGeometry(5, 8, 4),
                new THREE.MeshPhongMaterial({
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x4facfe,
                    emissiveIntensity: 0.2
                })
            );
            cockpit.position.y = 3;
            group.add(cockpit);

            const weapon = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1, 10),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            weapon.position.set(0, -5, 8);
            weapon.rotation.x = Math.PI/2;
            group.add(weapon);

            const light = new THREE.PointLight(0x4facfe, 2, 150);
            light.position.y = -5;
            light.castShadow = true;
            group.add(light);

            const spotlight = new THREE.SpotLight(0xffffff, 2, 500, Math.PI/6, 0.3, 1);
            spotlight.position.set(0, -5, 10);
            spotlight.target.position.set(0, -100, 100);
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 1024;
            spotlight.shadow.mapSize.height = 1024;
            group.add(spotlight);
            group.add(spotlight.target);

            const glowGeometry = new THREE.SphereGeometry(15, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);

            this.mesh = group;
            this.mesh.position.set(0, 100, 0);
            this.velocity = new THREE.Vector3(0, 0, 0); // Ensure velocity starts at zero
            this.rotation = new THREE.Vector3(0, 0, 0); // Ensure rotation starts at zero
            this.health = 100;
            this.maxSpeed = mode === 'combat' ? 8 : 5;
            this.turbo = false;
            this.lastShot = 0;

            scene.add(this.mesh);
        }

        update() {
            this.rotors.forEach(rotor => {
                rotor.rotation.y += this.turbo ? 0.8 : 0.5;
            });

            if(mode === 'exploration') {
                this.explorationMovement();
            } else {
                this.combatMovement();
            }

            this.mesh.position.add(this.velocity);

            document.getElementById('posX').textContent = Math.floor(this.mesh.position.x);
            document.getElementById('posZ').textContent = Math.floor(this.mesh.position.z);
            document.getElementById('altitude').textContent = Math.floor(this.mesh.position.y);
            document.getElementById('speed').textContent = Math.floor(this.velocity.length() * 20);
            document.getElementById('health').style.width = this.health + '%';

            // Update zone name based on position
            let zone = "Centre Ville";
            if(Math.abs(this.mesh.position.x) < BLOCK_SIZE && Math.abs(this.mesh.position.z) < BLOCK_SIZE) {
                zone = "Parc Central";
            } else if(this.mesh.position.x > MAP_SIZE/3 && this.mesh.position.z > MAP_SIZE/3) {
                zone = "Tour Landmark";
            } else if(this.mesh.position.x < -MAP_SIZE/3 && this.mesh.position.z < -MAP_SIZE/3) {
                zone = "Stade Municipal";
            } else if(Math.abs(this.mesh.position.x) > MAP_SIZE/2 - 100 || Math.abs(this.mesh.position.z) > MAP_SIZE/2 - 100) {
                zone = "Fronti√®re";
            }
            document.getElementById('zone').textContent = zone;
        }

        explorationMovement() {
            const moveSpeed = this.turbo ? 0.8 : 0.4;
            const rotSpeed = this.turbo ? 0.06 : 0.04;

            // Rotation ONLY - no movement
            if(keys['arrowleft']) {
                this.mesh.rotation.y += rotSpeed;
            }
            if(keys['arrowright']) {
                this.mesh.rotation.y -= rotSpeed;
            }

            // Forward/Backward movement based on current rotation
            if(keys['arrowup']) {
                // Move in the direction the drone is facing
                this.velocity.x -= Math.sin(this.mesh.rotation.y) * moveSpeed;
                this.velocity.z -= Math.cos(this.mesh.rotation.y) * moveSpeed;
            }
            if(keys['arrowdown']) {
                // Move backward
                this.velocity.x += Math.sin(this.mesh.rotation.y) * moveSpeed * 0.5;
                this.velocity.z += Math.cos(this.mesh.rotation.y) * moveSpeed * 0.5;
            }

            // Altitude control - direct and responsive
            if(keys[' ']) {
                this.velocity.y = moveSpeed * 2; // Direct upward speed
            } else if(keys['shift']) {
                this.velocity.y = -moveSpeed * 2; // Direct downward speed
            } else {
                this.velocity.y *= 0.8; // Quick stop on vertical axis
            }

            // Apply horizontal drag
            this.velocity.x *= 0.88;
            this.velocity.z *= 0.88;

            // Full stop when very slow
            if(Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;
            if(Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;
            if(Math.abs(this.velocity.y) < 0.01) this.velocity.y = 0;

            // Height limits within map boundaries
            const mapLimit = MAP_SIZE/2 - 50;
            this.mesh.position.x = Math.max(-mapLimit, Math.min(mapLimit, this.mesh.position.x));
            this.mesh.position.z = Math.max(-mapLimit, Math.min(mapLimit, this.mesh.position.z));
            this.mesh.position.y = Math.max(30, Math.min(400, this.mesh.position.y));

            // Visual tilt based on movement
            const targetTiltX = -this.velocity.z * 0.05;
            const targetTiltZ = -this.velocity.x * 0.05;
            this.mesh.rotation.x += (targetTiltX - this.mesh.rotation.x) * 0.1;
            this.mesh.rotation.z += (targetTiltZ - this.mesh.rotation.z) * 0.1;
        }

        combatMovement() {
            const moveSpeed = 0.5;
            const rotSpeed = 0.06;

            // Rotation
            if(keys['arrowleft']) {
                this.mesh.rotation.y += rotSpeed;
            }
            if(keys['arrowright']) {
                this.mesh.rotation.y -= rotSpeed;
            }

            // Movement
            if(keys['arrowup']) {
                this.velocity.x -= Math.sin(this.mesh.rotation.y) * moveSpeed;
                this.velocity.z -= Math.cos(this.mesh.rotation.y) * moveSpeed;
            }
            if(keys['arrowdown']) {
                this.velocity.x += Math.sin(this.mesh.rotation.y) * moveSpeed * 0.6;
                this.velocity.z += Math.cos(this.mesh.rotation.y) * moveSpeed * 0.6;
            }

            // Vertical movement - direct control
            if(keys[' ']) {
                this.velocity.y = moveSpeed * 2;
            } else if(keys['shift']) {
                this.velocity.y = -moveSpeed * 2;
            } else {
                this.velocity.y *= 0.8;
            }

            // Apply drag
            this.velocity.x *= 0.85;
            this.velocity.z *= 0.85;

            // Full stop when very slow
            if(Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;
            if(Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;
            if(Math.abs(this.velocity.y) < 0.01) this.velocity.y = 0;

            // Combat height limits
            this.mesh.position.y = Math.max(50, Math.min(300, this.mesh.position.y));

            // Dynamic tilt
            const targetTiltX = -this.velocity.z * 0.06;
            const targetTiltZ = -this.velocity.x * 0.06;
            this.mesh.rotation.x += (targetTiltX - this.mesh.rotation.x) * 0.15;
            this.mesh.rotation.z += (targetTiltZ - this.mesh.rotation.z) * 0.15;
        }

        shoot() {
            const now = Date.now();
            if(now - this.lastShot < 100) return;

            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(2),
                new THREE.MeshBasicMaterial({
                    color: 0x00f2fe,
                    emissive: 0x00f2fe
                })
            );

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);

            bullet.position.copy(this.mesh.position);
            bullet.velocity = direction.multiplyScalar(20);
            bullet.life = 60;
            bullet.isPlayer = true;

            scene.add(bullet);
            bullets.push(bullet);
            this.lastShot = now;

            createMuzzleFlash(this.mesh.position);
        }

        takeDamage(damage) {
            this.health -= damage;
            stats.health = this.health;

            createExplosion(this.mesh.position, 0xff0000, 10);

            if(this.health <= 0) {
                this.respawn();
            }
        }

        respawn() {
            this.health = 100;
            stats.health = 100;
            this.mesh.position.set(0, 100, 0);
            this.velocity.set(0, 0, 0);
            showModeIndicator("RESPAWN!");
        }
    }

    // Enemy Drone Class
    class EnemyDrone {
        constructor(position) {
            const group = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.OctahedronGeometry(10, 0),
                new THREE.MeshPhongMaterial({
                    color: 0xff6b6b,
                    emissive: 0xcc0000,
                    emissiveIntensity: 0.3
                })
            );
            group.add(body);

            for(let i = 0; i < 4; i++) {
                const angle = (i/4) * Math.PI * 2;
                const rotor = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 1, 3),
                    new THREE.MeshBasicMaterial({ color: 0x1a1a1a })
                );
                rotor.position.x = Math.cos(angle) * 12;
                rotor.position.z = Math.sin(angle) * 12;
                rotor.position.y = 5;
                group.add(rotor);
            }

            this.mesh = group;
            this.mesh.position.copy(position);
            this.velocity = new THREE.Vector3();
            this.health = 50;
            this.lastShot = 0;
            this.target = playerDrone;

            scene.add(this.mesh);
        }

        update() {
            if(!this.target) return;

            const dist = this.mesh.position.distanceTo(this.target.mesh.position);

            if(dist > 150) {
                const dir = this.target.mesh.position.clone()
                    .sub(this.mesh.position).normalize();
                this.velocity.add(dir.multiplyScalar(0.3));
            } else if(dist < 80) {
                const dir = this.mesh.position.clone()
                    .sub(this.target.mesh.position).normalize();
                this.velocity.add(dir.multiplyScalar(0.2));
            } else {
                const angle = Date.now() * 0.002;
                this.velocity.x += Math.cos(angle) * 0.1;
                this.velocity.z += Math.sin(angle) * 0.1;
            }

            if(dist < 200 && Date.now() - this.lastShot > 500) {
                this.shoot();
            }

            this.velocity.multiplyScalar(0.95);
            this.mesh.position.add(this.velocity);
            this.mesh.lookAt(this.target.mesh.position);
        }

        shoot() {
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(2),
                new THREE.MeshBasicMaterial({
                    color: 0xff6b6b,
                    emissive: 0xff6b6b
                })
            );

            const direction = this.target.mesh.position.clone()
                .sub(this.mesh.position).normalize();

            bullet.position.copy(this.mesh.position);
            bullet.velocity = direction.multiplyScalar(15);
            bullet.life = 60;
            bullet.isPlayer = false;

            scene.add(bullet);
            bullets.push(bullet);
            this.lastShot = Date.now();
        }

        takeDamage(damage) {
            this.health -= damage;

            if(this.health <= 0) {
                createExplosion(this.mesh.position, 0xff6600, 30);
                scene.remove(this.mesh);
                stats.kills++;
                document.getElementById('kills').textContent = stats.kills;

                // Update level 2 progress if active
                if(currentLevel === 2) {
                    updateProgress();
                }

                return true;
            }

            createExplosion(this.mesh.position, 0xffaa00, 10);
            return false;
        }
    }

    // Generate finite city map
    function generateCity() {
        // Create main ground
        const groundGeo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 20, 20);
        const groundMat = new THREE.MeshPhongMaterial({
            color: 0x2d4a2b,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;

        // Add slight terrain variation
        const vertices = ground.geometry.attributes.position.array;
        for(let i = 0; i < vertices.length; i += 3) {
            vertices[i + 1] = Math.random() * 3;
        }
        ground.geometry.computeVertexNormals();
        scene.add(ground);

        // Create city boundaries (walls)
        const wallHeight = 100;
        const wallThickness = 10;
        const wallMat = new THREE.MeshPhongMaterial({
            color: 0x444444,
            metalness: 0.5,
            roughness: 0.5
        });

        // North wall
        const northWall = new THREE.Mesh(
            new THREE.BoxGeometry(MAP_SIZE + wallThickness*2, wallHeight, wallThickness),
            wallMat
        );
        northWall.position.set(0, wallHeight/2, MAP_SIZE/2);
        northWall.castShadow = true;
        scene.add(northWall);

        // South wall
        const southWall = new THREE.Mesh(
            new THREE.BoxGeometry(MAP_SIZE + wallThickness*2, wallHeight, wallThickness),
            wallMat
        );
        southWall.position.set(0, wallHeight/2, -MAP_SIZE/2);
        southWall.castShadow = true;
        scene.add(southWall);

        // East wall
        const eastWall = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, wallHeight, MAP_SIZE),
            wallMat
        );
        eastWall.position.set(MAP_SIZE/2, wallHeight/2, 0);
        eastWall.castShadow = true;
        scene.add(eastWall);

        // West wall
        const westWall = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, wallHeight, MAP_SIZE),
            wallMat
        );
        westWall.position.set(-MAP_SIZE/2, wallHeight/2, 0);
        westWall.castShadow = true;
        scene.add(westWall);

        // Add warning stripes on walls
        const stripeMat = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 0.5
        });

        for(let i = -MAP_SIZE/2; i < MAP_SIZE/2; i += 50) {
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(20, 20, wallThickness + 1),
                stripeMat
            );
            stripe.position.set(i, wallHeight/2, MAP_SIZE/2);
            scene.add(stripe);

            const stripe2 = stripe.clone();
            stripe2.position.set(i, wallHeight/2, -MAP_SIZE/2);
            scene.add(stripe2);
        }

        // Create street grid
        const streetMat = new THREE.MeshPhongMaterial({
            color: 0x333333,
            roughness: 0.8
        });

        // Main avenues
        for(let i = 1; i < CITY_BLOCKS; i++) {
            // Horizontal streets
            const streetH = new THREE.Mesh(
                new THREE.PlaneGeometry(MAP_SIZE, 20),
                streetMat
            );
            streetH.rotation.x = -Math.PI/2;
            streetH.position.set(0, 0.1, -MAP_SIZE/2 + i * BLOCK_SIZE);
            scene.add(streetH);

            // Vertical streets
            const streetV = new THREE.Mesh(
                new THREE.PlaneGeometry(20, MAP_SIZE),
                streetMat
            );
            streetV.rotation.x = -Math.PI/2;
            streetV.position.set(-MAP_SIZE/2 + i * BLOCK_SIZE, 0.1, 0);
            scene.add(streetV);
        }

        // Generate buildings in city blocks
        for(let x = 0; x < CITY_BLOCKS; x++) {
            for(let z = 0; z < CITY_BLOCKS; z++) {
                generateCityBlock(
                    -MAP_SIZE/2 + x * BLOCK_SIZE + BLOCK_SIZE/2,
                    -MAP_SIZE/2 + z * BLOCK_SIZE + BLOCK_SIZE/2
                );
            }
        }

        // Add central park
        createCentralPark();

        // Add landmarks
        createLandmarks();

        // Street lights along main roads
        for(let i = -MAP_SIZE/2 + 50; i < MAP_SIZE/2; i += 100) {
            for(let j = -MAP_SIZE/2 + 50; j < MAP_SIZE/2; j += 100) {
                const light = createStreetLight();
                light.position.set(i, 0, j);
                scene.add(light);
            }
        }
    }

    function generateCityBlock(centerX, centerZ) {
        // Skip central area for park
        if(Math.abs(centerX) < BLOCK_SIZE && Math.abs(centerZ) < BLOCK_SIZE) {
            return;
        }

        const buildingCount = 2 + Math.floor(Math.random() * 3);
        const margin = 30;

        for(let i = 0; i < buildingCount; i++) {
            const building = createBuilding();
            const posX = centerX + (Math.random() - 0.5) * (BLOCK_SIZE - margin*2);
            const posZ = centerZ + (Math.random() - 0.5) * (BLOCK_SIZE - margin*2);
            building.position.set(posX, 0, posZ);
            scene.add(building);
        }

        // Add some trees
        const treeCount = 3 + Math.floor(Math.random() * 5);
        for(let i = 0; i < treeCount; i++) {
            const tree = createTree();
            tree.position.set(
                centerX + (Math.random() - 0.5) * BLOCK_SIZE,
                0,
                centerZ + (Math.random() - 0.5) * BLOCK_SIZE
            );
            scene.add(tree);
        }
    }

    function createCentralPark() {
        // Large park in the center
        const parkSize = BLOCK_SIZE * 1.5;
        const parkMat = new THREE.MeshPhongMaterial({
            color: 0x3a5f0b,
            roughness: 0.9
        });

        const park = new THREE.Mesh(
            new THREE.CircleGeometry(parkSize/2, 32),
            parkMat
        );
        park.rotation.x = -Math.PI/2;
        park.position.y = 0.05;
        scene.add(park);

        // Lake in center
        const lakeMat = new THREE.MeshPhongMaterial({
            color: 0x006994,
            transparent: true,
            opacity: 0.8,
            shininess: 100
        });

        const lake = new THREE.Mesh(
            new THREE.CircleGeometry(parkSize/4, 16),
            lakeMat
        );
        lake.rotation.x = -Math.PI/2;
        lake.position.y = 0.1;
        scene.add(lake);

        // Fountain
        const fountain = new THREE.Mesh(
            new THREE.CylinderGeometry(10, 12, 5),
            new THREE.MeshPhongMaterial({ color: 0x808080 })
        );
        fountain.position.y = 2.5;
        scene.add(fountain);

        // Trees around park
        for(let i = 0; i < 20; i++) {
            const angle = (i / 20) * Math.PI * 2;
            const dist = parkSize/3 + Math.random() * parkSize/6;
            const tree = createTree();
            tree.position.set(
                Math.cos(angle) * dist,
                0,
                Math.sin(angle) * dist
            );
            scene.add(tree);
        }

        // Park benches
        for(let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const bench = createBench();
            bench.position.set(
                Math.cos(angle) * parkSize/3,
                0,
                Math.sin(angle) * parkSize/3
            );
            bench.rotation.y = angle;
            scene.add(bench);
        }
    }

    function createLandmarks() {
        // Skyscraper landmark (tallest building)
        const skyscraper = new THREE.Group();
        const height = 400;

        const tower = new THREE.Mesh(
            new THREE.BoxGeometry(60, height, 60),
            new THREE.MeshPhongMaterial({
                color: 0x1a1a2e,
                metalness: 0.8,
                roughness: 0.2
            })
        );
        tower.position.y = height/2;
        tower.castShadow = true;
        skyscraper.add(tower);

        // Antenna
        const antenna = new THREE.Mesh(
            new THREE.CylinderGeometry(2, 2, 50),
            new THREE.MeshPhongMaterial({ color: 0xff0000 })
        );
        antenna.position.y = height + 25;
        skyscraper.add(antenna);

        // Blinking light
        const blinkLight = new THREE.PointLight(0xff0000, 2, 100);
        blinkLight.position.y = height + 50;
        skyscraper.add(blinkLight);

        skyscraper.position.set(MAP_SIZE/3, 0, MAP_SIZE/3);
        scene.add(skyscraper);

        // Stadium
        const stadium = new THREE.Group();
        const stadiumBase = new THREE.Mesh(
            new THREE.CylinderGeometry(100, 120, 40, 16),
            new THREE.MeshPhongMaterial({ color: 0x555555 })
        );
        stadiumBase.position.y = 20;
        stadium.add(stadiumBase);

        // Stadium lights
        for(let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const lightPole = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 3, 60),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            lightPole.position.set(
                Math.cos(angle) * 110,
                30,
                Math.sin(angle) * 110
            );
            stadium.add(lightPole);

            const stadiumLight = new THREE.PointLight(0xffffff, 1, 200);
            stadiumLight.position.set(
                Math.cos(angle) * 110,
                60,
                Math.sin(angle) * 110
            );
            stadium.add(stadiumLight);
        }

        stadium.position.set(-MAP_SIZE/3, 0, -MAP_SIZE/3);
        scene.add(stadium);
    }

    function createBuilding() {
        const buildingType = Math.random();

        if(buildingType < 0.3) {
            return createOfficeBuilding();
        } else if(buildingType < 0.6) {
            return createResidentialBuilding();
        } else {
            return createModernBuilding();
        }
    }

    function createOfficeBuilding() {
        const group = new THREE.Group();
        const width = 40 + Math.random() * 40;
        const depth = 40 + Math.random() * 40;
        const height = 80 + Math.random() * 120;

        const building = new THREE.Mesh(
            getCachedGeometry('box', width, height, depth),
            getCachedMaterial('phong', {
                color: 0x34495e,
                metalness: 0.5,
                roughness: 0.5
            })
        );
        building.position.y = height/2;
        building.castShadow = true;
        building.receiveShadow = true;
        group.add(building);

        // Windows
        const windowMat = getCachedMaterial('basic', {
            color: 0x87ceeb,
            emissive: 0x4488bb,
            emissiveIntensity: 0.3
        });

        const rows = Math.floor(height / 15);
        for(let i = 1; i < rows; i++) {
            const windowLine = new THREE.Mesh(
                getCachedGeometry('box', width * 0.95, 8, 1),
                windowMat
            );
            windowLine.position.set(0, i * 15, depth/2 + 0.5);
            group.add(windowLine);
        }

        return group;
    }

    function createResidentialBuilding() {
        const group = new THREE.Group();
        const width = 35 + Math.random() * 25;
        const depth = 35 + Math.random() * 25;
        const height = 60 + Math.random() * 60;

        const building = new THREE.Mesh(
            getCachedGeometry('box', width, height, depth),
            getCachedMaterial('phong', {
                color: new THREE.Color().setHSL(0.08, 0.3, 0.4),
                metalness: 0.3,
                roughness: 0.7
            })
        );
        building.position.y = height/2;
        building.castShadow = true;
        group.add(building);

        // Balconies
        const balconyCount = Math.floor(height / 20);
        for(let i = 1; i < balconyCount; i++) {
            if(Math.random() > 0.5) {
                const balcony = new THREE.Mesh(
                    getCachedGeometry('box', width * 0.3, 2, 8),
                    getCachedMaterial('phong', { color: 0x555555 })
                );
                balcony.position.set(0, i * 20, depth/2 + 4);
                group.add(balcony);
            }
        }

        return group;
    }

    function createModernBuilding() {
        const group = new THREE.Group();
        const radius = 20 + Math.random() * 20;
        const height = 100 + Math.random() * 150;
        const segments = 8;

        const tower = new THREE.Mesh(
            getCachedGeometry('cylinder', radius, radius * 1.1, height, segments),
            getCachedMaterial('phong', {
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2
            })
        );
        tower.position.y = height/2;
        tower.castShadow = true;
        group.add(tower);

        return group;
    }

    function createTree() {
        const group = new THREE.Group();

        const trunk = new THREE.Mesh(
            getCachedGeometry('cylinder', 2, 3, 15),
            getCachedMaterial('phong', { color: 0x4a3c28 })
        );
        trunk.position.y = 7.5;
        group.add(trunk);

        const foliage = new THREE.Mesh(
            getCachedGeometry('sphere', 8 + Math.random() * 4, 6, 5),
            getCachedMaterial('phong', {
                color: new THREE.Color().setHSL(0.25, 0.8, 0.3),
                flatShading: true
            })
        );
        foliage.position.y = 20;
        group.add(foliage);

        return group;
    }

    function createStreetLight() {
        const group = new THREE.Group();

        const pole = new THREE.Mesh(
            getCachedGeometry('cylinder', 1, 1.5, 30),
            getCachedMaterial('phong', {
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.2
            })
        );
        pole.position.y = 15;
        group.add(pole);

        const lightBulb = new THREE.Mesh(
            getCachedGeometry('sphere', 4, 6, 4),
            getCachedMaterial('basic', {
                color: 0xffdd88,
                emissive: 0xffdd88
            })
        );
        lightBulb.position.y = 30;
        group.add(lightBulb);

        const light = new THREE.PointLight(0xffdd88, 0.5, 50);
        light.position.y = 30;
        group.add(light);

        return group;
    }

    function createBench() {
        const group = new THREE.Group();

        const seat = new THREE.Mesh(
            getCachedGeometry('box', 20, 1, 8),
            getCachedMaterial('phong', { color: 0x8b4513 })
        );
        seat.position.y = 5;
        group.add(seat);

        const back = new THREE.Mesh(
            getCachedGeometry('box', 20, 8, 1),
            getCachedMaterial('phong', { color: 0x8b4513 })
        );
        back.position.set(0, 9, -3.5);
        group.add(back);

        for(let i = -8; i <= 8; i += 16) {
            const leg = new THREE.Mesh(
                getCachedGeometry('box', 1, 5, 1),
                getCachedMaterial('phong', { color: 0x696969 })
            );
            leg.position.set(i, 2.5, 0);
            group.add(leg);
        }

        return group;
    }

    function toggleMode() {
        if(!playerDrone) return;

        mode = mode === 'exploration' ? 'combat' : 'exploration';
        document.getElementById('mode').textContent = mode.toUpperCase();
        document.getElementById('modeBtn').textContent = mode.toUpperCase();
        playerDrone.maxSpeed = mode === 'combat' ? 8 : 5;
        showModeIndicator(mode === 'combat' ? '‚öîÔ∏è MODE COMBAT' : 'üåç MODE EXPLORATION');

        if(mode === 'combat' && enemies.length === 0) {
            spawnEnemies();
        }
    }

    function spawnEnemies() {
        if(!playerDrone) return;

        const count = 3 + Math.floor(Math.random() * 5);
        for(let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const distance = 100 + Math.random() * 100;
            const position = new THREE.Vector3(
                playerDrone.mesh.position.x + Math.cos(angle) * distance,
                50 + Math.random() * 100,
                playerDrone.mesh.position.z + Math.sin(angle) * distance
            );
            enemies.push(new EnemyDrone(position));
        }
        showModeIndicator(`‚öîÔ∏è ${count} ENNEMIS APPARUS!`);
    }

    function toggleCamera() {
        cameraMode = (cameraMode + 1) % 3;
        const modes = ['3√®me Personne', 'FPS', 'Vue du Dessus'];
        document.getElementById('cameraBtn').textContent = modes[cameraMode];
    }

    function teleportRandom() {
        if(!playerDrone) return;

        const range = 5000;
        playerDrone.mesh.position.set(
            (Math.random() - 0.5) * range,
            100,
            (Math.random() - 0.5) * range
        );
        playerDrone.velocity.set(0, 0, 0);
        updateChunks();
        showModeIndicator('üåç T√âL√âPORTATION!');
    }

    // Level Management Functions (declare before use)
    function showModeIndicator(text) {
        const indicator = document.createElement('div');
        indicator.className = 'mode-indicator';
        indicator.textContent = text;
        indicator.style.color = mode === 'combat' ? '#ff6b6b' : '#4facfe';
        document.body.appendChild(indicator);
        setTimeout(() => indicator.remove(), 2000);
    }

    function updateProgress() {
        if(currentLevel === 1) {
            document.getElementById('progress').textContent = currentCheckpoint;
        } else if(currentLevel === 2) {
            document.getElementById('progress').textContent = Math.min(stats.kills, 5);
        }
    }

    function updateTimer() {
        if(currentLevel > 0 && !levelComplete) {
            const elapsed = Math.floor((Date.now() - levelStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    function updateCamera() {
        if(!playerDrone) return;

        switch(cameraMode) {
            case 0:
                const offset = new THREE.Vector3(0, 50, 100);
                offset.applyQuaternion(playerDrone.mesh.quaternion);
                camera.position.lerp(
                    playerDrone.mesh.position.clone().add(offset),
                    0.1
                );
                camera.lookAt(playerDrone.mesh.position);
                break;
            case 1:
                camera.position.copy(playerDrone.mesh.position);
                camera.position.y += 5;
                const lookDir = new THREE.Vector3(0, 0, -100);
                lookDir.applyQuaternion(playerDrone.mesh.quaternion);
                camera.lookAt(playerDrone.mesh.position.clone().add(lookDir));
                break;
            case 2:
                camera.position.set(
                    playerDrone.mesh.position.x,
                    playerDrone.mesh.position.y + 200,
                    playerDrone.mesh.position.z + 50
                );
                camera.lookAt(playerDrone.mesh.position);
                break;
        }
    }

    function createExplosion(position, color, count) {
        for(let i = 0; i < count; i++) {
            const particle = new THREE.Mesh(
                new THREE.TetrahedronGeometry(2),
                new THREE.MeshBasicMaterial({ color })
            );
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                Math.random() * 10,
                (Math.random() - 0.5) * 10
            );
            particle.life = 30;
            scene.add(particle);
            particles.push(particle);
        }
    }

    function createMuzzleFlash(position) {
        const flash = new THREE.PointLight(0xffff00, 2, 50);
        flash.position.copy(position);
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 50);
    }

    function updateRadar() {
        if(!playerDrone) return;

        const canvas = document.getElementById('radarCanvas');
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, 200, 200);

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(100, 0);
        ctx.lineTo(100, 200);
        ctx.moveTo(0, 100);
        ctx.lineTo(200, 100);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(100, 100, 50, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(100, 100, 90, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = '#4facfe';
        ctx.fillRect(98, 98, 4, 4);

        enemies.forEach(enemy => {
            const dx = (enemy.mesh.position.x - playerDrone.mesh.position.x) / 5;
            const dz = (enemy.mesh.position.z - playerDrone.mesh.position.z) / 5;

            if(Math.abs(dx) < 100 && Math.abs(dz) < 100) {
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(100 + dx - 2, 100 + dz - 2, 4, 4);
            }
        });

        ctx.strokeStyle = '#00ff00';
        ctx.beginPath();
        ctx.moveTo(100, 100);
        const angle = -playerDrone.mesh.rotation.y;
        ctx.lineTo(100 + Math.sin(angle) * 20, 100 - Math.cos(angle) * 20);
        ctx.stroke();
    }

    let frameCount = 0;
    function performCleanup() {
        frameCount++;

        if(frameCount % 600 === 0) {
            const objectsToRemove = [];
            scene.traverse((child) => {
                if(child.userData.shouldRemove) {
                    objectsToRemove.push(child);
                }
            });

            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });

            if(window.gc) window.gc();
        }

        if(frameCount % 3 === 0) {
            updateRadar();
        }
    }

    // Initialize city and start with level menu
    playerDrone = new PlayerDrone();
    generateCity();

    // Show initial instructions
    setTimeout(() => {
        showModeIndicator("üéÆ Choisissez un niveau pour commencer!");
    }, 1000);

    // Input handling handling
    window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;

        if(e.key === 'Tab') {
            e.preventDefault();
            toggleMode();
        }
        if(e.key.toLowerCase() === 'c') toggleCamera();
        if(e.key.toLowerCase() === 'e') playerDrone.turbo = true;
    });

    window.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
        if(e.key.toLowerCase() === 'e') playerDrone.turbo = false;
    });

    window.addEventListener('mousemove', e => {
        mouse.x = (e.clientX / innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / innerHeight) * 2 + 1;
    });

    window.addEventListener('click', () => {
        if(mode === 'combat') {
            playerDrone.shoot();
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    // Mobile controls
    let touches = {};
    let joysticks = {
        left: { active: false, x: 0, y: 0 },
        right: { active: false, x: 0, y: 0 }
    };

    // Mobile joystick handling
    function setupMobileControls() {
        const leftJoystick = document.getElementById('leftJoystick');
        const rightJoystick = document.getElementById('rightJoystick');
        const leftKnob = document.getElementById('leftKnob');
        const rightKnob = document.getElementById('rightKnob');

        // Left joystick (movement)
        leftJoystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = leftJoystick.getBoundingClientRect();
            joysticks.left.active = true;
            updateJoystick('left', touch, rect, leftKnob);
        });

        leftJoystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joysticks.left.active) return;
            const touch = e.touches[0];
            const rect = leftJoystick.getBoundingClientRect();
            updateJoystick('left', touch, rect, leftKnob);
        });

        leftJoystick.addEventListener('touchend', (e) => {
            e.preventDefault();
            joysticks.left.active = false;
            joysticks.left.x = 0;
            joysticks.left.y = 0;
            leftKnob.style.transform = 'translate(-50%, -50%)';
            keys['arrowup'] = false;
            keys['arrowdown'] = false;
        });

        // Right joystick (rotation)
        rightJoystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = rightJoystick.getBoundingClientRect();
            joysticks.right.active = true;
            updateJoystick('right', touch, rect, rightKnob);
        });

        rightJoystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joysticks.right.active) return;
            const touch = e.touches[0];
            const rect = rightJoystick.getBoundingClientRect();
            updateJoystick('right', touch, rect, rightKnob);
        });

        rightJoystick.addEventListener('touchend', (e) => {
            e.preventDefault();
            joysticks.right.active = false;
            joysticks.right.x = 0;
            joysticks.right.y = 0;
            rightKnob.style.transform = 'translate(-50%, -50%)';
            keys['arrowleft'] = false;
            keys['arrowright'] = false;
        });

        // Altitude buttons
        const upButton = document.getElementById('upButton');
        const downButton = document.getElementById('downButton');
        const fireButton = document.getElementById('fireButton');

        upButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys[' '] = true;
        });

        upButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[' '] = false;
        });

        downButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['shift'] = true;
        });

        downButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['shift'] = false;
        });

        fireButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(mode === 'combat' && playerDrone) {
                playerDrone.shoot();
            }
        });
    }

    function updateJoystick(side, touch, rect, knob) {
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const x = touch.clientX - rect.left - centerX;
        const y = touch.clientY - rect.top - centerY;

        const distance = Math.min(40, Math.sqrt(x * x + y * y));
        const angle = Math.atan2(y, x);

        const knobX = Math.cos(angle) * distance;
        const knobY = Math.sin(angle) * distance;

        knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

        if (side === 'left') {
            // Movement control
            keys['arrowup'] = y < -20;
            keys['arrowdown'] = y > 20;
            joysticks.left.x = x / 40;
            joysticks.left.y = y / 40;
        } else {
            // Rotation control
            keys['arrowleft'] = x < -20;
            keys['arrowright'] = x > 20;
            joysticks.right.x = x / 40;
        }
    }

    // Initialize mobile controls
    setupMobileControls();

    // Detect mobile device
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if(isMobile) {
        document.getElementById('mobileControls').style.display = 'block';
    }

    // Main loop
    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;

        sky.material.uniforms.time.value = time;

        scene.children.forEach(child => {
            if(child.userData.isCloud) {
                child.position.x += child.userData.velocity;
                if(child.position.x > 2000) child.position.x = -2000;
            }
        });

        playerDrone.update();

        const dayProgress = (Math.sin(time * 0.05) + 1) / 2;
        sun.intensity = 0.4 + dayProgress * 0.6;
        sun.color.setHSL(0.1, 0.5, 0.5 + dayProgress * 0.3);
        ambientLight.intensity = 0.2 + dayProgress * 0.2;

        const heightFactor = Math.min(playerDrone.mesh.position.y / 400, 1);
        scene.fog.density = 0.0006 - heightFactor * 0.0003;

        // No more chunk updates - city is pre-generated

        enemies = enemies.filter(enemy => {
            enemy.update();
            return enemy.health > 0;
        });

        // Animate checkpoints
        checkpoints.forEach(checkpoint => {
            if(checkpoint.userData && checkpoint.userData.animate) {
                checkpoint.userData.animate();
            }
        });

        // Check level objectives only if function exists and level is active
        if(currentLevel > 0) {
            checkLevelObjectives();
        }
        updateTimer();

        bullets = bullets.filter(bullet => {
            bullet.position.add(bullet.velocity);
            bullet.life--;

            if(bullet.life % 3 === 0) {
                const trail = new THREE.Mesh(
                    getCachedGeometry('sphere', 0.5, 3, 2),
                    getCachedMaterial('basic', {
                        color: bullet.material.color,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                trail.position.copy(bullet.position);
                scene.add(trail);
                setTimeout(() => {
                    scene.remove(trail);
                    if(trail.geometry && !Object.values(geometryCache.sphere).includes(trail.geometry)) {
                        trail.geometry.dispose();
                    }
                }, 100);
            }

            if(bullet.isPlayer) {
                enemies.forEach(enemy => {
                    if(bullet.position.distanceTo(enemy.mesh.position) < 15) {
                        if(enemy.takeDamage(25)) {
                            enemies = enemies.filter(e => e !== enemy);
                        }
                        bullet.life = 0;
                    }
                });
            } else {
                if(bullet.position.distanceTo(playerDrone.mesh.position) < 15) {
                    playerDrone.takeDamage(10);
                    bullet.life = 0;
                }
            }

            if(bullet.life <= 0) {
                scene.remove(bullet);
                return false;
            }
            return true;
        });

        particles = particles.filter(particle => {
            particle.position.add(particle.velocity);
            particle.velocity.y -= 0.5;
            particle.life--;
            particle.rotation.x += 0.2;
            particle.rotation.y += 0.2;
            particle.material.opacity = particle.life / 40;

            if(particle.life <= 0) {
                scene.remove(particle);
                return false;
            }
            return true;
        });

        updateCamera();
        performCleanup();
        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>