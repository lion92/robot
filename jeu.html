<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Battle 3D - IA Adaptative Avanc√©e</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            background: #000;
            cursor: crosshair;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            z-index: 100;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        /* Camera Controls */
        .camera-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 15px;
            z-index: 100;
            min-width: 200px;
            user-select: none;
        }

        .camera-title {
            color: #00ff00;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }

        .camera-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .camera-btn:hover {
            background: rgba(0, 255, 0, 0.4);
            transform: translateX(-2px);
        }

        .camera-btn.active {
            background: rgba(0, 255, 0, 0.6);
            color: #000;
        }

        .target-info {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #00ff00;
            font-size: 12px;
            color: #fff;
        }

        .hud-content {
            display: flex;
            gap: 40px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
            color: #fff;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        /* AI Training Panel */
        .ai-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 15px;
            padding: 20px;
            width: 300px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .ai-title {
            color: #ff00ff;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
        }

        .ai-stat {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 0, 255, 0.1);
            border-radius: 8px;
            font-size: 12px;
            color: #fff;
        }

        .ai-progress {
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            transition: width 0.3s;
        }

        /* Battle Info */
        .battle-info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            z-index: 100;
            text-align: center;
            color: #ffd700;
        }

        /* Winner */
        .winner-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .loading {
            display: none;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="loading" id="loading">Initialisation du syst√®me 3D...</div>

<div class="hud" id="hud" style="display: none;">
    <div class="hud-content">
        <div class="stat-item">
            <div class="stat-value" id="battleNum">1</div>
            <div class="stat-label">Bataille</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="aliveCount">0</div>
            <div class="stat-label">Survivants</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timer">0:00</div>
            <div class="stat-label">Temps</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="totalShots">0</div>
            <div class="stat-label">Tirs</div>
        </div>
    </div>
</div>

<div class="ai-panel" id="aiPanel" style="display: none;">
    <div class="ai-title">üß† IA NEURONALE ADAPTATIVE</div>
    <div id="aiStats"></div>
</div>

<div class="camera-controls">
    <div class="camera-title">üìπ CAM√âRA</div>
    <button class="camera-btn active" id="cameraOrbit" onclick="setCameraMode('orbit')">Vue Orbitale</button>
    <button class="camera-btn" id="cameraFollow" onclick="setCameraMode('follow')">Suivre Combat</button>
    <button class="camera-btn" id="cameraFPV" onclick="setCameraMode('fpv')">Vue Cockpit</button>
    <button class="camera-btn" id="cameraCinematic" onclick="setCameraMode('cinematic')">Cin√©matique</button>
    <button class="camera-btn" id="cameraFree" onclick="setCameraMode('free')">üéÆ Libre 3D</button>
    <div class="target-info" id="targetInfo" style="display: none;">
        <div>Cible: <span id="targetName">-</span></div>
        <div>Sant√©: <span id="targetHealth">-</span></div>
    </div>
    <div class="target-info" id="freeControls" style="display: none;">
        <div style="font-size: 11px; line-height: 1.4;">
            <strong>Contr√¥les:</strong><br>
            ZQSD/WASD - D√©placer<br>
            Souris - Regarder<br>
            Shift - Vitesse x2<br>
            Espace/Ctrl - Haut/Bas
        </div>
    </div>
</div>

<div class="battle-info" id="battleInfo" style="display: none;">
    ‚öîÔ∏è Bataille spatiale en cours - Mode IA Avanc√©e Active
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Configuration
    const CONFIG = {
        SHIPS: 8,
        ARENA_SIZE: 500,
        SHIP_SPEED: 2,
        LASER_SPEED: 10,
        SHIP_HP: 100,
        DAMAGE: 15,
        AI_LEARNING_RATE: 0.1,
        NEURAL_LAYERS: [12, 24, 16, 8], // R√©seau de neurones profond
        BATTLE_TIME: 300,
        COLLISION_DAMAGE: 10,
        MISSILE_SPEED: 6,
        MISSILE_DAMAGE: 30,
        SHIELD_REGEN_RATE: 0.5,
        POWERUP_SPAWN_RATE: 0.002
    };

    // Ship configurations with AI personalities
    const SHIP_CONFIGS = [
        { name: 'PHOENIX', color: 0xff0000, emissive: 0xff0000, personality: 'aggressive' },
        { name: 'NEBULA', color: 0x00ffff, emissive: 0x00ffff, personality: 'defensive' },
        { name: 'QUANTUM', color: 0xff00ff, emissive: 0xff00ff, personality: 'balanced' },
        { name: 'STELLAR', color: 0xffd700, emissive: 0xffd700, personality: 'sniper' },
        { name: 'VORTEX', color: 0x00ff00, emissive: 0x00ff00, personality: 'flanker' },
        { name: 'COSMIC', color: 0x9400d3, emissive: 0x9400d3, personality: 'hunter' },
        { name: 'AURORA', color: 0xff69b4, emissive: 0xff69b4, personality: 'tactical' },
        { name: 'ECLIPSE', color: 0x1e90ff, emissive: 0x1e90ff, personality: 'adaptive' }
    ];

    // Global variables
    let scene, camera, renderer;
    let ships = [];
    let lasers = [];
    let missiles = [];
    let particles = [];
    let explosions = [];
    let powerups = [];
    let asteroids = [];
    let battleNumber = 0;
    let timer = CONFIG.BATTLE_TIME;
    let gameState = 'loading';
    let stats = { totalShots: 0, collisions: 0 };

    // Camera system
    let cameraMode = 'orbit';
    let cameraTarget = null;
    let cameraOffset = new THREE.Vector3();
    let cameraShake = 0;

    // Free camera controls
    let freeCameraPos = new THREE.Vector3(0, 200, 400);
    let freeCameraTarget = new THREE.Vector3(0, 0, 0);
    let mouseDown = false;
    let mouseX = 0, mouseY = 0;
    let keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        up: false,
        down: false,
        shift: false
    };

    // Neural Network for AI
    class NeuralNetwork {
        constructor(layers) {
            this.layers = layers;
            this.weights = [];
            this.biases = [];

            // Initialize weights and biases
            for (let i = 0; i < layers.length - 1; i++) {
                this.weights.push(this.createMatrix(layers[i + 1], layers[i]));
                this.biases.push(this.createMatrix(layers[i + 1], 1));
            }
        }

        createMatrix(rows, cols) {
            const matrix = [];
            for (let i = 0; i < rows; i++) {
                matrix[i] = [];
                for (let j = 0; j < cols; j++) {
                    matrix[i][j] = Math.random() * 2 - 1; // Random between -1 and 1
                }
            }
            return matrix;
        }

        sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        predict(inputs) {
            let current = inputs;

            for (let i = 0; i < this.weights.length; i++) {
                const weighted = this.matrixMultiply(this.weights[i], current);
                const biased = this.matrixAdd(weighted, this.biases[i]);
                current = biased.map(x => this.sigmoid(x[0]));
            }

            return current;
        }

        matrixMultiply(a, b) {
            const result = [];
            for (let i = 0; i < a.length; i++) {
                result[i] = [0];
                for (let j = 0; j < a[i].length; j++) {
                    result[i][0] += a[i][j] * b[j];
                }
            }
            return result;
        }

        matrixAdd(a, b) {
            return a.map((row, i) => [row[0] + b[i][0]]);
        }

        mutate(rate) {
            // Mutation for evolution
            for (let i = 0; i < this.weights.length; i++) {
                for (let j = 0; j < this.weights[i].length; j++) {
                    for (let k = 0; k < this.weights[i][j].length; k++) {
                        if (Math.random() < rate) {
                            this.weights[i][j][k] += (Math.random() * 2 - 1) * 0.5;
                        }
                    }
                }
            }
        }
    }

    // Ship class with advanced AI
    class Ship {
        constructor(config, index) {
            this.config = config;
            this.name = config.name;
            this.health = CONFIG.SHIP_HP;
            this.maxHealth = CONFIG.SHIP_HP;
            this.shield = 50;
            this.maxShield = 50;
            this.alive = true;
            this.shots = 0;
            this.hits = 0;
            this.lastShot = 0;
            this.lastMissile = 0;
            this.brain = new NeuralNetwork(CONFIG.NEURAL_LAYERS);
            this.memory = []; // For learning
            this.score = 0;
            this.generation = 1;
            this.powerupType = null;
            this.powerupTime = 0;

            // Create 3D ship model
            this.createModel();

            // Position
            const angle = (Math.PI * 2 * index) / CONFIG.SHIPS;
            this.mesh.position.x = Math.cos(angle) * CONFIG.ARENA_SIZE * 0.7;
            this.mesh.position.z = Math.sin(angle) * CONFIG.ARENA_SIZE * 0.7;
            this.mesh.position.y = Math.random() * 50 - 25;

            // Physics
            this.velocity = new THREE.Vector3();
            this.angularVelocity = 0;
            this.target = null;
            this.dodgeTarget = null;

            // Combat stats
            this.combo = 0;
            this.lastHitTime = 0;

            // AI parameters based on personality
            this.setupPersonality();
        }

        createModel() {
            const group = new THREE.Group();

            // Main body - sleek fighter design
            const bodyGeometry = new THREE.ConeGeometry(3, 15, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: this.config.color,
                emissive: this.config.emissive,
                emissiveIntensity: 0.5,
                specular: 0xffffff,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            group.add(body);

            // Wings
            const wingGeometry = new THREE.BoxGeometry(20, 0.5, 5);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: this.config.color,
                emissive: this.config.emissive,
                emissiveIntensity: 0.3
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.z = -2;
            group.add(wings);

            // Engine glow
            const engineGeometry = new THREE.SphereGeometry(2, 8, 8);
            const engineMaterial = new THREE.MeshBasicMaterial({
                color: this.config.emissive,
                transparent: true,
                opacity: 0.8
            });
            const engine = new THREE.Mesh(engineGeometry, engineMaterial);
            engine.position.z = -7;
            group.add(engine);

            // Shield
            const shieldGeometry = new THREE.SphereGeometry(12, 16, 16);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0,
                wireframe: true
            });
            this.shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            group.add(this.shield);

            this.mesh = group;
            this.size = 15; // Collision radius
            this.shieldMesh = this.shield; // Reference for shield updates
            this.angularVelocity = 0;
            scene.add(this.mesh);
        }

        setupPersonality() {
            switch(this.config.personality) {
                case 'aggressive':
                    this.aggressiveness = 0.9;
                    this.caution = 0.3;
                    this.accuracy = 0.7;
                    break;

                case 'free':
                    // Free camera movement
                    const moveSpeed = (keys.shift ? 10 : 5);
                    const lookSpeed = 0.002;

                    // Get camera direction vectors
                    const forward = new THREE.Vector3();
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3(0, 1, 0);

                    camera.getWorldDirection(forward);
                    right.crossVectors(forward, up).normalize();

                    // Movement
                    if (keys.forward || keys.w) {
                        freeCameraPos.add(forward.multiplyScalar(moveSpeed));
                    }
                    if (keys.backward || keys.s) {
                        freeCameraPos.add(forward.multiplyScalar(-moveSpeed));
                    }
                    if (keys.left || keys.a) {
                        freeCameraPos.add(right.multiplyScalar(-moveSpeed));
                    }
                    if (keys.right || keys.d) {
                        freeCameraPos.add(right.multiplyScalar(moveSpeed));
                    }
                    if (keys.up || keys.space) {
                        freeCameraPos.y += moveSpeed;
                    }
                    if (keys.down || keys.ctrl) {
                        freeCameraPos.y -= moveSpeed;
                    }

                    // Apply position
                    camera.position.copy(freeCameraPos);

                    // Look at target (controlled by mouse)
                    const lookAt = freeCameraPos.clone().add(freeCameraTarget);
                    camera.lookAt(lookAt);

                    break;
                case 'defensive':
                    this.aggressiveness = 0.3;
                    this.caution = 0.9;
                    this.accuracy = 0.6;
                    break;
                case 'sniper':
                    this.aggressiveness = 0.5;
                    this.caution = 0.6;
                    this.accuracy = 0.95;
                    break;
                case 'flanker':
                    this.aggressiveness = 0.7;
                    this.caution = 0.5;
                    this.accuracy = 0.6;
                    break;
                default:
                    this.aggressiveness = 0.6;
                    this.caution = 0.6;
                    this.accuracy = 0.7;
            }
        }

        update() {
            if (!this.alive) return;

            // Regenerate shields
            if (this.shield < this.maxShield) {
                this.shield = Math.min(this.maxShield, this.shield + CONFIG.SHIELD_REGEN_RATE);
            }

            // Update powerup
            if (this.powerupType && Date.now() - this.powerupTime > 10000) {
                this.powerupType = null;
            }

            // Get sensor data for neural network
            const inputs = this.getSensorData();

            // Neural network decision
            const outputs = this.brain.predict(inputs);

            // Interpret outputs
            const moveX = (outputs[0] - 0.5) * 2;
            const moveY = (outputs[1] - 0.5) * 2;
            const moveZ = (outputs[2] - 0.5) * 2;
            const shouldShoot = outputs[3] > 0.7;
            const shouldMissile = outputs[4] > 0.85;
            const shouldDodge = outputs[5] > 0.6;
            const targetIndex = Math.floor(outputs[6] * ships.length);

            // Advanced movement
            if (shouldDodge && this.dodgeTarget) {
                // Evasive maneuvers
                const dodgeDir = new THREE.Vector3();
                dodgeDir.subVectors(this.mesh.position, this.dodgeTarget);
                dodgeDir.normalize();
                this.velocity.add(dodgeDir.multiplyScalar(0.8));

                // Barrel roll
                this.angularVelocity += (Math.random() - 0.5) * 0.2;
            } else {
                // Normal movement
                this.velocity.x += moveX * 0.5 * (this.powerupType === 'speed' ? 1.5 : 1);
                this.velocity.y += moveY * 0.3;
                this.velocity.z += moveZ * 0.5 * (this.powerupType === 'speed' ? 1.5 : 1);
            }

            // Apply rotation
            this.mesh.rotation.z += this.angularVelocity;
            this.angularVelocity *= 0.9;

            // Limit velocity
            const maxSpeed = CONFIG.SHIP_SPEED * (1 + this.aggressiveness * 0.5);
            if (this.velocity.length() > maxSpeed) {
                this.velocity.normalize().multiplyScalar(maxSpeed);
            }

            // Apply velocity with damping
            this.mesh.position.add(this.velocity);
            this.velocity.multiplyScalar(0.98);

            // Check ship collisions
            this.checkShipCollisions();

            // Boundary check with bounce
            const boundary = CONFIG.ARENA_SIZE;
            ['x', 'y', 'z'].forEach(axis => {
                if (Math.abs(this.mesh.position[axis]) > boundary) {
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * boundary;
                    this.velocity[axis] *= -0.8;
                    this.takeDamage(5); // Boundary damage
                    createSparks(this.mesh.position, this.config.color);
                }
            });

            // Targeting
            const potentialTargets = ships.filter(s => s !== this && s.alive);
            if (potentialTargets.length > 0 && targetIndex < potentialTargets.length) {
                this.target = potentialTargets[targetIndex];
            }

            // Look at target with smooth rotation
            if (this.target) {
                const direction = new THREE.Vector3();
                direction.subVectors(this.target.mesh.position, this.mesh.position);
                direction.normalize();

                const targetQuaternion = new THREE.Quaternion();
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.lookAt(this.mesh.position, this.target.mesh.position, new THREE.Vector3(0, 1, 0));
                targetQuaternion.setFromRotationMatrix(rotationMatrix);

                this.mesh.quaternion.slerp(targetQuaternion, 0.1);

                // Combat decisions
                const distance = this.mesh.position.distanceTo(this.target.mesh.position);

                // Laser shooting
                if (shouldShoot && Date.now() - this.lastShot > 300) {
                    this.shoot();
                }

                // Missile shooting
                if (shouldMissile && Date.now() - this.lastMissile > 2000 && distance < 300) {
                    this.shootMissile();
                }
            }

            // Engine effects
            this.updateEngineEffects();

            // Update shields visual
            this.shieldMesh.material.opacity = this.shield > 0 ? this.shield / this.maxShield * 0.2 : 0;

            // Update AI stats display
            this.updateAIDisplay();
        }

        checkShipCollisions() {
            ships.forEach(other => {
                if (other !== this && other.alive) {
                    const distance = this.mesh.position.distanceTo(other.mesh.position);
                    const collisionDistance = this.size + other.size;

                    if (distance < collisionDistance) {
                        // Collision detected!
                        stats.collisions++;

                        // Calculate collision response
                        const normal = new THREE.Vector3();
                        normal.subVectors(this.mesh.position, other.mesh.position);
                        normal.normalize();

                        // Separate ships
                        const overlap = collisionDistance - distance;
                        this.mesh.position.add(normal.clone().multiplyScalar(overlap * 0.5));
                        other.mesh.position.add(normal.clone().multiplyScalar(-overlap * 0.5));

                        // Apply collision forces
                        const relativeVelocity = new THREE.Vector3();
                        relativeVelocity.subVectors(this.velocity, other.velocity);
                        const speed = relativeVelocity.dot(normal);

                        if (speed < 0) return; // Moving away

                        // Elastic collision
                        const impulse = 2 * speed / 2; // Equal mass assumed
                        this.velocity.sub(normal.clone().multiplyScalar(impulse));
                        other.velocity.add(normal.clone().multiplyScalar(impulse));

                        // Damage from collision
                        const collisionDamage = Math.abs(speed) * CONFIG.COLLISION_DAMAGE;
                        this.takeDamage(collisionDamage);
                        other.takeDamage(collisionDamage);

                        // Collision effects
                        const collisionPoint = new THREE.Vector3();
                        collisionPoint.lerpVectors(this.mesh.position, other.mesh.position, 0.5);
                        createCollisionEffect(collisionPoint, this.config.color, other.config.color);

                        // Add spin
                        this.angularVelocity += (Math.random() - 0.5) * 0.3;
                        other.angularVelocity += (Math.random() - 0.5) * 0.3;
                    }
                }
            });
        }

        updateEngineEffects() {
            const engine = this.mesh.children[2];
            const speed = this.velocity.length();
            engine.scale.setScalar(1 + speed * 0.1 + Math.sin(Date.now() * 0.01) * 0.2);

            // Thruster particles
            if (speed > 1 && Math.random() < 0.3) {
                const pos = this.mesh.position.clone();
                const backward = new THREE.Vector3(0, 0, -1);
                backward.applyQuaternion(this.mesh.quaternion);
                pos.add(backward.multiplyScalar(10));

                createThrusterParticle(pos, backward.multiplyScalar(-2), this.config.color);
            }
        }

        getSensorData() {
            const inputs = [];

            // Own position (normalized)
            inputs.push(this.mesh.position.x / CONFIG.ARENA_SIZE);
            inputs.push(this.mesh.position.y / CONFIG.ARENA_SIZE);
            inputs.push(this.mesh.position.z / CONFIG.ARENA_SIZE);

            // Own health and shield
            inputs.push(this.health / this.maxHealth);
            inputs.push(this.shield / this.maxShield);

            // Velocity
            inputs.push(this.velocity.x / CONFIG.SHIP_SPEED);
            inputs.push(this.velocity.y / CONFIG.SHIP_SPEED);
            inputs.push(this.velocity.z / CONFIG.SHIP_SPEED);

            // Nearest enemy data
            let nearestEnemy = null;
            let minDist = Infinity;

            ships.forEach(ship => {
                if (ship !== this && ship.alive) {
                    const dist = this.mesh.position.distanceTo(ship.mesh.position);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestEnemy = ship;
                    }
                }
            });

            if (nearestEnemy) {
                const relativePos = new THREE.Vector3();
                relativePos.subVectors(nearestEnemy.mesh.position, this.mesh.position);
                inputs.push(relativePos.x / CONFIG.ARENA_SIZE);
                inputs.push(relativePos.y / CONFIG.ARENA_SIZE);
                inputs.push(relativePos.z / CONFIG.ARENA_SIZE);
                inputs.push(minDist / CONFIG.ARENA_SIZE);
            } else {
                inputs.push(0, 0, 0, 1);
            }

            return inputs;
        }

        shoot() {
            if (!this.target || !this.alive) return;

            this.lastShot = Date.now();
            this.shots++;
            stats.totalShots++;

            // Multiple shots with powerup
            const shotCount = this.powerupType === 'multishot' ? 3 : 1;

            for (let i = 0; i < shotCount; i++) {
                // Calculate lead prediction
                const distance = this.mesh.position.distanceTo(this.target.mesh.position);
                const timeToTarget = distance / CONFIG.LASER_SPEED;
                const predictedPos = new THREE.Vector3();
                predictedPos.copy(this.target.mesh.position);
                predictedPos.add(this.target.velocity.clone().multiplyScalar(timeToTarget));

                // Add accuracy variance
                const spread = (1 - this.accuracy) * 0.1;
                predictedPos.x += (Math.random() - 0.5) * spread * distance;
                predictedPos.y += (Math.random() - 0.5) * spread * distance;
                predictedPos.z += (Math.random() - 0.5) * spread * distance;

                // Shot spread for multishot
                if (shotCount > 1) {
                    const spreadAngle = (i - 1) * 0.1;
                    predictedPos.x += Math.cos(spreadAngle) * 10;
                    predictedPos.z += Math.sin(spreadAngle) * 10;
                }

                // Create laser
                const direction = new THREE.Vector3();
                direction.subVectors(predictedPos, this.mesh.position);
                direction.normalize();

                const laser = new Laser(this.mesh.position, direction, this.config.color, this);
                lasers.push(laser);
            }

            // Muzzle flash
            createMuzzleFlash(this.mesh.position, this.config.color);
        }

        shootMissile() {
            if (!this.target || !this.alive) return;

            this.lastMissile = Date.now();

            const missile = new Missile(this.mesh.position, this.target, this.config.color, this);
            missiles.push(missile);

            // Launch effect
            createMissileTrail(this.mesh.position, this.config.color);
        }

        takeDamage(amount) {
            // Shield absorbs damage first
            if (this.shield > 0) {
                const shieldDamage = Math.min(this.shield, amount);
                this.shield -= shieldDamage;
                amount -= shieldDamage;

                // Shield effect
                this.shieldMesh.material.opacity = 0.8;
                this.shieldMesh.material.color.setHex(0xff0000);
                setTimeout(() => {
                    this.shieldMesh.material.color.setHex(0x00ffff);
                }, 100);
            }

            // Apply remaining damage to health
            if (amount > 0) {
                this.health -= amount;

                // Damage feedback
                createDamageNumber(this.mesh.position, Math.round(amount), this.config.color);
            }

            // Camera shake on hit
            if (this === cameraTarget && (cameraMode === 'follow' || cameraMode === 'fpv')) {
                cameraShake = 5;
            }

            if (this.health <= 0) {
                this.alive = false;
                this.destroy();
            }
        }

        destroy() {
            createExplosion(this.mesh.position, this.config.color);
            scene.remove(this.mesh);

            // Find new camera target if this was it
            if (this === cameraTarget) {
                setTimeout(() => findBestCameraTarget(), 1000);
            }

            // Big camera shake for explosions
            if (camera.position.distanceTo(this.mesh.position) < 200) {
                cameraShake = 10;
            }
        }

        updateAIDisplay() {
            // Update score based on performance
            this.score = this.hits * 100 + this.shots * 10 - (CONFIG.SHIP_HP - this.health);
        }
    }

    // Missile class
    class Missile {
        constructor(position, target, color, owner) {
            this.owner = owner;
            this.target = target;
            this.position = position.clone();
            this.velocity = new THREE.Vector3();
            this.speed = CONFIG.MISSILE_SPEED;
            this.color = color;
            this.lifeTime = 5000;
            this.birthTime = Date.now();

            // Create missile mesh
            const geometry = new THREE.ConeGeometry(0.5, 4, 8);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);
            scene.add(this.mesh);

            // Trail effect
            this.trail = [];
        }

        update() {
            // Check lifetime
            if (Date.now() - this.birthTime > this.lifeTime) {
                this.destroy();
                return false;
            }

            // Homing behavior
            if (this.target && this.target.alive) {
                const direction = new THREE.Vector3();
                direction.subVectors(this.target.mesh.position, this.mesh.position);
                direction.normalize();

                // Add acceleration towards target
                this.velocity.add(direction.multiplyScalar(0.5));

                // Limit speed
                if (this.velocity.length() > this.speed) {
                    this.velocity.normalize().multiplyScalar(this.speed);
                }
            }

            // Update position
            this.mesh.position.add(this.velocity);

            // Orient missile
            if (this.velocity.length() > 0) {
                this.mesh.lookAt(this.mesh.position.clone().add(this.velocity));
            }

            // Trail
            createMissileTrail(this.mesh.position, this.color);

            // Check collisions
            for (let ship of ships) {
                if (ship !== this.owner && ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < ship.size) {
                        ship.takeDamage(CONFIG.MISSILE_DAMAGE);
                        this.owner.hits++;
                        createExplosion(this.mesh.position, this.color);
                        this.destroy();
                        return false;
                    }
                }
            }

            // Boundary check
            if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                this.destroy();
                return false;
            }

            return true;
        }

        destroy() {
            scene.remove(this.mesh);
        }
    }

    // Enhanced effects
    function createCollisionEffect(position, color1, color2) {
        // Shockwave
        const geometry = new THREE.RingGeometry(1, 5, 32);
        const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const shockwave = new THREE.Mesh(geometry, material);
        shockwave.position.copy(position);
        shockwave.lookAt(camera.position);
        scene.add(shockwave);

        // Animate shockwave
        const animateShockwave = () => {
            shockwave.scale.multiplyScalar(1.2);
            shockwave.material.opacity *= 0.9;

            if (shockwave.material.opacity > 0.01) {
                requestAnimationFrame(animateShockwave);
            } else {
                scene.remove(shockwave);
            }
        };
        animateShockwave();

        // Sparks
        for (let i = 0; i < 20; i++) {
            const spark = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            createSpark(position, spark, Math.random() > 0.5 ? color1 : color2);
        }
    }

    function createSpark(position, velocity, color) {
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 2);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 1
        });
        const spark = new THREE.Mesh(geometry, material);
        spark.position.copy(position);
        scene.add(spark);

        const vel = velocity.clone();
        const animateSpark = () => {
            spark.position.add(vel);
            vel.multiplyScalar(0.95);
            spark.material.opacity *= 0.95;
            spark.rotation.x += 0.3;
            spark.rotation.y += 0.2;

            if (spark.material.opacity > 0.01) {
                requestAnimationFrame(animateSpark);
            } else {
                scene.remove(spark);
            }
        };
        animateSpark();
    }

    function createDamageNumber(position, damage, color) {
        // This would require text rendering in 3D, simplified for now
        const size = Math.min(damage / 10, 5);
        const geometry = new THREE.SphereGeometry(size, 8, 8);
        const material = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 1
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        sphere.position.y += 10;
        scene.add(sphere);

        const vel = new THREE.Vector3(0, 2, 0);
        const animateDamage = () => {
            sphere.position.add(vel);
            vel.y *= 0.9;
            sphere.material.opacity *= 0.95;

            if (sphere.material.opacity > 0.01) {
                requestAnimationFrame(animateDamage);
            } else {
                scene.remove(sphere);
            }
        };
        animateDamage();
    }

    function createThrusterParticle(position, velocity, color) {
        const geometry = new THREE.SphereGeometry(0.5, 4, 4);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8
        });
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);
        scene.add(particle);

        const vel = velocity.clone();
        const animateParticle = () => {
            particle.position.add(vel);
            particle.scale.multiplyScalar(0.95);
            particle.material.opacity *= 0.95;

            if (particle.material.opacity > 0.01) {
                requestAnimationFrame(animateParticle);
            } else {
                scene.remove(particle);
            }
        };
        animateParticle();
    }

    function createMissileTrail(position, color) {
        for (let i = 0; i < 3; i++) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            const pos = position.clone().add(offset);

            const geometry = new THREE.SphereGeometry(1, 4, 4);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const trail = new THREE.Mesh(geometry, material);
            trail.position.copy(pos);
            scene.add(trail);

            const animateTrail = () => {
                trail.scale.multiplyScalar(0.9);
                trail.material.opacity *= 0.9;

                if (trail.material.opacity > 0.01) {
                    requestAnimationFrame(animateTrail);
                } else {
                    scene.remove(trail);
                }
            };
            animateTrail();
        }
    }
    class Laser {
        constructor(position, direction, color, owner) {
            this.owner = owner;
            this.velocity = direction.multiplyScalar(CONFIG.LASER_SPEED);

            // Create laser mesh
            const geometry = new THREE.CylinderGeometry(0.2, 0.2, 10);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                emissive: color,
                transparent: true,
                opacity: 0.8
            });
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);

            // Orient laser
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            this.mesh.quaternion.copy(quaternion);

            scene.add(this.mesh);

            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(1);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
            this.glow.position.copy(position);
            scene.add(this.glow);
        }

        update() {
            this.mesh.position.add(this.velocity);
            this.glow.position.copy(this.mesh.position);

            // Check boundaries
            if (this.mesh.position.length() > CONFIG.ARENA_SIZE * 1.5) {
                this.destroy();
                return false;
            }

            // Check collisions
            for (let ship of ships) {
                if (ship !== this.owner && ship.alive) {
                    const distance = this.mesh.position.distanceTo(ship.mesh.position);
                    if (distance < 10) {
                        ship.takeDamage(CONFIG.DAMAGE);
                        this.owner.hits++;
                        createImpact(this.mesh.position, this.owner.config.color);
                        this.destroy();
                        return false;
                    }
                }
            }

            return true;
        }

        destroy() {
            scene.remove(this.mesh);
            scene.remove(this.glow);
        }
    }

    // Camera control functions
    window.setCameraMode = function(mode) {
        cameraMode = mode;

        // Update UI
        ['orbit', 'follow', 'fpv', 'cinematic', 'free'].forEach(m => {
            const btn = document.getElementById('camera' + m.charAt(0).toUpperCase() + m.slice(1));
            if (btn) btn.classList.remove('active');
        });
        const activeBtn = document.getElementById('camera' + mode.charAt(0).toUpperCase() + mode.slice(1));
        if (activeBtn) activeBtn.classList.add('active');

        // Show/hide info panels
        const targetInfo = document.getElementById('targetInfo');
        const freeControls = document.getElementById('freeControls');
        if (targetInfo) {
            targetInfo.style.display = (mode === 'follow' || mode === 'fpv') ? 'block' : 'none';
        }
        if (freeControls) {
            freeControls.style.display = mode === 'free' ? 'block' : 'none';
        }

        // Find initial target for follow modes
        if (mode === 'follow' || mode === 'fpv') {
            findBestCameraTarget();
        }

        // Initialize free camera position
        if (mode === 'free') {
            freeCameraPos.copy(camera.position);
            freeCameraTarget.set(0, 0, 0);
        }
    }

    function findBestCameraTarget() {
        const aliveShips = ships.filter(s => s.alive);
        if (aliveShips.length === 0) return;

        // Prioritize ships in combat
        const shipsInCombat = aliveShips.filter(s =>
            s.target && s.target.alive &&
            s.mesh.position.distanceTo(s.target.mesh.position) < 200
        );

        if (shipsInCombat.length > 0) {
            // Choose ship with most action (shots + hits)
            cameraTarget = shipsInCombat.reduce((best, ship) =>
                (ship.shots + ship.hits * 2) > (best.shots + best.hits * 2) ? ship : best
            );
        } else {
            // Random alive ship
            cameraTarget = aliveShips[Math.floor(Math.random() * aliveShips.length)];
        }

        updateTargetInfo();
    }

    function updateTargetInfo() {
        if (cameraTarget) {
            const nameEl = document.getElementById('targetName');
            const healthEl = document.getElementById('targetHealth');
            if (nameEl) {
                nameEl.textContent = cameraTarget.name;
                nameEl.style.color = `#${cameraTarget.config.color.toString(16).padStart(6, '0')}`;
            }
            if (healthEl) {
                healthEl.textContent = `${Math.round(cameraTarget.health)}/${cameraTarget.maxHealth}`;
            }
        }
    }

    function updateCamera() {
        if (!camera) return;

        const time = Date.now() * 0.0001;

        switch(cameraMode) {
            case 'orbit':
                // Rotating overview
                camera.position.x = Math.cos(time) * 400;
                camera.position.z = Math.sin(time) * 400;
                camera.position.y = 200 + Math.sin(time * 2) * 50;
                camera.lookAt(0, 0, 0);
                break;

            case 'follow':
                // Third person follow
                if (!cameraTarget || !cameraTarget.alive) {
                    findBestCameraTarget();
                }

                if (cameraTarget && cameraTarget.mesh) {
                    const distance = 100;
                    const height = 50;

                    // Smooth follow
                    const targetPos = cameraTarget.mesh.position.clone();
                    const direction = new THREE.Vector3(0, 0, 1);
                    direction.applyQuaternion(cameraTarget.mesh.quaternion);

                    const idealOffset = direction.multiplyScalar(-distance);
                    idealOffset.y = height;

                    cameraOffset.lerp(idealOffset, 0.1);

                    camera.position.copy(targetPos).add(cameraOffset);
                    camera.lookAt(targetPos);

                    updateTargetInfo();
                }
                break;

            case 'fpv':
                // First person view from cockpit
                if (!cameraTarget || !cameraTarget.alive) {
                    findBestCameraTarget();
                }

                if (cameraTarget && cameraTarget.mesh) {
                    const cockpitOffset = new THREE.Vector3(0, 5, 10);
                    cockpitOffset.applyQuaternion(cameraTarget.mesh.quaternion);

                    camera.position.copy(cameraTarget.mesh.position).add(cockpitOffset);

                    // Look forward
                    const lookTarget = cameraTarget.mesh.position.clone();
                    const forward = new THREE.Vector3(0, 0, 100);
                    forward.applyQuaternion(cameraTarget.mesh.quaternion);
                    lookTarget.add(forward);

                    camera.lookAt(lookTarget);

                    updateTargetInfo();
                }
                break;

            case 'cinematic':
                // Dynamic cinematic shots
                const cinematicTime = Date.now() * 0.0003;
                const shotDuration = 5000; // 5 seconds per shot
                const currentShot = Math.floor(Date.now() / shotDuration) % 4;

                switch(currentShot) {
                    case 0:
                        // Sweeping low angle
                        camera.position.x = Math.cos(cinematicTime) * 300;
                        camera.position.y = 30;
                        camera.position.z = Math.sin(cinematicTime) * 300;
                        camera.lookAt(0, 50, 0);
                        break;

                    case 1:
                        // Top down spiral
                        camera.position.x = Math.cos(cinematicTime * 2) * 200;
                        camera.position.y = 400;
                        camera.position.z = Math.sin(cinematicTime * 2) * 200;
                        camera.lookAt(0, 0, 0);
                        break;

                    case 2:
                        // Close flyby
                        if (!cameraTarget || !cameraTarget.alive) {
                            findBestCameraTarget();
                        }
                        if (cameraTarget && cameraTarget.mesh) {
                            const flybyOffset = new THREE.Vector3(
                                Math.cos(cinematicTime * 3) * 50,
                                20,
                                Math.sin(cinematicTime * 3) * 50
                            );
                            camera.position.copy(cameraTarget.mesh.position).add(flybyOffset);
                            camera.lookAt(cameraTarget.mesh.position);
                        }
                        break;

                    case 3:
                        // Wide establishing shot
                        camera.position.set(500, 300, 500);
                        camera.lookAt(0, 0, 0);
                        break;
                }
                break;
        }

        // Apply camera shake
        if (cameraShake > 0) {
            camera.position.x += (Math.random() - 0.5) * cameraShake;
            camera.position.y += (Math.random() - 0.5) * cameraShake;
            camera.position.z += (Math.random() - 0.5) * cameraShake;
            cameraShake *= 0.9;
        }
    }

    // Initialize Three.js
    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 100, 1000);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 200, 400);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -500;
        directionalLight.shadow.camera.right = 500;
        directionalLight.shadow.camera.top = 500;
        directionalLight.shadow.camera.bottom = -500;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 1000;
        scene.add(directionalLight);

        // Hemisphere light for sky/ground lighting
        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x3a5f3a, 0.6);
        scene.add(hemisphereLight);

        // Point lights for atmosphere
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff];
        colors.forEach((color, i) => {
            const light = new THREE.PointLight(color, 0.3, 300);
            const angle = (Math.PI * 2 * i) / colors.length;
            light.position.set(
                Math.cos(angle) * 200,
                50,
                Math.sin(angle) * 200
            );
            scene.add(light);
        });

        // Space environment
        createSpaceEnvironment();

        // Show UI
        document.getElementById('hud').style.display = 'block';
        document.getElementById('aiPanel').style.display = 'block';

        // Start
        startBattle();
        animate();
    }

    // Create space environment
    function createSpaceEnvironment() {
        // Sky dome with gradient
        const skyGeometry = new THREE.SphereGeometry(1500, 64, 64);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) },
                bottomColor: { value: new THREE.Color(0x000033) },
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
            fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        void main() {
          float h = normalize(vWorldPosition + offset).y;
          gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
        }
      `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Sun
        const sunGeometry = new THREE.SphereGeometry(50, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 2
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(800, 600, -400);
        scene.add(sun);

        // Sun glow
        const glowGeometry = new THREE.SphereGeometry(80, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffaa,
            transparent: true,
            opacity: 0.3
        });
        const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        sunGlow.position.copy(sun.position);
        scene.add(sunGlow);

        // Terrain
        const terrainSize = 2000;
        const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 100, 100);

        // Add terrain height variation
        const vertices = terrainGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const y = vertices[i + 1];
            const distance = Math.sqrt(x * x + y * y);

            // Mountains at edges
            if (distance > 600) {
                vertices[i + 2] = Math.sin(x * 0.01) * Math.cos(y * 0.01) * 100 + Math.random() * 50;
            } else {
                // Rolling hills in center
                vertices[i + 2] = Math.sin(x * 0.005) * Math.cos(y * 0.005) * 30 + Math.random() * 10;
            }
        }
        terrainGeometry.computeVertexNormals();

        const terrainMaterial = new THREE.MeshPhongMaterial({
            color: 0x3a5f3a,
            specular: 0x111111,
            shininess: 10
        });
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -200;
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Ocean
        const oceanGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 50, 50);
        const oceanMaterial = new THREE.MeshPhongMaterial({
            color: 0x006994,
            transparent: true,
            opacity: 0.8,
            specular: 0x00ffff,
            shininess: 100
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.y = -190;
        scene.add(ocean);

        // Animate ocean
        const animateOcean = () => {
            const time = Date.now() * 0.001;
            const vertices = oceanGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                vertices[i + 2] = Math.sin(x * 0.02 + time) * Math.cos(y * 0.02 + time) * 5;
            }
            oceanGeometry.attributes.position.needsUpdate = true;
            requestAnimationFrame(animateOcean);
        };
        animateOcean();

        // Clouds
        const cloudGroup = new THREE.Group();
        for (let i = 0; i < 20; i++) {
            const cloudGeometry = new THREE.SphereGeometry(
                50 + Math.random() * 100,
                8,
                6
            );
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6 + Math.random() * 0.2
            });
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);

            cloud.position.set(
                (Math.random() - 0.5) * 1500,
                200 + Math.random() * 300,
                (Math.random() - 0.5) * 1500
            );
            cloud.scale.x = 1 + Math.random();
            cloud.scale.y = 0.6 + Math.random() * 0.4;
            cloud.scale.z = 1 + Math.random();

            cloudGroup.add(cloud);
        }
        scene.add(cloudGroup);

        // Animate clouds
        const animateClouds = () => {
            cloudGroup.rotation.y += 0.0001;
            requestAnimationFrame(animateClouds);
        };
        animateClouds();

        // City/structures on ground
        const cityGroup = new THREE.Group();
        for (let i = 0; i < 30; i++) {
            const buildingHeight = 50 + Math.random() * 150;
            const buildingGeometry = new THREE.BoxGeometry(
                20 + Math.random() * 40,
                buildingHeight,
                20 + Math.random() * 40
            );
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(0.6, 0.1, 0.3 + Math.random() * 0.2),
                emissive: 0x111111,
                emissiveIntensity: 0.2
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

            const angle = Math.random() * Math.PI * 2;
            const distance = 300 + Math.random() * 200;
            building.position.set(
                Math.cos(angle) * distance,
                -200 + buildingHeight / 2,
                Math.sin(angle) * distance
            );
            building.castShadow = true;
            building.receiveShadow = true;

            // Windows lights
            if (Math.random() > 0.5) {
                const lightGeometry = new THREE.BoxGeometry(
                    building.geometry.parameters.width * 0.8,
                    building.geometry.parameters.height * 0.9,
                    building.geometry.parameters.depth * 0.8
                );
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff88,
                    transparent: true,
                    opacity: 0.3
                });
                const windowLight = new THREE.Mesh(lightGeometry, lightMaterial);
                building.add(windowLight);
            }

            cityGroup.add(building);
        }
        scene.add(cityGroup);

        // Floating islands
        for (let i = 0; i < 5; i++) {
            const islandGroup = new THREE.Group();

            // Island base
            const islandGeometry = new THREE.ConeGeometry(80, 100, 8);
            const islandMaterial = new THREE.MeshPhongMaterial({
                color: 0x654321,
                specular: 0x111111
            });
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.rotation.x = Math.PI;
            islandGroup.add(island);

            // Vegetation on top
            const treeGeometry = new THREE.ConeGeometry(30, 60, 8);
            const treeMaterial = new THREE.MeshPhongMaterial({
                color: 0x228b22
            });
            for (let j = 0; j < 3; j++) {
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.set(
                    (Math.random() - 0.5) * 40,
                    30,
                    (Math.random() - 0.5) * 40
                );
                islandGroup.add(tree);
            }

            // Position floating island
            islandGroup.position.set(
                (Math.random() - 0.5) * 1000,
                100 + Math.random() * 200,
                (Math.random() - 0.5) * 1000
            );

            // Floating animation
            const floatY = islandGroup.position.y;
            const floatSpeed = 0.001 + Math.random() * 0.002;
            const floatAmount = 10 + Math.random() * 20;
            const animateIsland = () => {
                islandGroup.position.y = floatY + Math.sin(Date.now() * floatSpeed) * floatAmount;
                islandGroup.rotation.y += 0.001;
                requestAnimationFrame(animateIsland);
            };
            animateIsland();

            scene.add(islandGroup);
        }

        // Starfield for upper atmosphere
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 3000;
        const positions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount * 3; i += 3) {
            const radius = 800 + Math.random() * 700;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.5; // Only upper hemisphere

            positions[i] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i + 1] = radius * Math.cos(phi) + 300;
            positions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2,
            transparent: true,
            opacity: 0.8
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Arena boundary now less visible
        const boundaryGeometry = new THREE.SphereGeometry(CONFIG.ARENA_SIZE, 32, 32);
        const boundaryMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.05,
            wireframe: true
        });
        const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
        scene.add(boundary);

        // Fog for atmosphere
        scene.fog = new THREE.FogExp2(0x8899aa, 0.0004);
    }

    // Effects
    function createMuzzleFlash(position, color) {
        const flash = new THREE.PointLight(color, 2, 50);
        flash.position.copy(position);
        scene.add(flash);

        setTimeout(() => scene.remove(flash), 100);
    }

    function createImpact(position, color) {
        // Ring effect
        const geometry = new THREE.RingGeometry(1, 5, 32);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(geometry, material);
        ring.position.copy(position);
        ring.lookAt(camera.position);
        scene.add(ring);

        // Animate
        const animate = () => {
            ring.scale.multiplyScalar(1.1);
            ring.material.opacity *= 0.95;

            if (ring.material.opacity > 0.01) {
                requestAnimationFrame(animate);
            } else {
                scene.remove(ring);
            }
        };
        animate();
    }

    function createExplosion(position, color) {
        // Multiple explosion spheres
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const geometry = new THREE.SphereGeometry(1, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);
                sphere.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                ));
                scene.add(sphere);

                // Animate
                const animate = () => {
                    sphere.scale.multiplyScalar(1.15);
                    sphere.material.opacity *= 0.93;

                    if (sphere.material.opacity > 0.01) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(sphere);
                    }
                };
                animate();
            }, i * 50);
        }

        // Particles
        const particleCount = 30;
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = position.x;
            positions[i + 1] = position.y;
            positions[i + 2] = position.z;

            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            velocities.push(velocity);
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const particleMaterial = new THREE.PointsMaterial({
            color: color,
            size: 3,
            transparent: true,
            opacity: 1
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        // Animate particles
        const animateParticles = () => {
            const positions = particleGeometry.attributes.position.array;

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] += velocities[i].x;
                positions[i * 3 + 1] += velocities[i].y;
                positions[i * 3 + 2] += velocities[i].z;

                velocities[i].multiplyScalar(0.98);
            }

            particleGeometry.attributes.position.needsUpdate = true;
            particleMaterial.opacity *= 0.96;

            if (particleMaterial.opacity > 0.01) {
                requestAnimationFrame(animateParticles);
            } else {
                scene.remove(particleSystem);
            }
        };
        animateParticles();
    }

    // Game logic
    function startBattle() {
        battleNumber++;
        timer = CONFIG.BATTLE_TIME;
        ships = [];
        lasers = [];
        gameState = 'battle';

        // Create ships
        for (let i = 0; i < CONFIG.SHIPS; i++) {
            const ship = new Ship(SHIP_CONFIGS[i % SHIP_CONFIGS.length], i);

            // Evolve AI from previous generation
            if (battleNumber > 1) {
                ship.brain.mutate(CONFIG.AI_LEARNING_RATE);
                ship.generation = battleNumber;
            }

            ships.push(ship);
        }

        document.getElementById('battleNum').textContent = battleNumber;
        gameLoop();
    }

    function gameLoop() {
        if (gameState !== 'battle') return;

        timer--;
        const minutes = Math.floor(timer / 60);
        const seconds = timer % 60;
        document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        const alive = ships.filter(s => s.alive);
        document.getElementById('aliveCount').textContent = alive.length;
        document.getElementById('totalShots').textContent = `${stats.totalShots} (${stats.collisions} ‚ö°)`;

        if (alive.length <= 1 || timer <= 0) {
            endBattle();
            return;
        }

        setTimeout(gameLoop, 1000);
    }

    function endBattle() {
        gameState = 'ended';

        const alive = ships.filter(s => s.alive);
        const winner = alive.length > 0 ? alive[0] : ships.reduce((a, b) => a.score > b.score ? a : b);

        // Auto restart after 2 seconds
        setTimeout(() => {
            // Clean up scene
            ships.forEach(ship => {
                if (ship.mesh.parent) scene.remove(ship.mesh);
            });
            lasers.forEach(laser => {
                scene.remove(laser.mesh);
                scene.remove(laser.glow);
            });

            stats.totalShots = 0;
            startBattle();
        }, 2000);
    }

    // Update AI display
    function updateAIDisplay() {
        const aiStats = document.getElementById('aiStats');
        const topShips = [...ships].sort((a, b) => b.score - a.score).slice(0, 5);

        aiStats.innerHTML = topShips.map(ship => `
      <div class="ai-stat">
        <div style="color: #${ship.config.color.toString(16).padStart(6, '0')}; font-weight: bold;">
          ${ship.name} (Gen ${ship.generation})
        </div>
        <div>Score: ${Math.round(ship.score)} | Vie: ${Math.round(ship.health)}</div>
        <div class="ai-progress">
          <div class="ai-progress-bar" style="width: ${ship.health}%"></div>
        </div>
      </div>
    `).join('');
    }

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        // Update camera
        updateCamera();

        // Update game objects
        if (gameState === 'battle') {
            ships.forEach(ship => ship.update());

            lasers = lasers.filter(laser => laser.update());
            missiles = missiles.filter(missile => missile.update());

            updateAIDisplay();
        }

        renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        switch(e.key.toLowerCase()) {
            case '1':
                setCameraMode('orbit');
                break;
            case '2':
                setCameraMode('follow');
                break;
            case '3':
                setCameraMode('fpv');
                break;
            case '4':
                setCameraMode('cinematic');
                break;
            case '5':
                setCameraMode('free');
                break;
            case ' ':
                e.preventDefault();
                if (cameraMode === 'follow' || cameraMode === 'fpv') {
                    // Switch to next alive ship
                    const aliveShips = ships.filter(s => s.alive);
                    if (aliveShips.length > 0) {
                        const currentIndex = aliveShips.indexOf(cameraTarget);
                        const nextIndex = (currentIndex + 1) % aliveShips.length;
                        cameraTarget = aliveShips[nextIndex];
                        updateTargetInfo();
                    }
                } else if (cameraMode === 'free') {
                    keys.space = true;
                }
                break;
            case 'w':
            case 'z':
                keys.forward = true;
                keys.w = true;
                break;
            case 's':
                keys.backward = true;
                keys.s = true;
                break;
            case 'a':
            case 'q':
                keys.left = true;
                keys.a = true;
                break;
            case 'd':
                keys.right = true;
                keys.d = true;
                break;
            case 'shift':
                keys.shift = true;
                break;
            case 'control':
                e.preventDefault();
                keys.ctrl = true;
                break;
        }
    });

    window.addEventListener('keyup', (e) => {
        switch(e.key.toLowerCase()) {
            case 'w':
            case 'z':
                keys.forward = false;
                keys.w = false;
                break;
            case 's':
                keys.backward = false;
                keys.s = false;
                break;
            case 'a':
            case 'q':
                keys.left = false;
                keys.a = false;
                break;
            case 'd':
                keys.right = false;
                keys.d = false;
                break;
            case ' ':
                keys.space = false;
                break;
            case 'shift':
                keys.shift = false;
                break;
            case 'control':
                keys.ctrl = false;
                break;
        }
    });

    // Mouse controls for free camera
    window.addEventListener('mousedown', (e) => {
        if (cameraMode === 'free') {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }
    });

    window.addEventListener('mouseup', () => {
        mouseDown = false;
    });

    window.addEventListener('mousemove', (e) => {
        if (mouseDown && cameraMode === 'free') {
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;

            // Rotate camera target
            const sensitivity = 0.005;
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(freeCameraTarget);

            spherical.theta -= deltaX * sensitivity;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + deltaY * sensitivity));

            freeCameraTarget.setFromSpherical(spherical);

            mouseX = e.clientX;
            mouseY = e.clientY;
        }
    });

    // Prevent right-click menu
    window.addEventListener('contextmenu', (e) => e.preventDefault());

    // Start the game
    window.addEventListener('load', init);
</script>

</body>
</html>