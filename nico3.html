<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drone Explorer - Monde Infini</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      overflow: hidden;
      font-family: 'Courier New', monospace;
      color: #fff;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 10px;
      font-size: 14px;
      min-width: 250px;
      border: 2px solid #4facfe;
      box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      padding: 15px 25px;
      border-radius: 10px;
      display: flex;
      gap: 15px;
      border: 2px solid #4facfe;
      box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
    }
    button {
      padding: 10px 20px;
      border: none;
      background: linear-gradient(135deg, #4facfe, #00f2fe);
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
    }
    button:hover {
      background: linear-gradient(135deg, #00f2fe, #4facfe);
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(79, 172, 254, 0.5);
    }
    #radar {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      background: rgba(0,20,0,0.8);
      border: 2px solid #00ff00;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255,255,255,0.5);
      border-radius: 50%;
      pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255,255,255,0.5);
    }
    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 50%;
      top: -10px;
      transform: translateX(-50%);
    }
    #crosshair::after {
      height: 2px;
      width: 20px;
      top: 50%;
      left: -10px;
      transform: translateY(-50%);
    }
    .mode-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      font-weight: bold;
      text-shadow: 0 0 20px currentColor;
      animation: fadeOut 2s forwards;
      pointer-events: none;
    }
    @keyframes fadeOut {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
    }
    #instructions {
      position: absolute;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
      font-size: 13px;
      border: 2px solid #4facfe;
      max-width: 250px;
    }
    .key {
      display: inline-block;
      background: #4facfe;
      padding: 2px 6px;
      border-radius: 3px;
      margin: 0 2px;
      font-weight: bold;
    }
    .health-bar {
      width: 100%;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      margin: 5px 0;
    }
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff3838, #ffaa00, #00ff00);
      transition: width 0.3s;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <h3>üöÅ DRONE EXPLORER</h3>
  <div>Mode: <span id="mode">EXPLORATION</span></div>
  <div>Position: X:<span id="posX">0</span> Z:<span id="posZ">0</span></div>
  <div>Altitude: <span id="altitude">100</span>m</div>
  <div>Vitesse: <span id="speed">0</span> km/h</div>
  <div>Sant√©: <div class="health-bar"><div class="health-fill" id="health" style="width: 100%"></div></div></div>
  <div>Munitions: <span id="ammo">‚àû</span></div>
  <div>√âliminations: <span id="kills">0</span></div>
  <div>Chunks charg√©s: <span id="chunks">0</span></div>
</div>

<div id="radar">
  <canvas id="radarCanvas" width="200" height="200"></canvas>
</div>

<div id="controls">
  <button onclick="toggleMode()">üéÆ Mode: <span id="modeBtn">EXPLORATION</span></button>
  <button onclick="spawnEnemies()">‚öîÔ∏è Spawn Ennemis</button>
  <button onclick="toggleCamera()">üì∑ Vue: <span id="cameraBtn">3√®me Personne</span></button>
  <button onclick="teleportRandom()">üåç T√©l√©porter Al√©atoire</button>
</div>

<div id="instructions">
  <h4>üìã CONTR√îLES</h4>
  <p><span class="key">‚Üë</span> Avancer</p>
  <p><span class="key">‚Üì</span> Reculer</p>
  <p><span class="key">‚Üê</span> Tourner gauche</p>
  <p><span class="key">‚Üí</span> Tourner droite</p>
  <p><span class="key">Espace</span> Monter</p>
  <p><span class="key">Shift</span> Descendre</p>
  <p><span class="key">ZQSD</span> D√©placements lat√©raux</p>
  <p><span class="key">Clic</span> Tirer (Combat)</p>
  <p><span class="key">E</span> Turbo</p>
  <p><span class="key">Tab</span> Changer Mode</p>
  <p><span class="key">C</span> Changer Vue</p>
  <p style="margin-top: 10px; color: #4facfe;">üí° Pilotez comme un vrai drone!</p>
</div>

<div id="crosshair"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  let scene, camera, renderer;
  let playerDrone, enemies = [], bullets = [], particles = [];
  let chunks = new Map();
  let keys = {};
  let mouse = { x: 0, y: 0 };
  let mode = 'exploration';
  let cameraMode = 0;
  let stats = { kills: 0, health: 100, ammo: 100 };
  let ambientLight, sun, sky;

  const CHUNK_SIZE = 500;
  const RENDER_DISTANCE = 2;
  const MAX_CHUNKS = 16;
  const LOD_DISTANCE = 800;

  // Geometry cache
  const geometryCache = {
    box: {},
    cylinder: {},
    sphere: {},
    plane: {}
  };

  // Material cache
  const materialCache = new Map();

  // Get or create cached geometry
  function getCachedGeometry(type, ...params) {
    const key = params.join('_');
    if (!geometryCache[type][key]) {
      switch(type) {
        case 'box':
          geometryCache[type][key] = new THREE.BoxGeometry(...params);
          break;
        case 'cylinder':
          geometryCache[type][key] = new THREE.CylinderGeometry(...params);
          break;
        case 'sphere':
          geometryCache[type][key] = new THREE.SphereGeometry(...params);
          break;
        case 'plane':
          geometryCache[type][key] = new THREE.PlaneGeometry(...params);
          break;
      }
    }
    return geometryCache[type][key];
  }

  // Get or create cached material
  function getCachedMaterial(type, options) {
    const key = type + '_' + JSON.stringify(options);
    if (!materialCache.has(key)) {
      switch(type) {
        case 'phong':
          materialCache.set(key, new THREE.MeshPhongMaterial(options));
          break;
        case 'basic':
          materialCache.set(key, new THREE.MeshBasicMaterial(options));
          break;
      }
    }
    return materialCache.get(key);
  }

  // Init Three.js
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x11151c, 0.0008);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 3000);
  camera.position.set(0, 150, 200);

  renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById('c'),
    antialias: true,
    alpha: false,
    powerPreference: "high-performance",
    stencil: false,
    depth: true
  });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.shadowMap.autoUpdate = false;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.outputEncoding = THREE.sRGBEncoding;

  // Lighting
  ambientLight = new THREE.AmbientLight(0x4466aa, 0.3);
  scene.add(ambientLight);

  sun = new THREE.DirectionalLight(0xffd4a3, 0.8);
  sun.position.set(300, 600, 300);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 4096;
  sun.shadow.mapSize.height = 4096;
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 2000;
  sun.shadow.camera.left = -500;
  sun.shadow.camera.right = 500;
  sun.shadow.camera.top = 500;
  sun.shadow.camera.bottom = -500;
  sun.shadow.bias = -0.0005;
  scene.add(sun);

  const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x545454, 0.4);
  scene.add(hemiLight);

  const rimLight = new THREE.DirectionalLight(0x88ccff, 0.3);
  rimLight.position.set(-300, 400, -300);
  scene.add(rimLight);

  // Sky
  const skyGeo = new THREE.SphereGeometry(3000, 64, 64);
  const skyMat = new THREE.ShaderMaterial({
    uniforms: {
      topColor: { value: new THREE.Color(0x0088ff) },
      bottomColor: { value: new THREE.Color(0xffd4a3) },
      offset: { value: 400 },
      exponent: { value: 0.5 },
      time: { value: 0 }
    },
    vertexShader: `
            varying vec3 vWorldPosition;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
    fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            uniform float time;
            varying vec3 vWorldPosition;
            varying vec2 vUv;

            void main() {
                float h = normalize(vWorldPosition + offset).y;
                vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));

                float cloud = sin(vUv.x * 10.0 + time * 0.1) * cos(vUv.y * 8.0 + time * 0.05);
                cloud = smoothstep(0.3, 0.7, cloud) * 0.1;
                skyColor = mix(skyColor, vec3(1.0), cloud * h);

                gl_FragColor = vec4(skyColor, 1.0);
            }
        `,
    side: THREE.BackSide
  });
  sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  // Clouds
  const cloudCount = 5;
  for(let i = 0; i < cloudCount; i++) {
    const cloud = new THREE.Mesh(
            getCachedGeometry('plane', 300, 300),
            getCachedMaterial('basic', {
              color: 0xffffff,
              transparent: true,
              opacity: 0.3,
              side: THREE.DoubleSide
            })
    );
    cloud.position.set(
            (Math.random() - 0.5) * 2000,
            300 + Math.random() * 200,
            (Math.random() - 0.5) * 2000
    );
    cloud.rotation.x = Math.PI / 2;
    cloud.scale.setScalar(0.5 + Math.random());
    scene.add(cloud);
    cloud.userData.velocity = 0.1 + Math.random() * 0.2;
    cloud.userData.isCloud = true;
  }

  // Player Drone Class
  class PlayerDrone {
    constructor() {
      const group = new THREE.Group();

      const bodyGeo = new THREE.OctahedronGeometry(12, 1);
      const bodyMat = new THREE.MeshPhongMaterial({
        color: 0x4facfe,
        emissive: 0x0066cc,
        emissiveIntensity: 0.3,
        metalness: 0.8,
        roughness: 0.2
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);

      this.rotors = [];
      for(let i = 0; i < 4; i++) {
        const angle = (i/4) * Math.PI * 2;
        const rotorGroup = new THREE.Group();

        const arm = new THREE.Mesh(
                new THREE.BoxGeometry(15, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
        );
        arm.position.x = Math.cos(angle) * 7.5;
        arm.position.z = Math.sin(angle) * 7.5;
        arm.rotation.y = angle;
        rotorGroup.add(arm);

        const rotor = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.5, 3),
                new THREE.MeshBasicMaterial({
                  color: 0x222222,
                  transparent: true,
                  opacity: 0.8
                })
        );
        rotor.position.x = Math.cos(angle) * 15;
        rotor.position.z = Math.sin(angle) * 15;
        rotor.position.y = 5;
        rotorGroup.add(rotor);
        this.rotors.push(rotor);

        group.add(rotorGroup);
      }

      const cockpit = new THREE.Mesh(
              new THREE.SphereGeometry(5, 8, 4),
              new THREE.MeshPhongMaterial({
                color: 0x87ceeb,
                transparent: true,
                opacity: 0.8,
                emissive: 0x4facfe,
                emissiveIntensity: 0.2
              })
      );
      cockpit.position.y = 3;
      group.add(cockpit);

      const weapon = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 1, 10),
              new THREE.MeshPhongMaterial({ color: 0x333333 })
      );
      weapon.position.set(0, -5, 8);
      weapon.rotation.x = Math.PI/2;
      group.add(weapon);

      const light = new THREE.PointLight(0x4facfe, 2, 150);
      light.position.y = -5;
      light.castShadow = true;
      group.add(light);

      const spotlight = new THREE.SpotLight(0xffffff, 2, 500, Math.PI/6, 0.3, 1);
      spotlight.position.set(0, -5, 10);
      spotlight.target.position.set(0, -100, 100);
      spotlight.castShadow = true;
      spotlight.shadow.mapSize.width = 1024;
      spotlight.shadow.mapSize.height = 1024;
      group.add(spotlight);
      group.add(spotlight.target);

      const glowGeometry = new THREE.SphereGeometry(15, 8, 8);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x4facfe,
        transparent: true,
        opacity: 0.3
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      group.add(glow);

      this.mesh = group;
      this.mesh.position.set(0, 100, 0);
      this.velocity = new THREE.Vector3();
      this.rotation = new THREE.Vector3();
      this.health = 100;
      this.maxSpeed = mode === 'combat' ? 8 : 5;
      this.turbo = false;
      this.lastShot = 0;

      scene.add(this.mesh);
    }

    update() {
      this.rotors.forEach(rotor => {
        rotor.rotation.y += this.turbo ? 0.8 : 0.5;
      });

      if(mode === 'exploration') {
        this.explorationMovement();
      } else {
        this.combatMovement();
      }

      this.mesh.position.add(this.velocity);

      document.getElementById('posX').textContent = Math.floor(this.mesh.position.x);
      document.getElementById('posZ').textContent = Math.floor(this.mesh.position.z);
      document.getElementById('altitude').textContent = Math.floor(this.mesh.position.y);
      document.getElementById('speed').textContent = Math.floor(this.velocity.length() * 20);
      document.getElementById('health').style.width = this.health + '%';
    }

    explorationMovement() {
      const speed = this.turbo ? 1.0 : 0.4;
      const rotSpeed = 0.04;

      // Forward/Backward with Up/Down arrows
      if(keys['arrowup']) {
        const forward = new THREE.Vector3(
                -Math.sin(this.mesh.rotation.y) * speed,
                0,
                -Math.cos(this.mesh.rotation.y) * speed
        );
        this.velocity.add(forward);
      }
      if(keys['arrowdown']) {
        const backward = new THREE.Vector3(
                Math.sin(this.mesh.rotation.y) * speed * 0.6,
                0,
                Math.cos(this.mesh.rotation.y) * speed * 0.6
        );
        this.velocity.add(backward);
      }

      // Rotation with Left/Right arrows
      if(keys['arrowleft']) {
        this.mesh.rotation.y += rotSpeed;
      }
      if(keys['arrowright']) {
        this.mesh.rotation.y -= rotSpeed;
      }

      // Alternative WASD/ZQSD controls for strafing
      if(keys['z'] || keys['w']) {
        const forward = new THREE.Vector3(
                -Math.sin(this.mesh.rotation.y) * speed,
                0,
                -Math.cos(this.mesh.rotation.y) * speed
        );
        this.velocity.add(forward);
      }
      if(keys['s']) {
        const backward = new THREE.Vector3(
                Math.sin(this.mesh.rotation.y) * speed * 0.6,
                0,
                Math.cos(this.mesh.rotation.y) * speed * 0.6
        );
        this.velocity.add(backward);
      }
      if(keys['q'] || keys['a']) {
        const left = new THREE.Vector3(
                -Math.cos(this.mesh.rotation.y) * speed * 0.7,
                0,
                Math.sin(this.mesh.rotation.y) * speed * 0.7
        );
        this.velocity.add(left);
      }
      if(keys['d']) {
        const right = new THREE.Vector3(
                Math.cos(this.mesh.rotation.y) * speed * 0.7,
                0,
                -Math.sin(this.mesh.rotation.y) * speed * 0.7
        );
        this.velocity.add(right);
      }

      // Altitude control
      if(keys[' ']) this.velocity.y += speed * 0.8;
      if(keys['shift']) this.velocity.y -= speed * 0.8;

      // Additional rotation with PageUp/PageDown
      if(keys['pageup']) this.velocity.y += speed * 0.8;
      if(keys['pagedown']) this.velocity.y -= speed * 0.8;

      // Mouse rotation (optional, reduced influence)
      if(Math.abs(mouse.x) > 0.1) {
        this.mesh.rotation.y -= mouse.x * 0.02;
      }

      // Apply drag
      this.velocity.multiplyScalar(0.92);

      // Height limits
      this.mesh.position.y = Math.max(30, Math.min(500, this.mesh.position.y));

      // Auto-stabilize rotation for smoother flight
      this.mesh.rotation.x = -this.velocity.z * 0.03;
      this.mesh.rotation.z = -this.velocity.x * 0.03;
    }

    combatMovement() {
      const speed = 0.6;
      const rotSpeed = 0.05;

      // Combat mode - more responsive controls
      if(keys['arrowup']) {
        const forward = new THREE.Vector3(
                -Math.sin(this.mesh.rotation.y) * speed,
                0,
                -Math.cos(this.mesh.rotation.y) * speed
        );
        this.velocity.add(forward);
      }
      if(keys['arrowdown']) {
        const backward = new THREE.Vector3(
                Math.sin(this.mesh.rotation.y) * speed * 0.7,
                0,
                Math.cos(this.mesh.rotation.y) * speed * 0.7
        );
        this.velocity.add(backward);
      }

      // Quick rotation for combat
      if(keys['arrowleft']) {
        this.mesh.rotation.y += rotSpeed;
      }
      if(keys['arrowright']) {
        this.mesh.rotation.y -= rotSpeed;
      }

      // WASD for additional movement
      if(keys['z'] || keys['w']) {
        const forward = new THREE.Vector3(
                -Math.sin(this.mesh.rotation.y) * speed,
                0,
                -Math.cos(this.mesh.rotation.y) * speed
        );
        this.velocity.add(forward);
      }
      if(keys['s']) {
        const backward = new THREE.Vector3(
                Math.sin(this.mesh.rotation.y) * speed * 0.7,
                0,
                Math.cos(this.mesh.rotation.y) * speed * 0.7
        );
        this.velocity.add(backward);
      }
      if(keys['q'] || keys['a']) {
        const left = new THREE.Vector3(
                -Math.cos(this.mesh.rotation.y) * speed * 0.8,
                0,
                Math.sin(this.mesh.rotation.y) * speed * 0.8
        );
        this.velocity.add(left);
      }
      if(keys['d']) {
        const right = new THREE.Vector3(
                Math.cos(this.mesh.rotation.y) * speed * 0.8,
                0,
                -Math.sin(this.mesh.rotation.y) * speed * 0.8
        );
        this.velocity.add(right);
      }

      // Vertical movement
      if(keys[' ']) this.velocity.y += speed;
      if(keys['shift']) this.velocity.y -= speed;

      // Mouse for fine aiming
      if(Math.abs(mouse.x) > 0.1) {
        this.mesh.rotation.y -= mouse.x * 0.03;
      }

      // Less drag for more agility
      this.velocity.multiplyScalar(0.88);

      // Combat height limits
      this.mesh.position.y = Math.max(50, Math.min(300, this.mesh.position.y));

      // Dynamic tilt based on movement
      this.mesh.rotation.x = -this.velocity.z * 0.04;
      this.mesh.rotation.z = -this.velocity.x * 0.04;
    }

    shoot() {
      const now = Date.now();
      if(now - this.lastShot < 100) return;

      const bullet = new THREE.Mesh(
              new THREE.SphereGeometry(2),
              new THREE.MeshBasicMaterial({
                color: 0x00f2fe,
                emissive: 0x00f2fe
              })
      );

      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);

      bullet.position.copy(this.mesh.position);
      bullet.velocity = direction.multiplyScalar(20);
      bullet.life = 60;
      bullet.isPlayer = true;

      scene.add(bullet);
      bullets.push(bullet);
      this.lastShot = now;

      createMuzzleFlash(this.mesh.position);
    }

    takeDamage(damage) {
      this.health -= damage;
      stats.health = this.health;

      createExplosion(this.mesh.position, 0xff0000, 10);

      if(this.health <= 0) {
        this.respawn();
      }
    }

    respawn() {
      this.health = 100;
      stats.health = 100;
      this.mesh.position.set(0, 100, 0);
      this.velocity.set(0, 0, 0);
      showModeIndicator("RESPAWN!");
    }
  }

  // Enemy Drone Class
  class EnemyDrone {
    constructor(position) {
      const group = new THREE.Group();

      const body = new THREE.Mesh(
              new THREE.OctahedronGeometry(10, 0),
              new THREE.MeshPhongMaterial({
                color: 0xff6b6b,
                emissive: 0xcc0000,
                emissiveIntensity: 0.3
              })
      );
      group.add(body);

      for(let i = 0; i < 4; i++) {
        const angle = (i/4) * Math.PI * 2;
        const rotor = new THREE.Mesh(
                new THREE.BoxGeometry(12, 1, 3),
                new THREE.MeshBasicMaterial({ color: 0x1a1a1a })
        );
        rotor.position.x = Math.cos(angle) * 12;
        rotor.position.z = Math.sin(angle) * 12;
        rotor.position.y = 5;
        group.add(rotor);
      }

      this.mesh = group;
      this.mesh.position.copy(position);
      this.velocity = new THREE.Vector3();
      this.health = 50;
      this.lastShot = 0;
      this.target = playerDrone;

      scene.add(this.mesh);
    }

    update() {
      if(!this.target) return;

      const dist = this.mesh.position.distanceTo(this.target.mesh.position);

      if(dist > 150) {
        const dir = this.target.mesh.position.clone()
                .sub(this.mesh.position).normalize();
        this.velocity.add(dir.multiplyScalar(0.3));
      } else if(dist < 80) {
        const dir = this.mesh.position.clone()
                .sub(this.target.mesh.position).normalize();
        this.velocity.add(dir.multiplyScalar(0.2));
      } else {
        const angle = Date.now() * 0.002;
        this.velocity.x += Math.cos(angle) * 0.1;
        this.velocity.z += Math.sin(angle) * 0.1;
      }

      if(dist < 200 && Date.now() - this.lastShot > 500) {
        this.shoot();
      }

      this.velocity.multiplyScalar(0.95);
      this.mesh.position.add(this.velocity);
      this.mesh.lookAt(this.target.mesh.position);
    }

    shoot() {
      const bullet = new THREE.Mesh(
              new THREE.SphereGeometry(2),
              new THREE.MeshBasicMaterial({
                color: 0xff6b6b,
                emissive: 0xff6b6b
              })
      );

      const direction = this.target.mesh.position.clone()
              .sub(this.mesh.position).normalize();

      bullet.position.copy(this.mesh.position);
      bullet.velocity = direction.multiplyScalar(15);
      bullet.life = 60;
      bullet.isPlayer = false;

      scene.add(bullet);
      bullets.push(bullet);
      this.lastShot = Date.now();
    }

    takeDamage(damage) {
      this.health -= damage;

      if(this.health <= 0) {
        createExplosion(this.mesh.position, 0xff6600, 30);
        scene.remove(this.mesh);
        stats.kills++;
        document.getElementById('kills').textContent = stats.kills;
        return true;
      }

      createExplosion(this.mesh.position, 0xffaa00, 10);
      return false;
    }
  }

  // Chunk Class
  class Chunk {
    constructor(x, z) {
      this.x = x;
      this.z = z;
      this.group = new THREE.Group();
      this.isLOD = false;
      this.generate();
    }

    generate() {
      const worldX = this.x * CHUNK_SIZE;
      const worldZ = this.z * CHUNK_SIZE;

      const distToPlayer = Math.sqrt(
              Math.pow(worldX - (playerDrone ? playerDrone.mesh.position.x : 0), 2) +
              Math.pow(worldZ - (playerDrone ? playerDrone.mesh.position.z : 0), 2)
      );
      this.isLOD = distToPlayer > LOD_DISTANCE;

      const groundMat = getCachedMaterial('phong', {
        color: new THREE.Color().setHSL(0.25, 0.3, 0.2 + Math.random() * 0.1),
        roughness: 0.9,
        metalness: 0.1
      });

      const ground = new THREE.Mesh(
              getCachedGeometry('plane', CHUNK_SIZE, CHUNK_SIZE, this.isLOD ? 2 : 10, this.isLOD ? 2 : 10),
              groundMat
      );
      ground.rotation.x = -Math.PI/2;
      ground.position.set(worldX, 0, worldZ);
      ground.receiveShadow = !this.isLOD;

      if (!this.isLOD) {
        const vertices = ground.geometry.attributes.position.array;
        for(let i = 0; i < vertices.length; i += 3) {
          vertices[i + 1] = Math.random() * 2;
        }
        ground.geometry.computeVertexNormals();
      }

      this.group.add(ground);

      const roadMat = getCachedMaterial('phong', {
        color: 0x333333,
        roughness: 0.8,
        metalness: 0.2
      });

      if(!this.isLOD && Math.random() > 0.3) {
        const streetH = new THREE.Mesh(
                getCachedGeometry('plane', CHUNK_SIZE, 20),
                roadMat
        );
        streetH.rotation.x = -Math.PI/2;
        streetH.position.set(worldX, 0.1, worldZ);
        this.group.add(streetH);
      }

      const buildingCount = this.isLOD ? 2 : (3 + Math.floor(Math.random() * 5));
      const positions = [];

      for(let i = 0; i < buildingCount; i++) {
        let position;
        let attempts = 0;

        do {
          position = new THREE.Vector3(
                  worldX + (Math.random() - 0.5) * CHUNK_SIZE * 0.8,
                  0,
                  worldZ + (Math.random() - 0.5) * CHUNK_SIZE * 0.8
          );
          attempts++;
        } while (attempts < 10 && positions.some(p => p.distanceTo(position) < 80));

        positions.push(position);

        const building = this.isLOD ? this.createSimpleBuilding() : this.createBuilding();
        building.position.copy(position);
        this.group.add(building);
      }

      if (!this.isLOD) {
        const treeCount = 5 + Math.floor(Math.random() * 10);
        for(let i = 0; i < treeCount; i++) {
          const tree = this.createTree();
          tree.position.set(
                  worldX + (Math.random() - 0.5) * CHUNK_SIZE,
                  0,
                  worldZ + (Math.random() - 0.5) * CHUNK_SIZE
          );
          this.group.add(tree);
        }
      }

      if (!this.isLOD) {
        for(let i = -1; i <= 1; i += 2) {
          for(let j = -1; j <= 1; j += 2) {
            const light = this.createStreetLight();
            light.position.set(
                    worldX + i * CHUNK_SIZE/3,
                    0,
                    worldZ + j * CHUNK_SIZE/3
            );
            this.group.add(light);
          }
        }
      }

      scene.add(this.group);
    }

    createSimpleBuilding() {
      const width = 40 + Math.random() * 40;
      const depth = 40 + Math.random() * 40;
      const height = 80 + Math.random() * 120;

      const building = new THREE.Mesh(
              getCachedGeometry('box', width, height, depth),
              getCachedMaterial('phong', {
                color: new THREE.Color().setHSL(0.6, 0.1, 0.3),
                metalness: 0.5,
                roughness: 0.5
              })
      );
      building.position.y = height/2;
      building.castShadow = false;
      building.receiveShadow = false;

      return building;
    }

    createBuilding() {
      const buildingType = Math.random();

      if(buildingType < 0.3) {
        return this.createSkyscraper();
      } else if(buildingType < 0.6) {
        return this.createOfficeBuilding();
      } else if(buildingType < 0.8) {
        return this.createResidentialBuilding();
      } else {
        return this.createModernTower();
      }
    }

    createSkyscraper() {
      const group = new THREE.Group();
      const width = 40 + Math.random() * 30;
      const depth = 40 + Math.random() * 30;
      const height = 150 + Math.random() * 150;

      const buildingMat = new THREE.MeshPhongMaterial({
        color: 0x2c3e50,
        metalness: 0.7,
        roughness: 0.3
      });

      const tower = new THREE.Mesh(
              new THREE.BoxGeometry(width, height, depth),
              buildingMat
      );
      tower.position.y = height/2;
      tower.castShadow = true;
      tower.receiveShadow = true;
      group.add(tower);

      const foundation = new THREE.Mesh(
              new THREE.BoxGeometry(width * 1.3, 5, depth * 1.3),
              new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
      );
      foundation.position.y = 2.5;
      foundation.receiveShadow = true;
      group.add(foundation);

      return group;
    }

    createOfficeBuilding() {
      const group = new THREE.Group();
      const width = 50 + Math.random() * 40;
      const depth = 50 + Math.random() * 40;
      const height = 80 + Math.random() * 80;

      const building = new THREE.Mesh(
              new THREE.BoxGeometry(width, height, depth),
              new THREE.MeshPhongMaterial({
                color: 0x34495e,
                metalness: 0.5,
                roughness: 0.5
              })
      );
      building.position.y = height/2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);

      return group;
    }

    createResidentialBuilding() {
      const group = new THREE.Group();
      const width = 35 + Math.random() * 25;
      const depth = 35 + Math.random() * 25;
      const height = 60 + Math.random() * 60;

      const building = new THREE.Mesh(
              new THREE.BoxGeometry(width, height, depth),
              new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(0.08, 0.3, 0.4),
                metalness: 0.3,
                roughness: 0.7
              })
      );
      building.position.y = height/2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);

      return group;
    }

    createModernTower() {
      const group = new THREE.Group();
      const radius = 20 + Math.random() * 20;
      const height = 100 + Math.random() * 150;
      const segments = 8 + Math.floor(Math.random() * 8);

      const tower = new THREE.Mesh(
              new THREE.CylinderGeometry(radius, radius * 1.1, height, segments),
              new THREE.MeshPhongMaterial({
                color: 0x2c3e50,
                metalness: 0.8,
                roughness: 0.2
              })
      );
      tower.position.y = height/2;
      tower.castShadow = true;
      tower.receiveShadow = true;
      group.add(tower);

      return group;
    }

    createTree() {
      const group = new THREE.Group();

      const trunk = new THREE.Mesh(
              getCachedGeometry('cylinder', 2, 3, 15),
              getCachedMaterial('phong', { color: 0x4a3c28 })
      );
      trunk.position.y = 7.5;
      group.add(trunk);

      const foliage = new THREE.Mesh(
              getCachedGeometry('sphere', 8 + Math.random() * 4, 4, 3),
              getCachedMaterial('phong', {
                color: new THREE.Color().setHSL(0.25, 0.8, 0.3),
                flatShading: true
              })
      );
      foliage.position.y = 20;
      group.add(foliage);

      return group;
    }

    createStreetLight() {
      const group = new THREE.Group();

      const pole = new THREE.Mesh(
              getCachedGeometry('cylinder', 1, 1.5, 30),
              getCachedMaterial('phong', {
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.2
              })
      );
      pole.position.y = 15;
      group.add(pole);

      const lightBulb = new THREE.Mesh(
              getCachedGeometry('sphere', 4, 6, 4),
              getCachedMaterial('basic', {
                color: 0xffdd88,
                emissive: 0xffdd88
              })
      );
      lightBulb.position.y = 30;
      group.add(lightBulb);

      if (!this.isLOD) {
        const light = new THREE.PointLight(0xffdd88, 1, 50, 2);
        light.position.y = 30;
        group.add(light);
      }

      return group;
    }

    unload() {
      scene.remove(this.group);

      this.group.traverse((child) => {
        if (child.geometry && !Object.values(geometryCache).some(cache =>
                Object.values(cache).includes(child.geometry))) {
          child.geometry.dispose();
        }
        if (child.material && !materialCache.has(child.material)) {
          if (Array.isArray(child.material)) {
            child.material.forEach(m => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });

      this.group = null;
    }
  }

  // Functions
  function updateChunks() {
    if(!playerDrone) return;

    const playerChunkX = Math.floor(playerDrone.mesh.position.x / CHUNK_SIZE);
    const playerChunkZ = Math.floor(playerDrone.mesh.position.z / CHUNK_SIZE);

    const newChunks = new Set();
    for(let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
      for(let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
        const chunkX = playerChunkX + x;
        const chunkZ = playerChunkZ + z;
        const key = `${chunkX},${chunkZ}`;
        newChunks.add(key);

        if(!chunks.has(key)) {
          if(chunks.size >= MAX_CHUNKS) {
            const oldestKey = chunks.keys().next().value;
            const oldChunk = chunks.get(oldestKey);
            oldChunk.unload();
            chunks.delete(oldestKey);
          }
          chunks.set(key, new Chunk(chunkX, chunkZ));
        }
      }
    }

    chunks.forEach((chunk, key) => {
      if(!newChunks.has(key)) {
        chunk.unload();
        chunks.delete(key);
      }
    });

    if(Date.now() % 10 === 0) {
      renderer.shadowMap.needsUpdate = true;
    }

    document.getElementById('chunks').textContent = chunks.size;
  }

  function toggleMode() {
    if(!playerDrone) return;

    mode = mode === 'exploration' ? 'combat' : 'exploration';
    document.getElementById('mode').textContent = mode.toUpperCase();
    document.getElementById('modeBtn').textContent = mode.toUpperCase();
    playerDrone.maxSpeed = mode === 'combat' ? 8 : 5;
    showModeIndicator(mode === 'combat' ? '‚öîÔ∏è MODE COMBAT' : 'üåç MODE EXPLORATION');

    if(mode === 'combat' && enemies.length === 0) {
      spawnEnemies();
    }
  }

  function spawnEnemies() {
    if(!playerDrone) return;

    const count = 3 + Math.floor(Math.random() * 5);
    for(let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      const distance = 100 + Math.random() * 100;
      const position = new THREE.Vector3(
              playerDrone.mesh.position.x + Math.cos(angle) * distance,
              50 + Math.random() * 100,
              playerDrone.mesh.position.z + Math.sin(angle) * distance
      );
      enemies.push(new EnemyDrone(position));
    }
    showModeIndicator(`‚öîÔ∏è ${count} ENNEMIS APPARUS!`);
  }

  function toggleCamera() {
    cameraMode = (cameraMode + 1) % 3;
    const modes = ['3√®me Personne', 'FPS', 'Vue du Dessus'];
    document.getElementById('cameraBtn').textContent = modes[cameraMode];
  }

  function teleportRandom() {
    if(!playerDrone) return;

    const range = 5000;
    playerDrone.mesh.position.set(
            (Math.random() - 0.5) * range,
            100,
            (Math.random() - 0.5) * range
    );
    playerDrone.velocity.set(0, 0, 0);
    updateChunks();
    showModeIndicator('üåç T√âL√âPORTATION!');
  }

  function showModeIndicator(text) {
    const indicator = document.createElement('div');
    indicator.className = 'mode-indicator';
    indicator.textContent = text;
    indicator.style.color = mode === 'combat' ? '#ff6b6b' : '#4facfe';
    document.body.appendChild(indicator);
    setTimeout(() => indicator.remove(), 2000);
  }

  function updateCamera() {
    if(!playerDrone) return;

    switch(cameraMode) {
      case 0:
        const offset = new THREE.Vector3(0, 50, 100);
        offset.applyQuaternion(playerDrone.mesh.quaternion);
        camera.position.lerp(
                playerDrone.mesh.position.clone().add(offset),
                0.1
        );
        camera.lookAt(playerDrone.mesh.position);
        break;
      case 1:
        camera.position.copy(playerDrone.mesh.position);
        camera.position.y += 5;
        const lookDir = new THREE.Vector3(0, 0, -100);
        lookDir.applyQuaternion(playerDrone.mesh.quaternion);
        camera.lookAt(playerDrone.mesh.position.clone().add(lookDir));
        break;
      case 2:
        camera.position.set(
                playerDrone.mesh.position.x,
                playerDrone.mesh.position.y + 200,
                playerDrone.mesh.position.z + 50
        );
        camera.lookAt(playerDrone.mesh.position);
        break;
    }
  }

  function createExplosion(position, color, count) {
    for(let i = 0; i < count; i++) {
      const particle = new THREE.Mesh(
              new THREE.TetrahedronGeometry(2),
              new THREE.MeshBasicMaterial({ color })
      );
      particle.position.copy(position);
      particle.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 10,
              Math.random() * 10,
              (Math.random() - 0.5) * 10
      );
      particle.life = 30;
      scene.add(particle);
      particles.push(particle);
    }
  }

  function createMuzzleFlash(position) {
    const flash = new THREE.PointLight(0xffff00, 2, 50);
    flash.position.copy(position);
    scene.add(flash);
    setTimeout(() => scene.remove(flash), 50);
  }

  function updateRadar() {
    if(!playerDrone) return;

    const canvas = document.getElementById('radarCanvas');
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, 200, 200);

    ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
    ctx.beginPath();
    ctx.moveTo(100, 0);
    ctx.lineTo(100, 200);
    ctx.moveTo(0, 100);
    ctx.lineTo(200, 100);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(100, 100, 50, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(100, 100, 90, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = '#4facfe';
    ctx.fillRect(98, 98, 4, 4);

    enemies.forEach(enemy => {
      const dx = (enemy.mesh.position.x - playerDrone.mesh.position.x) / 5;
      const dz = (enemy.mesh.position.z - playerDrone.mesh.position.z) / 5;

      if(Math.abs(dx) < 100 && Math.abs(dz) < 100) {
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(100 + dx - 2, 100 + dz - 2, 4, 4);
      }
    });

    ctx.strokeStyle = '#00ff00';
    ctx.beginPath();
    ctx.moveTo(100, 100);
    const angle = -playerDrone.mesh.rotation.y;
    ctx.lineTo(100 + Math.sin(angle) * 20, 100 - Math.cos(angle) * 20);
    ctx.stroke();
  }

  let frameCount = 0;
  function performCleanup() {
    frameCount++;

    if(frameCount % 600 === 0) {
      const objectsToRemove = [];
      scene.traverse((child) => {
        if(child.userData.shouldRemove) {
          objectsToRemove.push(child);
        }
      });

      objectsToRemove.forEach(obj => {
        scene.remove(obj);
        if(obj.geometry) obj.geometry.dispose();
        if(obj.material) {
          if(Array.isArray(obj.material)) {
            obj.material.forEach(m => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      });

      if(window.gc) window.gc();
    }

    if(frameCount % 3 === 0) {
      updateRadar();
    }
  }

  // Initialize
  playerDrone = new PlayerDrone();
  updateChunks();

  // Input
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;

    if(e.key === 'Tab') {
      e.preventDefault();
      toggleMode();
    }
    if(e.key.toLowerCase() === 'c') toggleCamera();
    if(e.key.toLowerCase() === 'e') playerDrone.turbo = true;
  });

  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
    if(e.key.toLowerCase() === 'e') playerDrone.turbo = false;
  });

  window.addEventListener('mousemove', e => {
    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  });

  window.addEventListener('click', () => {
    if(mode === 'combat') {
      playerDrone.shoot();
    }
  });

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Main loop
  function animate() {
    requestAnimationFrame(animate);

    const time = Date.now() * 0.001;

    sky.material.uniforms.time.value = time;

    scene.children.forEach(child => {
      if(child.userData.isCloud) {
        child.position.x += child.userData.velocity;
        if(child.position.x > 2000) child.position.x = -2000;
      }
    });

    playerDrone.update();

    const dayProgress = (Math.sin(time * 0.05) + 1) / 2;
    sun.intensity = 0.4 + dayProgress * 0.6;
    sun.color.setHSL(0.1, 0.5, 0.5 + dayProgress * 0.3);
    ambientLight.intensity = 0.2 + dayProgress * 0.2;

    const heightFactor = Math.min(playerDrone.mesh.position.y / 500, 1);
    scene.fog.density = 0.0008 - heightFactor * 0.0004;

    updateChunks();

    enemies = enemies.filter(enemy => {
      enemy.update();
      return enemy.health > 0;
    });

    bullets = bullets.filter(bullet => {
      bullet.position.add(bullet.velocity);
      bullet.life--;

      if(bullet.life % 3 === 0) {
        const trail = new THREE.Mesh(
                getCachedGeometry('sphere', 0.5, 3, 2),
                getCachedMaterial('basic', {
                  color: bullet.material.color,
                  transparent: true,
                  opacity: 0.3
                })
        );
        trail.position.copy(bullet.position);
        scene.add(trail);
        setTimeout(() => {
          scene.remove(trail);
          if(trail.geometry && !Object.values(geometryCache.sphere).includes(trail.geometry)) {
            trail.geometry.dispose();
          }
        }, 100);
      }

      if(bullet.isPlayer) {
        enemies.forEach(enemy => {
          if(bullet.position.distanceTo(enemy.mesh.position) < 15) {
            if(enemy.takeDamage(25)) {
              enemies = enemies.filter(e => e !== enemy);
            }
            bullet.life = 0;
          }
        });
      } else {
        if(bullet.position.distanceTo(playerDrone.mesh.position) < 15) {
          playerDrone.takeDamage(10);
          bullet.life = 0;
        }
      }

      if(bullet.life <= 0) {
        scene.remove(bullet);
        return false;
      }
      return true;
    });

    particles = particles.filter(particle => {
      particle.position.add(particle.velocity);
      particle.velocity.y -= 0.5;
      particle.life--;
      particle.rotation.x += 0.2;
      particle.rotation.y += 0.2;
      particle.material.opacity = particle.life / 40;

      if(particle.life <= 0) {
        scene.remove(particle);
        return false;
      }
      return true;
    });

    updateCamera();
    performCleanup();
    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>