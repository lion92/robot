<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Arroseur HD - Mission Jardinage</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: #fff;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            filter: contrast(1.1) saturate(1.2);
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(30,30,50,0.8));
            padding: 20px;
            border-radius: 20px;
            font-size: 14px;
            min-width: 280px;
            border: 2px solid rgba(79, 172, 254, 0.5);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37),
            inset 0 0 20px rgba(79, 172, 254, 0.2);
            backdrop-filter: blur(10px);
        }
        #hud h3 {
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 18px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(30,30,50,0.9));
            padding: 15px 25px;
            border-radius: 25px;
            display: flex;
            gap: 15px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(10px);
        }
        button {
            padding: 12px 24px;
            border: none;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 25px rgba(118, 75, 162, 0.6);
        }
        #radar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(0,40,0,0.9), rgba(0,20,0,0.7));
            border: 3px solid rgba(0,255,0,0.5);
            border-radius: 50%;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.3),
            inset 0 0 30px rgba(0, 255, 0, 0.1);
            overflow: hidden;
        }
        #radar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: conic-gradient(from 0deg, transparent, rgba(0,255,0,0.3), transparent);
            animation: radarSweep 4s linear infinite;
            border-radius: 50%;
        }
        @keyframes radarSweep {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
            animation: crosshairPulse 2s ease-in-out infinite;
        }
        @keyframes crosshairPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
        }
        #crosshair::before {
            width: 2px;
            height: 30px;
            left: 50%;
            top: -15px;
            transform: translateX(-50%);
        }
        #crosshair::after {
            height: 2px;
            width: 30px;
            top: 50%;
            left: -15px;
            transform: translateY(-50%);
        }
        .mode-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 42px;
            font-weight: bold;
            text-shadow: 0 0 30px currentColor, 0 0 60px currentColor;
            animation: fadeOut 2.5s forwards;
            pointer-events: none;
            z-index: 1000;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        @keyframes fadeOut {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3) rotateY(90deg);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2) rotateY(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1) rotateY(0deg);
            }
        }
        #instructions {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(30,30,50,0.8));
            padding: 25px;
            border-radius: 20px;
            font-size: 13px;
            border: 2px solid rgba(79, 172, 254, 0.3);
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(10px);
        }
        #instructions h4 {
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }
        .key {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 4px 8px;
            border-radius: 5px;
            margin: 0 3px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
        }
        .water-bar {
            width: 100%;
            height: 22px;
            background: linear-gradient(90deg, #1a1a2e, #16213e);
            border-radius: 15px;
            overflow: hidden;
            margin: 8px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
            border: 1px solid rgba(79, 172, 254, 0.3);
        }
        .water-fill {
            height: 100%;
            background: linear-gradient(90deg, #00a8ff, #00d4ff, #00ffff, #00ffd5);
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            position: relative;
            overflow: hidden;
        }
        .water-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .score-popup {
            position: absolute;
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0,255,136,0.8);
            animation: scoreFloat 2s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }
        @keyframes scoreFloat {
            0% {
                transform: translateY(0) scale(0.5) rotateZ(-10deg);
                opacity: 0;
            }
            50% {
                transform: translateY(-40px) scale(1.3) rotateZ(5deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-80px) scale(0.8) rotateZ(0deg);
                opacity: 0;
            }
        }
        #levelComplete {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            font-size: 28px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 0 80px rgba(0,255,136,0.6),
            inset 0 0 30px rgba(255,255,255,0.2);
            animation: levelCompleteAnim 0.5s ease-out;
        }
        @keyframes levelCompleteAnim {
            0% { transform: translate(-50%, -50%) scale(0) rotateZ(180deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotateZ(0deg); }
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(79, 172, 254, 0.2);
        }
        .stat-label {
            color: rgba(255,255,255,0.7);
        }
        .stat-value {
            color: #00d4ff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
    <h3>üöÅüíß DRONE ARROSEUR HD</h3>
    <div class="stat-item">
        <span class="stat-label">Mode:</span>
        <span class="stat-value" id="gameMode">ARROSAGE</span>
    </div>
    <div class="stat-item">
        <span class="stat-label">üå± Score:</span>
        <span class="stat-value" id="score">0</span>
    </div>
    <div class="stat-item">
        <span class="stat-label">üåø Plantes:</span>
        <span class="stat-value"><span id="plantsWatered">0</span>/<span id="totalPlants">0</span></span>
    </div>
    <div class="stat-item">
        <span class="stat-label">‚è±Ô∏è Temps:</span>
        <span class="stat-value" id="timer">00:00</span>
    </div>
    <div class="stat-item">
        <span class="stat-label">üìç Position:</span>
        <span class="stat-value">X:<span id="posX">0</span> Z:<span id="posZ">0</span></span>
    </div>
    <div class="stat-item">
        <span class="stat-label">üî∫ Altitude:</span>
        <span class="stat-value"><span id="altitude">100</span>m</span>
    </div>
    <div style="margin-top: 10px;">
        <div style="color: #00d4ff; font-size: 12px; margin-bottom: 3px;">üíß R√©servoir d'eau</div>
        <div class="water-bar"><div class="water-fill" id="water" style="width: 100%"></div></div>
    </div>
    <div class="stat-item">
        <span class="stat-label">üèÜ Record:</span>
        <span class="stat-value" id="highScore">0</span>
    </div>
    <div class="stat-item">
        <span class="stat-label">üåç Zone:</span>
        <span class="stat-value" id="zone">Centre Ville</span>
    </div>
</div>

<div id="radar">
    <canvas id="radarCanvas" width="200" height="200"></canvas>
</div>

<div id="controls">
    <button onclick="startWateringMode()">üíß Arrosage</button>
    <button onclick="startCombatMode()">‚öîÔ∏è Combat</button>
    <button onclick="toggleCamera()">üì∑ Vue</button>
    <button onclick="restartLevel()">üîÑ Reset</button>
</div>

<div id="instructions">
    <h4>üìã CONTR√îLES</h4>
    <p><span class="key">‚Üë</span> Avancer</p>
    <p><span class="key">‚Üì</span> Reculer</p>
    <p><span class="key">‚Üê</span> Tourner gauche</p>
    <p><span class="key">‚Üí</span> Tourner droite</p>
    <p><span class="key">Espace</span> Monter</p>
    <p><span class="key">Shift</span> Descendre</p>
    <p><span class="key">Clic / W</span> Arroser</p>
    <p><span class="key">R</span> Recharger eau</p>
    <p><span class="key">C</span> Changer Vue</p>
    <p style="margin-top: 15px; color: #00ff88;">üå± Trouvez et arrosez les plantes!</p>
    <p style="color: #00d4ff;">üíß Rechargez au lac central!</p>
</div>

<div id="levelComplete">
    <h2>üéâ NIVEAU TERMIN√â!</h2>
    <p>Score Final: <span id="finalScore">0</span></p>
    <p>Plantes Arros√©es: <span id="finalPlants">0</span></p>
    <p>Temps: <span id="finalTime">00:00</span></p>
    <button onclick="nextLevel()">Niveau Suivant ‚Üí</button>
</div>

<div id="crosshair"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer, composer;
    let playerDrone, enemies = [], bullets = [], particles = [];
    let plants = [], waterDrops = [];
    let keys = {};
    let mouse = { x: 0, y: 0 };
    let mode = 'watering';
    let cameraMode = 0;
    let stats = {
        score: 0,
        plantsWatered: 0,
        waterLevel: 100,
        highScore: parseInt(localStorage.getItem('droneHighScore') || 0)
    };
    let ambientLight, sun, sky;
    let waterRefillStation, lakeMesh;
    let startTime = Date.now();
    let currentLevel = 1;
    let clouds = [];

    const MAP_SIZE = 2000;
    const CITY_BLOCKS = 8;
    const BLOCK_SIZE = MAP_SIZE / CITY_BLOCKS;

    // Initialize Three.js with better settings
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0003);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 150, 200);

    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('c'),
        antialias: true,
        alpha: false,
        powerPreference: "high-performance",
        precision: "highp",
        logarithmicDepthBuffer: true
    });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;

    // Enhanced lighting
    ambientLight = new THREE.HemisphereLight(0x87ceeb, 0x494949, 0.6);
    scene.add(ambientLight);

    sun = new THREE.DirectionalLight(0xffd4a3, 2);
    sun.position.set(500, 800, 500);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 4096;
    sun.shadow.mapSize.height = 4096;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 3000;
    sun.shadow.camera.left = -1000;
    sun.shadow.camera.right = 1000;
    sun.shadow.camera.top = 1000;
    sun.shadow.camera.bottom = -1000;
    sun.shadow.bias = -0.0005;
    scene.add(sun);

    // Add rim light
    const rimLight = new THREE.DirectionalLight(0x88ccff, 0.5);
    rimLight.position.set(-300, 400, -300);
    scene.add(rimLight);

    // Enhanced sky with gradient
    const skyGeo = new THREE.SphereGeometry(4000, 64, 64);
    const skyMat = new THREE.ShaderMaterial({
        uniforms: {
            topColor: { value: new THREE.Color(0x0088ff) },
            bottomColor: { value: new THREE.Color(0xffd4a3) },
            offset: { value: 400 },
            exponent: { value: 0.6 }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `,
        side: THREE.BackSide
    });
    sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Create volumetric clouds
    function createClouds() {
        const cloudGeometry = new THREE.SphereGeometry(1, 6, 6);

        for(let i = 0; i < 15; i++) {
            const cloudGroup = new THREE.Group();

            // Create cloud with multiple spheres
            for(let j = 0; j < 8; j++) {
                const cloudPart = new THREE.Mesh(
                    cloudGeometry,
                    new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.4,
                        depthWrite: false
                    })
                );
                cloudPart.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 50
                );
                cloudPart.scale.setScalar(20 + Math.random() * 30);
                cloudGroup.add(cloudPart);
            }

            cloudGroup.position.set(
                (Math.random() - 0.5) * 3000,
                300 + Math.random() * 300,
                (Math.random() - 0.5) * 3000
            );
            cloudGroup.userData.speed = 0.05 + Math.random() * 0.1;
            clouds.push(cloudGroup);
            scene.add(cloudGroup);
        }
    }

    // Enhanced Plant Class
    class Plant {
        constructor(position, type = 'flower') {
            const group = new THREE.Group();

            this.type = type;
            this.watered = false;
            this.health = 0;
            this.position = position;

            if(type === 'flower') {
                // Stylized pot with details
                const potGeo = new THREE.CylinderGeometry(5, 4, 6, 12);
                const potMat = new THREE.MeshPhongMaterial({
                    color: 0x8b4513,
                    roughness: 0.7,
                    metalness: 0.1
                });
                const pot = new THREE.Mesh(potGeo, potMat);
                pot.position.y = 3;
                pot.castShadow = true;
                pot.receiveShadow = true;
                group.add(pot);

                // Pot rim
                const rimGeo = new THREE.TorusGeometry(5, 0.5, 8, 12);
                const rim = new THREE.Mesh(rimGeo, potMat);
                rim.position.y = 6;
                rim.rotation.x = Math.PI / 2;
                group.add(rim);

                // Stem with gradient
                const stemGeo = new THREE.CylinderGeometry(0.4, 0.6, 12, 8);
                const stemMat = new THREE.MeshPhongMaterial({
                    color: 0x228b22,
                    emissive: 0x0a3d0a,
                    emissiveIntensity: 0.2
                });
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = 12;
                group.add(stem);

                // Enhanced flower petals
                this.petals = [];
                const petalCount = 8;
                const petalGeo = new THREE.SphereGeometry(2.5, 8, 6);

                for(let i = 0; i < petalCount; i++) {
                    const petalMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(0.95, 0.8, 0.6),
                        emissive: 0xff1493,
                        emissiveIntensity: 0.1
                    });
                    const petal = new THREE.Mesh(petalGeo, petalMat);
                    const angle = (i / petalCount) * Math.PI * 2;
                    petal.position.set(
                        Math.cos(angle) * 4,
                        18,
                        Math.sin(angle) * 4
                    );
                    petal.scale.set(1.2, 0.6, 1);
                    petal.rotation.z = angle;
                    group.add(petal);
                    this.petals.push(petal);
                }

                // Glowing center
                const centerGeo = new THREE.SphereGeometry(2, 12, 8);
                const centerMat = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5
                });
                const center = new THREE.Mesh(centerGeo, centerMat);
                center.position.y = 18;
                group.add(center);

                // Add glow effect
                const glowGeo = new THREE.SphereGeometry(3, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.y = 18;
                group.add(glow);

                this.pointValue = 10;

            } else if(type === 'tree') {
                // Realistic trunk with bark texture
                const trunkGeo = new THREE.CylinderGeometry(4, 5, 25, 10, 1);
                const trunkMat = new THREE.MeshPhongMaterial({
                    color: 0x4a3c28,
                    roughness: 0.9,
                    metalness: 0
                });

                // Deform trunk for realism
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 12.5;
                trunk.castShadow = true;
                group.add(trunk);

                // Multiple foliage layers
                this.foliageLayers = [];
                for(let i = 0; i < 3; i++) {
                    const foliageGeo = new THREE.DodecahedronGeometry(10 - i * 2, 1);
                    const foliageMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(0.25, 0.8, 0.3 - i * 0.05),
                        flatShading: true,
                        emissive: 0x0a4d0a,
                        emissiveIntensity: 0.1
                    });
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = 28 + i * 5;
                    foliage.rotation.y = Math.random() * Math.PI;
                    foliage.castShadow = true;
                    group.add(foliage);
                    this.foliageLayers.push(foliage);
                }

                this.foliage = this.foliageLayers[0];
                this.pointValue = 20;

            } else if(type === 'bush') {
                // Detailed bush
                const bushGeo = new THREE.IcosahedronGeometry(10, 1);
                const bushMat = new THREE.MeshPhongMaterial({
                    color: 0x2d5016,
                    flatShading: true,
                    emissive: 0x1a300d,
                    emissiveIntensity: 0.2
                });
                this.bush = new THREE.Mesh(bushGeo, bushMat);
                this.bush.position.y = 8;
                this.bush.scale.set(1.8, 1, 1.8);
                this.bush.castShadow = true;
                group.add(this.bush);

                // Add flowers on bush
                for(let i = 0; i < 8; i++) {
                    const flowerGeo = new THREE.SphereGeometry(0.8, 6, 6);
                    const flowerMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.9, 0.9, 0.7),
                        emissive: 0xff00ff,
                        emissiveIntensity: 0.3
                    });
                    const flower = new THREE.Mesh(flowerGeo, flowerMat);
                    flower.position.set(
                        (Math.random() - 0.5) * 15,
                        5 + Math.random() * 8,
                        (Math.random() - 0.5) * 15
                    );
                    group.add(flower);
                }

                this.pointValue = 15;
            }

            // Enhanced indicator light with pulsing
            this.indicator = new THREE.PointLight(0xff0000, 3, 40);
            this.indicator.position.y = 35;
            group.add(this.indicator);

            // 3D water drop icon
            const dropGroup = new THREE.Group();
            const dropGeo = new THREE.SphereGeometry(3, 8, 8);
            const dropMat = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.8,
                emissive: 0x0088ff,
                emissiveIntensity: 0.3
            });
            const drop = new THREE.Mesh(dropGeo, dropMat);
            drop.scale.set(1, 1.5, 1);
            dropGroup.add(drop);

            const dropTip = new THREE.Mesh(
                new THREE.ConeGeometry(2, 4, 8),
                dropMat
            );
            dropTip.position.y = -3;
            dropTip.rotation.x = Math.PI;
            dropGroup.add(dropTip);

            dropGroup.position.y = 40;
            this.waterIcon = dropGroup;
            group.add(dropGroup);

            this.mesh = group;
            this.mesh.position.copy(position);
            scene.add(this.mesh);

            this.updateAppearance();
        }

        water(amount) {
            if(this.watered) return 0;

            this.health = Math.min(100, this.health + amount);

            if(this.health >= 100 && !this.watered) {
                this.watered = true;
                stats.plantsWatered++;
                stats.score += this.pointValue;

                showScorePopup(this.mesh.position, `+${this.pointValue}`);
                createWaterSplash(this.mesh.position, 30);

                updateHUD();

                return this.pointValue;
            }

            this.updateAppearance();
            return 0;
        }

        updateAppearance() {
            const healthRatio = this.health / 100;

            if(this.type === 'flower') {
                this.petals.forEach((petal, i) => {
                    const hue = 0.95 - (1 - healthRatio) * 0.8;
                    const sat = healthRatio * 0.8;
                    const light = 0.3 + healthRatio * 0.3;
                    petal.material.color.setHSL(hue, sat, light);
                    petal.material.emissiveIntensity = healthRatio * 0.2;
                });
            } else if(this.type === 'tree' && this.foliageLayers) {
                this.foliageLayers.forEach((foliage, i) => {
                    const hue = 0.25 - (1 - healthRatio) * 0.15;
                    const sat = healthRatio * 0.8;
                    const light = 0.2 + healthRatio * 0.2;
                    foliage.material.color.setHSL(hue, sat, light);
                });
            } else if(this.type === 'bush' && this.bush) {
                const hue = 0.25 - (1 - healthRatio) * 0.15;
                const sat = healthRatio * 0.7;
                const light = 0.2 + healthRatio * 0.2;
                this.bush.material.color.setHSL(hue, sat, light);
            }

            if(this.watered) {
                this.indicator.color.setHex(0x00ff00);
                this.indicator.intensity = 1.5;
                this.waterIcon.visible = false;
            } else {
                const r = 1;
                const g = healthRatio;
                const b = 0;
                this.indicator.color.setRGB(r, g, b);
                this.indicator.intensity = 3 - healthRatio * 1.5;
                this.waterIcon.visible = true;
            }
        }

        update() {
            if(this.waterIcon && this.waterIcon.visible) {
                this.waterIcon.rotation.y += 0.03;
                this.waterIcon.position.y = 40 + Math.sin(Date.now() * 0.003) * 3;

                // Pulsing effect
                const pulse = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                this.waterIcon.scale.setScalar(pulse);
            }

            if(this.watered) {
                this.mesh.rotation.y += 0.01;

                // Gentle swaying for watered plants
                if(this.type === 'flower' && this.petals) {
                    this.petals.forEach((petal, i) => {
                        petal.position.y = 18 + Math.sin(Date.now() * 0.002 + i) * 0.5;
                    });
                }
            }

            // Pulsing indicator light
            if(this.indicator && !this.watered) {
                this.indicator.intensity = 3 + Math.sin(Date.now() * 0.01) * 1;
            }
        }
    }

    // Enhanced Player Drone Class
    class PlayerDrone {
        constructor() {
            const group = new THREE.Group();

            // Futuristic body design
            const bodyGeo = new THREE.OctahedronGeometry(15, 2);
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0x4facfe,
                emissive: 0x0066cc,
                emissiveIntensity: 0.4,
                metalness: 0.9,
                roughness: 0.1,
                reflectivity: 1
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            group.add(body);

            // Glass cockpit
            const cockpitGeo = new THREE.SphereGeometry(8, 16, 12);
            const cockpitMat = new THREE.MeshPhongMaterial({
                color: 0x88ddff,
                transparent: true,
                opacity: 0.6,
                emissive: 0x4488ff,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
            cockpit.position.y = 5;
            cockpit.scale.set(1, 0.7, 1);
            group.add(cockpit);

            // Animated water tank
            const tankGeo = new THREE.SphereGeometry(10, 16, 16);
            const tankMat = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.5,
                emissive: 0x0088ff,
                emissiveIntensity: 0.2
            });
            const tank = new THREE.Mesh(tankGeo, tankMat);
            tank.position.y = -10;
            tank.scale.set(0.8, 1, 0.8);
            group.add(tank);
            this.waterTank = tank;

            // Water level indicator inside tank
            const waterGeo = new THREE.SphereGeometry(9, 16, 16);
            const waterMat = new THREE.MeshPhongMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0.8,
                emissive: 0x00aaff,
                emissiveIntensity: 0.5
            });
            this.waterLevel = new THREE.Mesh(waterGeo, waterMat);
            this.waterLevel.position.y = -10;
            this.waterLevel.scale.set(0.8, 1, 0.8);
            group.add(this.waterLevel);

            // Enhanced rotors with blur effect
            this.rotors = [];
            this.rotorBlurs = [];
            for(let i = 0; i < 4; i++) {
                const angle = (i/4) * Math.PI * 2;

                // Rotor arm
                const armGeo = new THREE.BoxGeometry(20, 2, 3);
                const armMat = new THREE.MeshPhongMaterial({
                    color: 0x2a2a2a,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const arm = new THREE.Mesh(armGeo, armMat);
                arm.position.x = Math.cos(angle) * 10;
                arm.position.z = Math.sin(angle) * 10;
                arm.position.y = 3;
                arm.rotation.y = angle;
                group.add(arm);

                // Rotor blade
                const rotorGeo = new THREE.BoxGeometry(15, 0.5, 4);
                const rotorMat = new THREE.MeshBasicMaterial({
                    color: 0x111111,
                    transparent: true,
                    opacity: 0.9
                });
                const rotor = new THREE.Mesh(rotorGeo, rotorMat);
                rotor.position.x = Math.cos(angle) * 18;
                rotor.position.z = Math.sin(angle) * 18;
                rotor.position.y = 6;
                group.add(rotor);
                this.rotors.push(rotor);

                // Rotor blur effect
                const blurGeo = new THREE.CylinderGeometry(15, 15, 0.2, 32);
                const blurMat = new THREE.MeshBasicMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.2
                });
                const blur = new THREE.Mesh(blurGeo, blurMat);
                blur.position.x = Math.cos(angle) * 18;
                blur.position.z = Math.sin(angle) * 18;
                blur.position.y = 6;
                group.add(blur);
                this.rotorBlurs.push(blur);
            }

            // Advanced water sprayer
            const sprayerGeo = new THREE.ConeGeometry(4, 10, 12);
            const sprayerMat = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00aaff,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });
            const sprayer = new THREE.Mesh(sprayerGeo, sprayerMat);
            sprayer.position.y = -15;
            sprayer.rotation.x = Math.PI;
            group.add(sprayer);

            // LED lights
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            for(let i = 0; i < 4; i++) {
                const angle = (i/4) * Math.PI * 2;
                const led = new THREE.PointLight(colors[i], 0.5, 20);
                led.position.x = Math.cos(angle) * 12;
                led.position.z = Math.sin(angle) * 12;
                group.add(led);
            }

            // Main spotlight
            const spotlight = new THREE.SpotLight(0xffffff, 2, 500, Math.PI/6, 0.3, 1);
            spotlight.position.set(0, -10, 15);
            spotlight.target.position.set(0, -100, 100);
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 1024;
            spotlight.shadow.mapSize.height = 1024;
            group.add(spotlight);
            group.add(spotlight.target);

            // Drone glow effect
            const glowGeo = new THREE.SphereGeometry(20, 12, 12);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            group.add(glow);

            this.mesh = group;
            this.mesh.position.set(0, 100, 0);
            this.velocity = new THREE.Vector3(0, 0, 0);
            this.isWatering = false;
            this.lastWater = 0;

            scene.add(this.mesh);
        }

        update() {
            // Animate rotors with speed variation
            const rotorSpeed = 0.6 + this.velocity.length() * 2;
            this.rotors.forEach((rotor, i) => {
                rotor.rotation.y += rotorSpeed;
                this.rotorBlurs[i].rotation.y += rotorSpeed * 0.5;
                this.rotorBlurs[i].visible = rotorSpeed > 0.8;
            });

            // Movement with improved physics
            const moveSpeed = 0.5;
            const rotSpeed = 0.05;

            if(keys['arrowleft']) {
                this.mesh.rotation.y += rotSpeed;
            }
            if(keys['arrowright']) {
                this.mesh.rotation.y -= rotSpeed;
            }

            if(keys['arrowup']) {
                this.velocity.x -= Math.sin(this.mesh.rotation.y) * moveSpeed;
                this.velocity.z -= Math.cos(this.mesh.rotation.y) * moveSpeed;
            }
            if(keys['arrowdown']) {
                this.velocity.x += Math.sin(this.mesh.rotation.y) * moveSpeed * 0.6;
                this.velocity.z += Math.cos(this.mesh.rotation.y) * moveSpeed * 0.6;
            }

            if(keys[' ']) {
                this.velocity.y = moveSpeed * 2.5;
            } else if(keys['shift']) {
                this.velocity.y = -moveSpeed * 2.5;
            } else {
                this.velocity.y *= 0.85;
            }

            // Advanced physics drag
            this.velocity.x *= 0.92;
            this.velocity.z *= 0.92;

            this.mesh.position.add(this.velocity);

            // Boundaries
            const mapLimit = MAP_SIZE/2 - 50;
            this.mesh.position.x = Math.max(-mapLimit, Math.min(mapLimit, this.mesh.position.x));
            this.mesh.position.z = Math.max(-mapLimit, Math.min(mapLimit, this.mesh.position.z));
            this.mesh.position.y = Math.max(20, Math.min(500, this.mesh.position.y));

            // Dynamic tilt
            const targetTiltX = -this.velocity.z * 0.08;
            const targetTiltZ = -this.velocity.x * 0.08;
            this.mesh.rotation.x += (targetTiltX - this.mesh.rotation.x) * 0.15;
            this.mesh.rotation.z += (targetTiltZ - this.mesh.rotation.z) * 0.15;

            // Animate water tank
            const waterRatio = stats.waterLevel / 100;
            this.waterLevel.scale.y = 0.3 + waterRatio * 0.7;
            this.waterLevel.position.y = -10 - (1 - waterRatio) * 5;
            this.waterTank.material.opacity = 0.3 + waterRatio * 0.4;

            // Water tank glow effect
            this.waterTank.material.emissiveIntensity = waterRatio * 0.3;
            this.waterLevel.material.emissiveIntensity = waterRatio * 0.5;

            // Update HUD
            document.getElementById('posX').textContent = Math.floor(this.mesh.position.x);
            document.getElementById('posZ').textContent = Math.floor(this.mesh.position.z);
            document.getElementById('altitude').textContent = Math.floor(this.mesh.position.y);
        }

        waterPlants() {
            const now = Date.now();
            if(now - this.lastWater < 80) return;
            if(stats.waterLevel <= 0) {
                showModeIndicator("üíß R√©servoir vide! Direction le lac!");
                return;
            }

            // Create realistic water spray
            for(let i = 0; i < 5; i++) {
                const dropGeo = new THREE.SphereGeometry(0.8 + Math.random() * 0.5);
                const dropMat = new THREE.MeshPhongMaterial({
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x0088ff,
                    emissiveIntensity: 0.3
                });
                const drop = new THREE.Mesh(dropGeo, dropMat);
                drop.position.copy(this.mesh.position);
                drop.position.y -= 15;

                const spread = 3;
                drop.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    -8 - Math.random() * 2,
                    (Math.random() - 0.5) * spread
                );
                drop.life = 40;
                scene.add(drop);
                waterDrops.push(drop);
            }

            stats.waterLevel = Math.max(0, stats.waterLevel - 0.8);
            updateHUD();
            this.lastWater = now;

            // Check for plants to water with distance-based effectiveness
            plants.forEach(plant => {
                const dist = plant.mesh.position.distanceTo(this.mesh.position);
                if(dist < 60 && this.mesh.position.y < 120) {
                    const effectiveness = Math.max(0, 1 - (dist / 60));
                    plant.water(8 * effectiveness);
                }
            });
        }

        refillWater() {
            if(lakeMesh) {
                const dist = this.mesh.position.distanceTo(lakeMesh.position);
                if(dist < 80 && this.mesh.position.y < 60) {
                    const oldLevel = stats.waterLevel;
                    stats.waterLevel = Math.min(100, stats.waterLevel + 3);

                    if(oldLevel < 100 && stats.waterLevel >= 100) {
                        showModeIndicator("üíß R√©servoir plein!");
                        createWaterSplash(this.mesh.position, 20);
                    }

                    // Create refill effect
                    if(Math.random() < 0.3) {
                        const bubble = new THREE.Mesh(
                            new THREE.SphereGeometry(Math.random() * 2 + 1),
                            new THREE.MeshBasicMaterial({
                                color: 0x00aaff,
                                transparent: true,
                                opacity: 0.6
                            })
                        );
                        bubble.position.copy(lakeMesh.position);
                        bubble.position.x += (Math.random() - 0.5) * 50;
                        bubble.position.z += (Math.random() - 0.5) * 50;
                        scene.add(bubble);

                        particles.push({
                            mesh: bubble,
                            position: bubble.position,
                            velocity: new THREE.Vector3(0, 2, 0),
                            life: 30
                        });
                    }

                    updateHUD();
                }
            }
        }
    }

    // Generate enhanced city map
    function generateCity() {
        // Textured ground with grass
        const groundGeo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 50, 50);
        const groundMat = new THREE.MeshPhongMaterial({
            color: 0x3a5f0b,
            roughness: 0.8,
            metalness: 0.1
        });

        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;

        // Add terrain variation
        const vertices = ground.geometry.attributes.position.array;
        for(let i = 0; i < vertices.length; i += 3) {
            vertices[i + 1] = Math.sin(vertices[i] * 0.01) * 5 + Math.cos(vertices[i + 2] * 0.01) * 5;
        }
        ground.geometry.computeVertexNormals();
        scene.add(ground);

        // Beautiful central lake
        const lakeGeo = new THREE.CircleGeometry(120, 64);
        const lakeMat = new THREE.MeshPhongMaterial({
            color: 0x006994,
            transparent: true,
            opacity: 0.7,
            shininess: 100,
            reflectivity: 1,
            emissive: 0x004466,
            emissiveIntensity: 0.1
        });
        lakeMesh = new THREE.Mesh(lakeGeo, lakeMat);
        lakeMesh.rotation.x = -Math.PI/2;
        lakeMesh.position.y = 0.5;
        lakeMesh.receiveShadow = true;
        scene.add(lakeMesh);
        waterRefillStation = lakeMesh;

        // Lake shore decoration
        const shoreGeo = new THREE.TorusGeometry(125, 5, 8, 32);
        const shoreMat = new THREE.MeshPhongMaterial({
            color: 0x8b7355,
            roughness: 0.9
        });
        const shore = new THREE.Mesh(shoreGeo, shoreMat);
        shore.rotation.x = -Math.PI/2;
        shore.position.y = 1;
        scene.add(shore);

        // Animated fountain
        const fountainBase = new THREE.Mesh(
            new THREE.CylinderGeometry(15, 18, 8, 16),
            new THREE.MeshPhongMaterial({
                color: 0x808080,
                metalness: 0.5,
                roughness: 0.3
            })
        );
        fountainBase.position.y = 4;
        fountainBase.castShadow = true;
        scene.add(fountainBase);

        // Fountain water jet
        const jetGeo = new THREE.CylinderGeometry(1, 2, 20, 8);
        const jetMat = new THREE.MeshPhongMaterial({
            color: 0x00aaff,
            transparent: true,
            opacity: 0.6,
            emissive: 0x0088ff,
            emissiveIntensity: 0.3
        });
        const jet = new THREE.Mesh(jetGeo, jetMat);
        jet.position.y = 15;
        scene.add(jet);

        // Generate city blocks with roads
        generateRoads();
        generateBuildings();
        generateParks();
        generatePlants();
        createClouds();
    }

    function generateRoads() {
        const roadMat = new THREE.MeshPhongMaterial({
            color: 0x333333,
            roughness: 0.9
        });

        const linesMat = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            emissive: 0xffff00
        });

        for(let i = 1; i < CITY_BLOCKS; i++) {
            // Main roads
            const roadH = new THREE.Mesh(
                new THREE.PlaneGeometry(MAP_SIZE, 40),
                roadMat
            );
            roadH.rotation.x = -Math.PI/2;
            roadH.position.set(0, 0.2, -MAP_SIZE/2 + i * BLOCK_SIZE);
            roadH.receiveShadow = true;
            scene.add(roadH);

            // Road lines
            const lineH = new THREE.Mesh(
                new THREE.PlaneGeometry(MAP_SIZE, 2),
                linesMat
            );
            lineH.rotation.x = -Math.PI/2;
            lineH.position.set(0, 0.3, -MAP_SIZE/2 + i * BLOCK_SIZE);
            scene.add(lineH);

            const roadV = new THREE.Mesh(
                new THREE.PlaneGeometry(40, MAP_SIZE),
                roadMat
            );
            roadV.rotation.x = -Math.PI/2;
            roadV.position.set(-MAP_SIZE/2 + i * BLOCK_SIZE, 0.2, 0);
            roadV.receiveShadow = true;
            scene.add(roadV);

            const lineV = new THREE.Mesh(
                new THREE.PlaneGeometry(2, MAP_SIZE),
                linesMat
            );
            lineV.rotation.x = -Math.PI/2;
            lineV.position.set(-MAP_SIZE/2 + i * BLOCK_SIZE, 0.3, 0);
            scene.add(lineV);
        }
    }

    function generateBuildings() {
        for(let i = 0; i < 25; i++) {
            const width = 50 + Math.random() * 80;
            const height = 60 + Math.random() * 200;
            const depth = 50 + Math.random() * 80;

            const buildingGeo = new THREE.BoxGeometry(width, height, depth);
            const hue = 0.55 + Math.random() * 0.1;
            const buildingMat = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(hue, 0.2, 0.3),
                metalness: 0.5,
                roughness: 0.5
            });

            const building = new THREE.Mesh(buildingGeo, buildingMat);

            let x, z;
            do {
                x = (Math.random() - 0.5) * (MAP_SIZE - 200);
                z = (Math.random() - 0.5) * (MAP_SIZE - 200);
            } while(Math.sqrt(x*x + z*z) < 200);

            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);

            // Windows with emissive glow
            const windowRows = Math.floor(height / 15);
            const windowCols = Math.floor(width / 15);

            for(let row = 1; row < windowRows; row++) {
                for(let col = 1; col < windowCols; col++) {
                    if(Math.random() > 0.3) {
                        const windowGeo = new THREE.PlaneGeometry(8, 10);
                        const windowMat = new THREE.MeshBasicMaterial({
                            color: 0xffffaa,
                            emissive: 0xffff88,
                            emissiveIntensity: Math.random()
                        });
                        const window = new THREE.Mesh(windowGeo, windowMat);
                        window.position.set(
                            x + (col - windowCols/2) * 15,
                            row * 15,
                            z + depth/2 + 0.1
                        );
                        scene.add(window);
                    }
                }
            }
        }
    }

    function generateParks() {
        // Small parks around the city
        for(let i = 0; i < 5; i++) {
            const parkSize = 80 + Math.random() * 40;
            const parkGeo = new THREE.CircleGeometry(parkSize, 32);
            const parkMat = new THREE.MeshPhongMaterial({
                color: 0x2d5016,
                roughness: 0.9
            });

            const park = new THREE.Mesh(parkGeo, parkMat);
            park.rotation.x = -Math.PI/2;
            park.position.set(
                (Math.random() - 0.5) * (MAP_SIZE - 400),
                0.1,
                (Math.random() - 0.5) * (MAP_SIZE - 400)
            );

            if(park.position.length() > 200) {
                park.receiveShadow = true;
                scene.add(park);

                // Add trees to parks
                const treeCount = 3 + Math.floor(Math.random() * 5);
                for(let j = 0; j < treeCount; j++) {
                    const angle = (j / treeCount) * Math.PI * 2;
                    const dist = parkSize * 0.3 + Math.random() * parkSize * 0.4;

                    const treeGeo = new THREE.ConeGeometry(8, 20, 8);
                    const treeMat = new THREE.MeshPhongMaterial({
                        color: 0x0d5016,
                        flatShading: true
                    });
                    const tree = new THREE.Mesh(treeGeo, treeMat);
                    tree.position.set(
                        park.position.x + Math.cos(angle) * dist,
                        10,
                        park.position.z + Math.sin(angle) * dist
                    );
                    tree.castShadow = true;
                    scene.add(tree);
                }
            }
        }
    }

    function generatePlants() {
        plants.forEach(plant => {
            scene.remove(plant.mesh);
        });
        plants = [];

        const plantCount = 20 + currentLevel * 5;

        for(let i = 0; i < plantCount; i++) {
            const types = ['flower', 'tree', 'bush'];
            const weights = [0.5, 0.3, 0.2];
            const random = Math.random();
            let type = 'flower';

            if(random < weights[0]) type = 'flower';
            else if(random < weights[0] + weights[1]) type = 'tree';
            else type = 'bush';

            let x, z;
            let validPosition = false;

            while(!validPosition) {
                x = (Math.random() - 0.5) * (MAP_SIZE - 150);
                z = (Math.random() - 0.5) * (MAP_SIZE - 150);

                if(Math.sqrt(x*x + z*z) > 180) {
                    validPosition = true;
                    for(let plant of plants) {
                        const dist = Math.sqrt(
                            Math.pow(x - plant.position.x, 2) +
                            Math.pow(z - plant.position.z, 2)
                        );
                        if(dist < 60) {
                            validPosition = false;
                            break;
                        }
                    }
                }
            }

            const plant = new Plant(new THREE.Vector3(x, 0, z), type);
            plants.push(plant);
        }



        document.getElementById('totalPlants').textContent = plants.length;
    }

    // Enhanced Effects
    function createWaterSplash(position, count = 20) {
        for(let i = 0; i < count; i++) {
            const particleGeo = new THREE.SphereGeometry(Math.random() * 1 + 0.5);
            const particleMat = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.9,
                emissive: 0x0088ff,
                emissiveIntensity: 0.4
            });
            const particle = new THREE.Mesh(particleGeo, particleMat);
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 8,
                Math.random() * 15,
                (Math.random() - 0.5) * 8
            );
            particle.life = 40;
            scene.add(particle);
            particles.push({
                mesh: particle,
                position: particle.position,
                velocity: particle.velocity,
                life: particle.life
            });
        }

        // Add water ring effect
        const ringGeo = new THREE.TorusGeometry(5, 0.5, 8, 16);
        const ringMat = new THREE.MeshBasicMaterial({
            color: 0x00aaff,
            transparent: true,
            opacity: 0.6
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.copy(position);
        ring.position.y = 1;
        ring.rotation.x = Math.PI / 2;
        scene.add(ring);

        // Animate ring expansion
        const animateRing = () => {
            ring.scale.x += 0.5;
            ring.scale.y += 0.5;
            ring.material.opacity -= 0.02;
            if(ring.material.opacity > 0) {
                requestAnimationFrame(animateRing);
            } else {
                scene.remove(ring);
            }
        };
        animateRing();
    }

    function showScorePopup(position, text) {
        const popup = document.createElement('div');
        popup.className = 'score-popup';
        popup.textContent = text;

        const vector = position.clone();
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

        popup.style.left = x + 'px';
        popup.style.top = y + 'px';

        document.body.appendChild(popup);
        setTimeout(() => popup.remove(), 2000);
    }

    function showModeIndicator(text) {
        const indicator = document.createElement('div');
        indicator.className = 'mode-indicator';
        indicator.textContent = text;
        indicator.style.color = mode === 'combat' ? '#ff6666' : '#00ffaa';
        document.body.appendChild(indicator);
        setTimeout(() => indicator.remove(), 2500);
    }

    // Game Management
    function startWateringMode() {
        mode = 'watering';
        stats.plantsWatered = 0;
        stats.waterLevel = 100;
        startTime = Date.now();
        generatePlants();

        enemies.forEach(enemy => scene.remove(enemy.mesh || enemy));
        enemies = [];

        document.getElementById('gameMode').textContent = 'ARROSAGE';
        showModeIndicator("üíß Mode Arrosage - Sauvez les plantes!");
        updateHUD();
    }

    function startCombatMode() {
        mode = 'combat';
        document.getElementById('gameMode').textContent = 'COMBAT';
        showModeIndicator("‚öîÔ∏è Mode Combat - D√©fendez le jardin!");
        spawnEnemies();
    }

    function spawnEnemies() {
        for(let i = 0; i < 8; i++) {
            const enemyGeo = new THREE.DodecahedronGeometry(12, 0);
            const enemyMat = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0xaa0000,
                emissiveIntensity: 0.3
            });
            const enemy = new THREE.Mesh(enemyGeo, enemyMat);
            enemy.position.set(
                (Math.random() - 0.5) * 600,
                50 + Math.random() * 150,
                (Math.random() - 0.5) * 600
            );
            enemy.velocity = new THREE.Vector3();
            enemy.life = 100;
            scene.add(enemy);
            enemies.push(enemy);
        }
    }

    function updateHUD() {
        document.getElementById('score').textContent = stats.score;
        document.getElementById('plantsWatered').textContent = stats.plantsWatered;
        document.getElementById('water').style.width = stats.waterLevel + '%';
        document.getElementById('highScore').textContent = stats.highScore;

        if(stats.score > stats.highScore) {
            stats.highScore = stats.score;
            localStorage.setItem('droneHighScore', stats.highScore);
        }

        if(stats.plantsWatered >= plants.length && plants.length > 0) {
            levelComplete();
        }
    }

    function updateTimer() {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('timer').textContent =
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function levelComplete() {
        const completeDiv = document.getElementById('levelComplete');
        document.getElementById('finalScore').textContent = stats.score;
        document.getElementById('finalPlants').textContent = stats.plantsWatered;
        document.getElementById('finalTime').textContent = document.getElementById('timer').textContent;
        completeDiv.style.display = 'block';

        showModeIndicator("üéâ BRAVO! Niveau termin√©!");

        // Celebration effects
        for(let i = 0; i < 50; i++) {
            setTimeout(() => {
                const pos = new THREE.Vector3(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 200,
                    (Math.random() - 0.5) * 200
                );
                createWaterSplash(pos, 10);
            }, i * 50);
        }
    }

    function nextLevel() {
        currentLevel++;
        document.getElementById('levelComplete').style.display = 'none';
        startWateringMode();
        showModeIndicator(`üå± NIVEAU ${currentLevel} - Difficult√© augment√©e!`);
    }

    function restartLevel() {
        stats.score = 0;
        stats.plantsWatered = 0;
        stats.waterLevel = 100;
        startTime = Date.now();
        playerDrone.mesh.position.set(0, 100, 0);
        playerDrone.velocity.set(0, 0, 0);
        generatePlants();
        updateHUD();
        showModeIndicator("üîÑ Niveau recommenc√©!");
    }

    function toggleCamera() {
        cameraMode = (cameraMode + 1) % 3;
        const modes = ['3√®me Personne', 'FPS', 'Vue du Dessus'];
        document.getElementById('cameraBtn').textContent = modes[cameraMode];
    }

    function updateCamera() {
        if(!playerDrone) return;

        switch(cameraMode) {
            case 0: // Third person
                const offset = new THREE.Vector3(0, 60, 120);
                offset.applyQuaternion(playerDrone.mesh.quaternion);
                camera.position.lerp(
                    playerDrone.mesh.position.clone().add(offset),
                    0.1
                );
                camera.lookAt(playerDrone.mesh.position);
                break;
            case 1: // FPS
                camera.position.copy(playerDrone.mesh.position);
                camera.position.y += 8;
                const lookDir = new THREE.Vector3(0, 0, -100);
                lookDir.applyQuaternion(playerDrone.mesh.quaternion);
                camera.lookAt(playerDrone.mesh.position.clone().add(lookDir));
                break;
            case 2: // Top down
                camera.position.set(
                    playerDrone.mesh.position.x,
                    playerDrone.mesh.position.y + 250,
                    playerDrone.mesh.position.z + 50
                );
                camera.lookAt(playerDrone.mesh.position);
                break;
        }
    }

    function updateRadar() {
        if(!playerDrone) return;

        const canvas = document.getElementById('radarCanvas');
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, 200, 200);

        // Radar grid
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
        for(let i = 0; i <= 200; i += 20) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, 200);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(200, i);
            ctx.stroke();
        }

        // Radar circles
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
        for(let r = 25; r <= 100; r += 25) {
            ctx.beginPath();
            ctx.arc(100, 100, r, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Player drone
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(100, 100, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Plants on radar
        plants.forEach(plant => {
            const dx = (plant.mesh.position.x - playerDrone.mesh.position.x) / 5;
            const dz = (plant.mesh.position.z - playerDrone.mesh.position.z) / 5;

            if(Math.abs(dx) < 100 && Math.abs(dz) < 100) {
                if(plant.watered) {
                    ctx.fillStyle = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                } else {
                    const healthRatio = plant.health / 100;
                    const r = Math.floor(255);
                    const g = Math.floor(255 * healthRatio);
                    ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
                    ctx.strokeStyle = ctx.fillStyle;
                }

                ctx.beginPath();
                ctx.arc(100 + dx, 100 + dz, plant.watered ? 2 : 4, 0, Math.PI * 2);
                ctx.fill();

                if(!plant.watered) {
                    ctx.beginPath();
                    ctx.arc(100 + dx, 100 + dz, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        });

        // Water source (lake)
        if(lakeMesh) {
            const dx = (lakeMesh.position.x - playerDrone.mesh.position.x) / 5;
            const dz = (lakeMesh.position.z - playerDrone.mesh.position.z) / 5;

            if(Math.abs(dx) < 100 && Math.abs(dz) < 100) {
                ctx.fillStyle = '#0088ff';
                ctx.beginPath();
                ctx.arc(100 + dx, 100 + dz, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#00aaff';
                ctx.beginPath();
                ctx.arc(100 + dx, 100 + dz, 18, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Direction indicator
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(100, 100);
        const angle = -playerDrone.mesh.rotation.y;
        ctx.lineTo(100 + Math.sin(angle) * 25, 100 - Math.cos(angle) * 25);
        ctx.stroke();
        ctx.lineWidth = 1;
    }

    // Initialize game
    playerDrone = new PlayerDrone();
    generateCity();
    startWateringMode();

    // Enhanced input handling
    window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;

        if(e.key.toLowerCase() === 'w') {
            playerDrone.waterPlants();
        }
        if(e.key.toLowerCase() === 'r') {
            playerDrone.refillWater();
        }
        if(e.key.toLowerCase() === 'c') {
            toggleCamera();
        }
    });

    window.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
    });

    window.addEventListener('click', () => {
        if(mode === 'watering') {
            playerDrone.waterPlants();
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    // Main animation loop
    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;

        // Update player
        if(playerDrone) {
            playerDrone.update();

            if(keys['r']) {
                playerDrone.refillWater();
            }
        }

        // Animate clouds
        clouds.forEach(cloud => {
            cloud.position.x += cloud.userData.speed;
            if(cloud.position.x > 2000) cloud.position.x = -2000;
            cloud.rotation.y += 0.001;
        });

        // Update plants
        plants.forEach(plant => plant.update());

        // Update water drops with physics
        waterDrops = waterDrops.filter(drop => {
            drop.position.add(drop.velocity);
            drop.velocity.y -= 0.4; // Gravity
            drop.life--;

            // Add air resistance
            drop.velocity.x *= 0.98;
            drop.velocity.z *= 0.98;

            // Water drop trails
            if(drop.life % 2 === 0) {
                const trail = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({
                        color: 0x00aaff,
                        transparent: true,
                        opacity: 0.4
                    })
                );
                trail.position.copy(drop.position);
                scene.add(trail);
                setTimeout(() => scene.remove(trail), 200);
            }

            if(drop.position.y <= 0) {
                createWaterSplash(drop.position, 5);
                scene.remove(drop);
                return false;
            }

            if(drop.life <= 0) {
                scene.remove(drop);
                return false;
            }

            // Scale down as it falls
            const scale = drop.life / 40;
            drop.scale.setScalar(scale);
            drop.material.opacity = 0.9 * scale;

            return true;
        });

        // Update particle effects
        particles = particles.filter(p => {
            if(p.mesh && p.velocity) {
                p.position.add(p.velocity);
                p.velocity.y -= 0.5;
                p.life--;

                if(p.mesh.material) {
                    p.mesh.material.opacity = p.life / 40;
                }

                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    return false;
                }
            }
            return true;
        });

        // Update enemies in combat mode
        if(mode === 'combat') {
            enemies = enemies.filter(enemy => {
                if(enemy && enemy.position) {
                    // Simple AI movement
                    const toPlayer = playerDrone.mesh.position.clone().sub(enemy.position);
                    const dist = toPlayer.length();

                    if(dist > 100) {
                        toPlayer.normalize();
                        enemy.velocity.add(toPlayer.multiplyScalar(0.2));
                    }

                    enemy.velocity.multiplyScalar(0.95);
                    enemy.position.add(enemy.velocity);
                    enemy.rotation.x += 0.02;
                    enemy.rotation.y += 0.03;

                    return true;
                }
                return false;
            });
        }

        // Dynamic lighting based on time
        const dayProgress = (Math.sin(time * 0.02) + 1) / 2;
        sun.intensity = 1.5 + dayProgress * 0.5;
        sun.position.x = Math.cos(time * 0.02) * 500;
        sun.position.y = 600 + Math.sin(time * 0.02) * 200;

        // Update sky color
        sky.material.uniforms.topColor.value.setHSL(0.55, 0.5, 0.5 + dayProgress * 0.2);
        sky.material.uniforms.bottomColor.value.setHSL(0.08, 0.8, 0.6 + dayProgress * 0.2);

        // Fog density based on altitude
        if(playerDrone) {
            const heightFactor = Math.min(playerDrone.mesh.position.y / 500, 1);
            scene.fog.density = 0.0003 - heightFactor * 0.0002;
        }

        // Update zone display
        let zone = "Centre Ville";
        if(playerDrone) {
            const px = playerDrone.mesh.position.x;
            const pz = playerDrone.mesh.position.z;

            if(Math.sqrt(px*px + pz*pz) < 120) {
                zone = "üåä Lac Central (Recharge üíß)";
                // Add blue tint when near water
                if(Math.sqrt(px*px + pz*pz) < 80 && playerDrone.mesh.position.y < 60) {
                    renderer.toneMappingExposure = 1.6;
                } else {
                    renderer.toneMappingExposure = 1.4;
                }
            } else if(px > MAP_SIZE/3) {
                zone = "üè¢ Quartier Est";
            } else if(px < -MAP_SIZE/3) {
                zone = "üèõÔ∏è Quartier Ouest";
            } else if(pz > MAP_SIZE/3) {
                zone = "üè≠ Zone Industrielle Nord";
            } else if(pz < -MAP_SIZE/3) {
                zone = "üèòÔ∏è Banlieue Sud";
            } else {
                zone = "üåÜ Centre Ville";
            }
        }
        document.getElementById('zone').textContent = zone;

        updateCamera();
        updateRadar();
        updateTimer();

        // Render scene
        renderer.render(scene, camera);
    }

    // Start animation
    animate();

    // Initial welcome message
    setTimeout(() => {
        showModeIndicator("üå± Bienvenue! Arrosez les plantes!");
        setTimeout(() => {
            showModeIndicator("üíß Rechargez au lac central!");
        }, 3000);
    }, 1000);
</script>
</body>
</html>